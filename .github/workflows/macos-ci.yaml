name: macos-ci

on:
  workflow_dispatch: {}
  push:
    branches: [main, master]
    paths-ignore:
      - ".github/*.yml"
      - ".github/*.yaml"
      - ".github/**/*.yml"
      - ".github/**/*.yaml"
      - "**/*.md"
  pull_request:
    branches: [main, master]
    paths-ignore:
      - ".github/*.yml"
      - ".github/*.yaml"
      - ".github/**/*.yml"
      - ".github/**/*.yaml"
      - "**/*.md"

jobs:
  build-portable-dmg:
    runs-on: macos-latest
    timeout-minutes: 45
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v5.0.0

      - name: Compute dependency SHAs (for cache key)
        id: dep-shas
        shell: bash
        run: |
          set -euo pipefail
          echo "mbe_sha=$(git ls-remote https://github.com/arancormonk/mbelib-neo HEAD | cut -f1)" >> "$GITHUB_OUTPUT"
          echo "codec2_sha=$(git ls-remote https://github.com/arancormonk/codec2 HEAD | cut -f1)" >> "$GITHUB_OUTPUT"
          echo "itpp_sha=$(git ls-remote https://github.com/arancormonk/itpp HEAD | cut -f1)" >> "$GITHUB_OUTPUT"
          echo "rtlsdr_sha=$(git ls-remote https://github.com/arancormonk/rtl-sdr HEAD | cut -f1)" >> "$GITHUB_OUTPUT"

      - name: Prepare dependency environment
        shell: bash
        run: |
          set -euxo pipefail
          echo "DEPS_PREFIX=${GITHUB_WORKSPACE}/.deps" >> "$GITHUB_ENV"
          # Homebrew locations (arm64=/opt/homebrew, x86_64=/usr/local)
          HB_PREFIX=$(brew --prefix)
          echo "HB_PREFIX=$HB_PREFIX" >> "$GITHUB_ENV"
          echo "PKG_CONFIG_PATH=${GITHUB_WORKSPACE}/.deps/lib/pkgconfig:${GITHUB_WORKSPACE}/.deps/lib64/pkgconfig:${HB_PREFIX}/lib/pkgconfig:/usr/local/lib/pkgconfig:${PKG_CONFIG_PATH:-}" >> "$GITHUB_ENV"
          echo "CMAKE_PREFIX_PATH=${GITHUB_WORKSPACE}/.deps:${HB_PREFIX}:/usr/local:${CMAKE_PREFIX_PATH:-}" >> "$GITHUB_ENV"
          echo "DYLD_LIBRARY_PATH=${GITHUB_WORKSPACE}/.deps/lib:${GITHUB_WORKSPACE}/.deps/lib64:${DYLD_LIBRARY_PATH:-}" >> "$GITHUB_ENV"

      - name: Restore dependency cache
        uses: actions/cache@v4.2.4
        with:
          path: ${{ env.DEPS_PREFIX }}
          key: deps-${{ runner.os }}-${{ steps.dep-shas.outputs.mbe_sha }}-${{ steps.dep-shas.outputs.codec2_sha }}-${{ steps.dep-shas.outputs.itpp_sha }}-${{ steps.dep-shas.outputs.rtlsdr_sha }}
          restore-keys: |
            deps-${{ runner.os }}-

      - name: Install base toolchain + libs (Homebrew)
        shell: bash
        run: |
          set -euxo pipefail
          brew update
          # Many deps we build from source (cached) to align with Linux/Windows flows
          brew install cmake ninja pkg-config ccache \
            libsndfile pulseaudio fftw libusb ncurses
          # Prefer Homebrew packages when available
          brew install codec2 rtl-sdr || true
          # ITPP may not be in core; try core first, then brewsci tap
          if ! brew list --versions itpp >/dev/null 2>&1; then
            brew install itpp || true
          fi
          if ! brew list --versions itpp >/dev/null 2>&1; then
            brew tap brewsci/science || true
            brew install brewsci/science/itpp || true
          fi
          brew --version
          cmake --version
          pkg-config --version

      - name: Prepare ccache environment
        shell: bash
        run: |
          set -euxo pipefail
          echo "CCACHE_DIR=${GITHUB_WORKSPACE}/.ccache" >> "$GITHUB_ENV"
          echo "CC=ccache clang" >> "$GITHUB_ENV"
          echo "CXX=ccache clang++" >> "$GITHUB_ENV"
          echo "CCACHE_BASEDIR=${GITHUB_WORKSPACE}" >> "$GITHUB_ENV"
          echo "CCACHE_NOHASHDIR=true" >> "$GITHUB_ENV"
          echo "CCACHE_SLOPPINESS=time_macros" >> "$GITHUB_ENV"
          mkdir -p "${GITHUB_WORKSPACE}/.ccache"

      - name: Restore ccache
        uses: actions/cache@v4.2.4
        with:
          path: ${{ env.CCACHE_DIR }}
          key: ccache-${{ runner.os }}-${{ github.sha }}
          restore-keys: |
            ccache-${{ runner.os }}-

      - name: Initialize ccache
        shell: bash
        run: |
          ccache --version
          ccache --zero-stats
          ccache --set-config=max_size=500M
          ccache --set-config=compression=true

      - name: Build and install mbelib-neo (required, cached)
        shell: bash
        run: |
          set -euxo pipefail
          if [ ! -f "$DEPS_PREFIX/lib/pkgconfig/libmbe-neo.pc" ] && [ ! -f "$DEPS_PREFIX/lib64/pkgconfig/libmbe-neo.pc" ]; then
            git clone --depth 1 https://github.com/arancormonk/mbelib-neo /tmp/mbelib-neo
            git -C /tmp/mbelib-neo fetch --depth 1 origin ${{ steps.dep-shas.outputs.mbe_sha }}
            git -C /tmp/mbelib-neo checkout ${{ steps.dep-shas.outputs.mbe_sha }}
            cmake -S /tmp/mbelib-neo -B /tmp/mbelib-neo/build -G Ninja \
              -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=ON \
              -DCMAKE_INSTALL_PREFIX="$DEPS_PREFIX" \
              -DCMAKE_OSX_ARCHITECTURES=arm64
            cmake --build /tmp/mbelib-neo/build -j
            cmake --install /tmp/mbelib-neo/build
          fi

      - name: Ensure codec2 (cached fallback if not found)
        shell: bash
        run: |
          set -euxo pipefail
          if ! pkg-config --exists codec2 && [ ! -f "$DEPS_PREFIX/lib/pkgconfig/codec2.pc" ] && [ ! -f "$DEPS_PREFIX/lib64/pkgconfig/codec2.pc" ]; then
            git clone --depth 1 https://github.com/arancormonk/codec2 /tmp/codec2
            git -C /tmp/codec2 fetch --depth 1 origin ${{ steps.dep-shas.outputs.codec2_sha }}
            git -C /tmp/codec2 checkout ${{ steps.dep-shas.outputs.codec2_sha }}
            cmake -S /tmp/codec2 -B /tmp/codec2/build -G Ninja \
              -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=ON \
              -DCMAKE_INSTALL_PREFIX="$DEPS_PREFIX" \
              -DCMAKE_OSX_ARCHITECTURES=arm64
            cmake --build /tmp/codec2/build -j
            cmake --install /tmp/codec2/build
          fi

      - name: Ensure ITPP (cached fallback if not found)
        shell: bash
        run: |
          set -euxo pipefail
          if ! pkg-config --exists itpp && [ ! -f "$DEPS_PREFIX/lib/pkgconfig/itpp.pc" ] && [ ! -f "$DEPS_PREFIX/lib64/pkgconfig/itpp.pc" ]; then
            git clone --depth 1 https://github.com/arancormonk/itpp /tmp/itpp
            git -C /tmp/itpp fetch --depth 1 origin ${{ steps.dep-shas.outputs.itpp_sha }}
            git -C /tmp/itpp checkout ${{ steps.dep-shas.outputs.itpp_sha }}
            cmake -S /tmp/itpp -B /tmp/itpp/build -G Ninja \
              -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=ON \
              -DCMAKE_INSTALL_PREFIX="$DEPS_PREFIX" \
              -DCMAKE_OSX_ARCHITECTURES=arm64 \
              -DCMAKE_POLICY_VERSION_MINIMUM=3.5 \
              -DBLA_VENDOR=Apple \
              -DITPP_SHARED_LIB=ON \
              -DHTML_DOCS=OFF -DDOXYGEN_EXECUTABLE=/usr/bin/false
            cmake --build /tmp/itpp/build -j
            cmake --install /tmp/itpp/build
          fi

      - name: Ensure RTL-SDR (cached fallback if not found)
        shell: bash
        run: |
          set -euxo pipefail
          if ! pkg-config --exists librtlsdr && [ ! -f "$DEPS_PREFIX/lib/pkgconfig/librtlsdr.pc" ] && [ ! -f "$DEPS_PREFIX/lib64/pkgconfig/librtlsdr.pc" ]; then
            git clone --depth 1 https://github.com/arancormonk/rtl-sdr /tmp/rtl-sdr
            git -C /tmp/rtl-sdr fetch --depth 1 origin ${{ steps.dep-shas.outputs.rtlsdr_sha }}
            git -C /tmp/rtl-sdr checkout ${{ steps.dep-shas.outputs.rtlsdr_sha }}
            cmake -S /tmp/rtl-sdr -B /tmp/rtl-sdr/build -G Ninja \
              -DCMAKE_BUILD_TYPE=Release -DDETACH_KERNEL_DRIVER=ON \
              -DCMAKE_INSTALL_PREFIX="$DEPS_PREFIX" \
              -DCMAKE_OSX_ARCHITECTURES=arm64
            cmake --build /tmp/rtl-sdr/build -j
            cmake --install /tmp/rtl-sdr/build
          fi

      - name: Show dependency versions
        shell: bash
        run: |
          set -euxo pipefail
          pkg-config --modversion codec2 || true
          pkg-config --modversion itpp || true
          pkg-config --modversion librtlsdr || true
          pkg-config --modversion libpulse || true
          pkg-config --modversion sndfile || true

      - name: Configure (Release preset)
        shell: bash
        run: |
          cmake --preset dev-release -G Ninja \
            -DDSD_ENABLE_LTO=OFF -DCMAKE_OSX_ARCHITECTURES=arm64 \
            -DBUILD_TESTING=OFF \
            -DCURSES_LIBRARY="$HB_PREFIX/opt/ncurses/lib/libncursesw.dylib" \
            -DCURSES_INCLUDE_PATH="$HB_PREFIX/opt/ncurses/include"

      - name: Build
        shell: bash
        run: |
          cmake --build --preset dev-release -j

      - name: Smoke test - show CLI help
        shell: bash
        run: |
          ./build/dev-release/apps/dsd-cli/dsd-neo -h || true

      - name: Stage portable tree
        id: stage
        shell: bash
        run: |
          set -euo pipefail
          shopt -s nullglob
          EXE="build/dev-release/apps/dsd-cli/dsd-neo"
          test -f "$EXE"
          STAGE="dist/dsd-neo-macos"
          mkdir -p "$STAGE/bin" "$STAGE/lib"
          cp -f "$EXE" "$STAGE/bin/"

          # Copy docs/launchers
          cp -f packaging/macos/README-macos.txt "$STAGE/" || true
          cp -f packaging/macos/dsd-neo.sh "$STAGE/" || true
          chmod +x "$STAGE/dsd-neo.sh" || true

          # Helper: collect dylib deps of a file and copy non-system libs into $STAGE/lib
          collect_deps() {
            local file="$1"
            local libs lib base src
            libs=$(otool -L "$file" | tail -n +2 | awk '{print $1}')
            for lib in $libs; do
              # Skip system libraries
              case "$lib" in
                /usr/lib/*|/System/*) continue;;
              esac
              base=$(basename "$lib")
              # Prefer copied version if we already staged it
              if [ ! -f "$STAGE/lib/$base" ]; then
                # Resolve potential symlink
                if [ -f "$lib" ]; then
                  cp -f "$lib" "$STAGE/lib/$base" 2>/dev/null || true
                fi
              fi
            done
          }

          # Initial pass for the main binary
          collect_deps "$STAGE/bin/dsd-neo"
          # Iterate to capture transitive deps (cap at 5 passes)
          pass=1
          while [ $pass -le 5 ]; do
            changed=0
            for lib in "$STAGE"/lib/*.dylib; do
              [ -f "$lib" ] || continue
              before=$(ls -1 "$STAGE"/lib | wc -l)
              collect_deps "$lib"
              after=$(ls -1 "$STAGE"/lib | wc -l)
              if [ "$after" -gt "$before" ]; then changed=1; fi
            done
            [ "$changed" -eq 0 ] && break
            pass=$((pass+1))
          done

          # Normalize install names for staged libs and rebasing binary to @rpath
          add_rpath() {
            local bin="$1"
            # Add rpath if not present
            if ! otool -l "$bin" | grep -A2 LC_RPATH | grep -q '@executable_path/../lib'; then
              install_name_tool -add_rpath "@executable_path/../lib" "$bin" || true
            fi
          }

          add_rpath "$STAGE/bin/dsd-neo"

          # Set id for staged libs and change references in the main binary
          for lib in "$STAGE"/lib/*.dylib; do
            [ -f "$lib" ] || continue
            base=$(basename "$lib")
            install_name_tool -id "@rpath/$base" "$lib" || true
          done

          # Rewire binary deps to @rpath when we staged the lib
          while IFS= read -r line; do
            dep=$(echo "$line" | awk '{print $1}')
            case "$dep" in /usr/lib/*|/System/*|$STAGE/*) continue;; esac
            base=$(basename "$dep")
            if [ -f "$STAGE/lib/$base" ]; then
              install_name_tool -change "$dep" "@rpath/$base" "$STAGE/bin/dsd-neo" || true
            fi
          done < <(otool -L "$STAGE/bin/dsd-neo" | tail -n +2)

          # Also update references inside each staged lib to other staged libs
          for tgt in "$STAGE"/lib/*.dylib; do
            [ -f "$tgt" ] || continue
            while IFS= read -r line; do
              dep=$(echo "$line" | awk '{print $1}')
              case "$dep" in /usr/lib/*|/System/*|$STAGE/*) continue;; esac
              base=$(basename "$dep")
              if [ -f "$STAGE/lib/$base" ]; then
                install_name_tool -change "$dep" "@rpath/$base" "$tgt" || true
              fi
            done < <(otool -L "$tgt" | tail -n +2)
          done

          # Emit manifest for auditing
          (cd "$STAGE/lib" && ls -1 *.dylib 2>/dev/null | sort -f) > "$STAGE/dylibs-manifest.txt" || true

      - name: Smoke test staged binary
        shell: bash
        run: |
          set -euo pipefail
          STAGE="dist/dsd-neo-macos"
          export DYLD_FALLBACK_LIBRARY_PATH="$STAGE/lib:${DYLD_FALLBACK_LIBRARY_PATH:-}"
          "$STAGE/bin/dsd-neo" -h || true

      - name: Create DMG
        id: dmg
        shell: bash
        env:
          REF_TYPE: ${{ github.ref_type }}
          REF_NAME: ${{ github.ref_name }}
        run: |
          set -euxo pipefail
          stage='dist/dsd-neo-macos'
          arch='arm64'
          if [ "$REF_TYPE" = 'tag' ] && [ -n "$REF_NAME" ]; then
            dmg="dist/dsd-neo-macos-${arch}-portable-${REF_NAME}.dmg"
            artName="dsd-neo-macos-${arch}-portable-${REF_NAME}"
          else
            dmg="dist/dsd-neo-macos-${arch}-portable-nightly.dmg"
            artName="dsd-neo-macos-${arch}-portable-nightly"
          fi
          mkdir -p "$(dirname "$dmg")"
          [ -f "$dmg" ] && rm -f "$dmg"
          # Include the staged folder as a top-level directory inside the DMG
          imgroot="dist/.imgroot"
          rm -rf "$imgroot"
          mkdir -p "$imgroot"
          cp -a "$stage" "$imgroot/"
          # Create a compressed read-only DMG from imgroot (contains dsd-neo-macos/)
          hdiutil create -fs HFS+ -volname "dsd-neo" -srcfolder "$imgroot" -format UDZO -imagekey zlib-level=9 "$dmg"
          echo "DMG_PATH=$dmg" >> "$GITHUB_OUTPUT"
          echo "ART_NAME=$artName" >> "$GITHUB_OUTPUT"

      - name: Verify DMG contents (mount and run help)
        shell: bash
        run: |
          set -euxo pipefail
          dmg='${{ steps.dmg.outputs.DMG_PATH }}'
          mnt=$(mktemp -d)
          hdiutil attach "$dmg" -nobrowse -noverify -mountpoint "$mnt"
          trap 'hdiutil detach "$mnt" -force || true' EXIT
          # Run help from inside the mounted DMG
          export DYLD_FALLBACK_LIBRARY_PATH="$mnt/dsd-neo-macos/lib:${DYLD_FALLBACK_LIBRARY_PATH:-}"
          "$mnt/dsd-neo-macos/bin/dsd-neo" -h || (echo 'Running help from DMG failed' >&2; exit 1)
          hdiutil detach "$mnt" -force
          trap - EXIT

      - name: Upload artifact
        uses: actions/upload-artifact@v4.6.2
        with:
          name: ${{ steps.dmg.outputs.ART_NAME }}
          path: ${{ steps.dmg.outputs.DMG_PATH }}
          retention-days: 7

      - name: Upload release asset
        if: startsWith(github.ref, 'refs/tags/')
        uses: softprops/action-gh-release@v2.3.3
        with:
          files: ${{ steps.dmg.outputs.DMG_PATH }}
          name: ${{ steps.dmg.outputs.ART_NAME }}
          generate_release_notes: true

      - name: Upload nightly asset (overwrite)
        if: ${{ !startsWith(github.ref, 'refs/tags/') }}
        uses: svenstaro/upload-release-action@v2
        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          tag: nightly
          prerelease: true
          file: ${{ steps.dmg.outputs.DMG_PATH }}
          asset_name: ${{ steps.dmg.outputs.ART_NAME }}.dmg
          overwrite: true
