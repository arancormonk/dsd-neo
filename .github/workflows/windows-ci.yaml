name: windows-ci

on:
  workflow_dispatch: {}
  push:
    branches: [main, master]
    paths-ignore:
      - ".github/*.yml"
      - ".github/*.yaml"
      - ".github/**/*.yml"
      - ".github/**/*.yaml"
      - "**/*.md"

jobs:
  build-portable-zip:
    runs-on: windows-latest
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v6.0.1

      - name: Gate on Linux CI success (linux-ci.yaml) [disabled]
        if: ${{ false }}
        uses: actions/github-script@v8
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const sha = context.sha;
            // Check latest run of the Linux CI workflow for this commit
            const res = await github.rest.actions.listWorkflowRuns({
              owner,
              repo,
              workflow_id: 'linux-ci.yaml',
              head_sha: sha,
              per_page: 1
            });
            const run = res.data.workflow_runs[0];
            if (!run) {
              core.setFailed(`No Linux CI (linux-ci.yaml) run found for commit ${sha}.`);
            } else if (run.status !== 'completed' || run.conclusion !== 'success') {
              core.setFailed(`Linux CI (linux-ci.yaml) not successful for ${sha}. status=${run.status} conclusion=${run.conclusion}`);
            } else {
              core.info(`Linux CI passed: ${run.html_url}`);
            }

      - name: Compute dependency SHAs
        id: dep-shas
        shell: pwsh
        run: |
          $mbe = (git ls-remote https://github.com/arancormonk/mbelib-neo HEAD).Split("`t")[0]
          $codec2 = (git ls-remote https://github.com/arancormonk/codec2 HEAD).Split("`t")[0]
          $itpp = (git ls-remote https://github.com/arancormonk/itpp HEAD).Split("`t")[0]
          $rtlsdr = (git ls-remote https://github.com/arancormonk/rtl-sdr HEAD).Split("`t")[0]
          "mbe_sha=$mbe" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "codec2_sha=$codec2" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "itpp_sha=$itpp" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "rtlsdr_sha=$rtlsdr" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Setup Cygwin
        uses: egor-tensin/setup-cygwin@v4.0.1
        with:
          packages: >-
            git
            ccache
            gcc-g++
            make
            cmake
            curl
            ninja
            pkg-config
            libsndfile-devel
            libncurses-devel
            libpulse-devel
            pulseaudio
            pulseaudio-utils
            libusb1.0-devel
            mintty

      - name: Mark repo safe for Cygwin git
        shell: pwsh
        run: C:\\tools\\cygwin\\bin\\bash.exe -lc 'set -o igncr; git config --global --add safe.directory "$(cygpath -u "$GITHUB_WORKSPACE")"'

      - name: Restore cygdeps cache
        uses: actions/cache@v4.3.0
        id: cygdeps-cache
        with:
          path: .cygdeps
          key: cygdeps-${{ runner.os }}-${{ steps.dep-shas.outputs.mbe_sha }}-${{ steps.dep-shas.outputs.codec2_sha }}-${{ steps.dep-shas.outputs.itpp_sha }}-${{ steps.dep-shas.outputs.rtlsdr_sha }}
          restore-keys: |
            cygdeps-${{ runner.os }}-

      - name: Show Cygwin versions
        shell: pwsh
        run: C:\\tools\\cygwin\\bin\\bash.exe -lc 'set -o igncr; uname -a; cmake --version; gcc --version'

      - name: Prepare deps environment
        shell: pwsh
        run: |
          C:\\tools\\cygwin\\bin\\bash.exe -lc 'set -o igncr; WS="$(cygpath -u "$GITHUB_WORKSPACE")"; cd "$WS"; DEPS_PREFIX="$WS/.cygdeps"; CCACHE_DIR="$WS/.ccache-cygwin"; mkdir -p "$CCACHE_DIR"; echo "DEPS_PREFIX=$DEPS_PREFIX" >> "$GITHUB_ENV"; echo "CMAKE_PREFIX_PATH=$DEPS_PREFIX:${CMAKE_PREFIX_PATH:-}" >> "$GITHUB_ENV"; echo "PKG_CONFIG_PATH=$DEPS_PREFIX/lib/pkgconfig:$DEPS_PREFIX/lib64/pkgconfig:${PKG_CONFIG_PATH:-}" >> "$GITHUB_ENV"; echo "PATH=$DEPS_PREFIX/bin:${PATH}" >> "$GITHUB_ENV"; echo "LD_LIBRARY_PATH=$DEPS_PREFIX/bin:$DEPS_PREFIX/lib:$DEPS_PREFIX/lib64:${LD_LIBRARY_PATH:-}" >> "$GITHUB_ENV"; echo "CCACHE_DIR=$CCACHE_DIR" >> "$GITHUB_ENV"; echo "CC=ccache gcc" >> "$GITHUB_ENV"; echo "CXX=ccache g++" >> "$GITHUB_ENV"; echo "CCACHE_BASEDIR=$WS" >> "$GITHUB_ENV"; echo "CCACHE_NOHASHDIR=true" >> "$GITHUB_ENV"; echo "CCACHE_SLOPPINESS=time_macros" >> "$GITHUB_ENV"'

      - name: Restore ccache (Cygwin)
        uses: actions/cache@v4.3.0
        with:
          path: .ccache-cygwin
          key: ccache-${{ runner.os }}-${{ github.job }}-cygwin-${{ github.sha }}
          restore-keys: |
            ccache-${{ runner.os }}-${{ github.job }}-cygwin-

      - name: Initialize ccache (Cygwin)
        shell: pwsh
        run: |
          C:\\tools\\cygwin\\bin\\bash.exe -lc 'set -o igncr; set -euo pipefail; ccache --version || ccache -V; ccache --zero-stats || ccache -z || true; ccache --set-config=max_size=500M || ccache -M 500M || true; ccache --set-config=compression=true || ccache -o compression=true || true'

      - name: Decide deps to build (manifest)
        id: dep-plan
        shell: pwsh
        env:
          MBE_SHA: ${{ steps.dep-shas.outputs.mbe_sha }}
          CODEC2_SHA: ${{ steps.dep-shas.outputs.codec2_sha }}
          ITPP_SHA: ${{ steps.dep-shas.outputs.itpp_sha }}
          RTLSDR_SHA: ${{ steps.dep-shas.outputs.rtlsdr_sha }}
        run: |
          C:\\tools\\cygwin\\bin\\bash.exe -lc 'set -o igncr; set -euo pipefail; WS="$(cygpath -u "$GITHUB_WORKSPACE")"; cd "$WS"; : "${DEPS_PREFIX:?DEPS_PREFIX not set}"; mf="$DEPS_PREFIX/.manifest"; man_mbe=$(sed -n "s/^mbe_sha=//p" "$mf" 2>/dev/null || true); man_codec2=$(sed -n "s/^codec2_sha=//p" "$mf" 2>/dev/null || true); man_itpp=$(sed -n "s/^itpp_sha=//p" "$mf" 2>/dev/null || true); man_rtlsdr=$(sed -n "s/^rtlsdr_sha=//p" "$mf" 2>/dev/null || true); inst_mbe=false; if [ -f "$DEPS_PREFIX/lib/pkgconfig/libmbe-neo.pc" ] || [ -f "$DEPS_PREFIX/lib64/pkgconfig/libmbe-neo.pc" ]; then inst_mbe=true; fi; inst_codec2=false; if [ -f "$DEPS_PREFIX/lib/pkgconfig/codec2.pc" ] || [ -f "$DEPS_PREFIX/lib64/pkgconfig/codec2.pc" ]; then inst_codec2=true; fi; inst_itpp=false; if [ -f "$DEPS_PREFIX/lib/pkgconfig/itpp.pc" ] || [ -f "$DEPS_PREFIX/lib64/pkgconfig/itpp.pc" ]; then inst_itpp=true; fi; inst_rtlsdr=false; if [ -f "$DEPS_PREFIX/lib/pkgconfig/librtlsdr.pc" ] || [ -f "$DEPS_PREFIX/lib64/pkgconfig/librtlsdr.pc" ]; then inst_rtlsdr=true; fi; m_ok=false; c2_ok=false; i_ok=false; r_ok=false; [ "$inst_mbe" = true ] && [ -n "$man_mbe" ] && [ "$man_mbe" = "$MBE_SHA" ] && m_ok=true || true; [ "$inst_codec2" = true ] && [ -n "$man_codec2" ] && [ "$man_codec2" = "$CODEC2_SHA" ] && c2_ok=true || true; [ "$inst_itpp" = true ] && [ -n "$man_itpp" ] && [ "$man_itpp" = "$ITPP_SHA" ] && i_ok=true || true; [ "$inst_rtlsdr" = true ] && [ -n "$man_rtlsdr" ] && [ "$man_rtlsdr" = "$RTLSDR_SHA" ] && r_ok=true || true; build_mbe=true; [ "$m_ok" = true ] && build_mbe=false || true; build_codec2=true; [ "$c2_ok" = true ] && build_codec2=false || true; build_itpp=true; [ "$i_ok" = true ] && build_itpp=false || true; build_rtlsdr=true; [ "$r_ok" = true ] && build_rtlsdr=false || true; echo "build_mbe=$build_mbe" >> "$GITHUB_OUTPUT"; echo "build_codec2=$build_codec2" >> "$GITHUB_OUTPUT"; echo "build_itpp=$build_itpp" >> "$GITHUB_OUTPUT"; echo "build_rtlsdr=$build_rtlsdr" >> "$GITHUB_OUTPUT"; echo "Plan: mbe=$build_mbe codec2=$build_codec2 itpp=$build_itpp rtlsdr=$build_rtlsdr"'

      - name: Download mbelib-neo source (tarball)
        shell: pwsh
        if: steps.cygdeps-cache.outputs.cache-hit != 'true' && steps.dep-plan.outputs.build_mbe == 'true'
        run: |
          C:\\tools\\cygwin\\bin\\bash.exe -lc 'set -o igncr; cd "$(cygpath -u "$GITHUB_WORKSPACE")"; curl -L -o mbelib-neo.tar.gz https://github.com/arancormonk/mbelib-neo/archive/refs/heads/main.tar.gz && ls -l mbelib-neo.tar.gz'

      - name: Build mbe-neo (static or shared)
        shell: pwsh
        if: steps.cygdeps-cache.outputs.cache-hit != 'true' && steps.dep-plan.outputs.build_mbe == 'true'
        run: |
          C:\\tools\\cygwin\\bin\\bash.exe -lc 'set -o igncr; set -euo pipefail; WS="$(cygpath -u "$GITHUB_WORKSPACE")"; cd "$WS"; if [ ! -f "$DEPS_PREFIX/lib/pkgconfig/libmbe-neo.pc" ] && [ ! -f "$DEPS_PREFIX/lib64/pkgconfig/libmbe-neo.pc" ]; then echo "Extracting mbelib-neo.tar.gz in $WS"; tar -xzf mbelib-neo.tar.gz || true; D="mbelib-neo-main"; if [ ! -d "$D/src/ambe" ]; then echo "Tarball extract missing expected tree; falling back to git clone"; rm -rf "$D" mbelib-neo || true; git clone --depth 1 https://github.com/arancormonk/mbelib-neo.git mbelib-neo; D="mbelib-neo"; fi; echo "Using source dir: $D"; test -d "$D/src/ambe" && ls -la "$D/src/ambe" || true; cmake -S "$D" -B "$D/build" -G Ninja -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX="$DEPS_PREFIX" -DMBELIB_BUILD_TESTS=OFF -DMBELIB_BUILD_EXAMPLES=OFF -DBUILD_SHARED_LIBS=OFF; cmake --build "$D/build" -j; cmake --install "$D/build"; else echo "Using cached mbelib-neo in $DEPS_PREFIX"; fi'

      - name: Download codec2 source (tarball)
        shell: pwsh
        if: steps.cygdeps-cache.outputs.cache-hit != 'true' && steps.dep-plan.outputs.build_codec2 == 'true'
        run: |
          C:\\tools\\cygwin\\bin\\bash.exe -lc 'set -o igncr; cd "$(cygpath -u "$GITHUB_WORKSPACE")"; curl -L -o codec2.tar.gz https://github.com/arancormonk/codec2/archive/refs/heads/main.tar.gz && ls -l codec2.tar.gz'

      - name: Build codec2
        shell: pwsh
        if: steps.cygdeps-cache.outputs.cache-hit != 'true' && steps.dep-plan.outputs.build_codec2 == 'true'
        run: |
          C:\\tools\\cygwin\\bin\\bash.exe -lc 'set -o igncr; set -euo pipefail; WS="$(cygpath -u "$GITHUB_WORKSPACE")"; cd "$WS"; if [ ! -f "$DEPS_PREFIX/lib/pkgconfig/codec2.pc" ] && [ ! -f "$DEPS_PREFIX/lib64/pkgconfig/codec2.pc" ]; then echo "Extracting codec2.tar.gz in $WS"; tar -xzf codec2.tar.gz; D="codec2-main"; if [ ! -d "$D/src" ]; then echo "Tarball extract missing expected tree; falling back to git clone"; rm -rf "$D" codec2 || true; git clone --depth 1 https://github.com/arancormonk/codec2.git codec2; D="codec2"; fi; echo "Using source dir: $D"; cmake -S "$D" -B "$D/build" -G Ninja -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX="$DEPS_PREFIX" -DBUILD_SHARED_LIBS=ON -DUNITTEST=OFF; cmake --build "$D/build" -j; cmake --install "$D/build"; else echo "Using cached codec2 in $DEPS_PREFIX"; fi'

      - name: Download rtl-sdr source (tarball)
        shell: pwsh
        if: steps.cygdeps-cache.outputs.cache-hit != 'true' && steps.dep-plan.outputs.build_rtlsdr == 'true'
        run: |
          C:\\tools\\cygwin\\bin\\bash.exe -lc 'set -o igncr; cd "$(cygpath -u "$GITHUB_WORKSPACE")"; curl -L -o rtl-sdr.tar.gz https://github.com/arancormonk/rtl-sdr/archive/refs/heads/master.tar.gz && ls -l rtl-sdr.tar.gz'

      - name: Build rtl-sdr
        shell: pwsh
        if: steps.cygdeps-cache.outputs.cache-hit != 'true' && steps.dep-plan.outputs.build_rtlsdr == 'true'
        run: |
          C:\\tools\\cygwin\\bin\\bash.exe -lc 'set -o igncr; set -euo pipefail; WS="$(cygpath -u "$GITHUB_WORKSPACE")"; cd "$WS"; if [ ! -f "$DEPS_PREFIX/lib/pkgconfig/librtlsdr.pc" ] && [ ! -f "$DEPS_PREFIX/lib64/pkgconfig/librtlsdr.pc" ]; then echo "Extracting rtl-sdr.tar.gz in $WS"; tar -xzf rtl-sdr.tar.gz; D="rtl-sdr-master"; if [ ! -d "$D/src" ]; then echo "Tarball extract missing expected tree; falling back to git clone"; rm -rf "$D" rtl-sdr || true; git clone --depth 1 https://github.com/arancormonk/rtl-sdr.git rtl-sdr; D="rtl-sdr"; fi; echo "Using source dir: $D"; if ! grep -q "target_link_libraries(\s*convenience_static\s\+rtlsdr" "$D/src/CMakeLists.txt"; then echo "target_link_libraries(convenience_static rtlsdr)" >> "$D/src/CMakeLists.txt"; fi; cmake -S "$D" -B "$D/build" -G Ninja -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX="$DEPS_PREFIX" -DINSTALL_UDEV_RULES=OFF; cmake --build "$D/build" -j; cmake --install "$D/build"; else echo "Using cached rtl-sdr in $DEPS_PREFIX"; fi'

      - name: Download itpp source (tarball)
        shell: pwsh
        if: steps.cygdeps-cache.outputs.cache-hit != 'true' && steps.dep-plan.outputs.build_itpp == 'true'
        run: |
          C:\\tools\\cygwin\\bin\\bash.exe -lc 'set -o igncr; cd "$(cygpath -u "$GITHUB_WORKSPACE")"; curl -L -o itpp.tar.gz https://github.com/arancormonk/itpp/archive/refs/heads/develop.tar.gz && ls -l itpp.tar.gz'

      - name: Build itpp
        shell: pwsh
        if: steps.cygdeps-cache.outputs.cache-hit != 'true' && steps.dep-plan.outputs.build_itpp == 'true'
        run: |
          C:\\tools\\cygwin\\bin\\bash.exe -lc 'set -o igncr; set -euo pipefail; WS="$(cygpath -u "$GITHUB_WORKSPACE")"; cd "$WS"; if [ ! -f "$DEPS_PREFIX/lib/pkgconfig/itpp.pc" ] && [ ! -f "$DEPS_PREFIX/lib64/pkgconfig/itpp.pc" ]; then echo "Extracting itpp.tar.gz in $WS"; tar -xzf itpp.tar.gz; D="itpp-develop"; if [ ! -d "$D/itpp" ]; then echo "Tarball extract missing expected tree; falling back to git clone"; rm -rf "$D" itpp || true; git clone --depth 1 https://github.com/arancormonk/itpp.git itpp; D="itpp"; fi; echo "Using source dir: $D"; mkdir -p "$D/build"; cmake -S "$D" -B "$D/build" -G Ninja -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX="$DEPS_PREFIX" -DCMAKE_POLICY_VERSION_MINIMUM=3.10 -DITPP_SHARED_LIB=ON -DHTML_DOCS=OFF -DDOXYGEN_EXECUTABLE=/bin/false; cmake --build "$D/build" -j; cmake --install "$D/build"; else echo "Using cached itpp in $DEPS_PREFIX"; fi'

      - name: Update cygdeps manifest
        shell: pwsh
        env:
          MBE_SHA: ${{ steps.dep-shas.outputs.mbe_sha }}
          CODEC2_SHA: ${{ steps.dep-shas.outputs.codec2_sha }}
          ITPP_SHA: ${{ steps.dep-shas.outputs.itpp_sha }}
          RTLSDR_SHA: ${{ steps.dep-shas.outputs.rtlsdr_sha }}
        run: |
          C:\\tools\\cygwin\\bin\\bash.exe -lc 'set -o igncr; set -e; : "${DEPS_PREFIX:?}"; mkdir -p "$DEPS_PREFIX"; mf="$DEPS_PREFIX/.manifest"; : > "$mf"; echo "mbe_sha=$MBE_SHA" >> "$mf"; echo "codec2_sha=$CODEC2_SHA" >> "$mf"; echo "itpp_sha=$ITPP_SHA" >> "$mf"; echo "rtlsdr_sha=$RTLSDR_SHA" >> "$mf"; echo "updated=$(date -u +%FT%TZ)" >> "$mf"; echo "Wrote $mf"'

      - name: Save cygdeps cache (explicit)
        if: steps.cygdeps-cache.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4.3.0
        with:
          path: .cygdeps
          key: cygdeps-${{ runner.os }}-${{ steps.dep-shas.outputs.mbe_sha }}-${{ steps.dep-shas.outputs.codec2_sha }}-${{ steps.dep-shas.outputs.itpp_sha }}-${{ steps.dep-shas.outputs.rtlsdr_sha }}

      - name: Configure (Release)
        shell: pwsh
        run: |
          C:\\tools\\cygwin\\bin\\bash.exe -lc 'set -o igncr; cd "$(cygpath -u "$GITHUB_WORKSPACE")" && cmake --preset dev-release -G Ninja -DDSD_ENABLE_LTO=OFF -DBUILD_TESTING=OFF'

      - name: Build
        shell: pwsh
        run: |
          C:\\tools\\cygwin\\bin\\bash.exe -lc 'set -o igncr; cd "$(cygpath -u "$GITHUB_WORKSPACE")" && cmake --build --preset dev-release -j'

      - name: Smoke test - show CLI help
        shell: pwsh
        run: |
          C:\\tools\\cygwin\\bin\\bash.exe -lc 'set -o igncr; cd "$(cygpath -u "$GITHUB_WORKSPACE")" && ./build/dev-release/apps/dsd-cli/dsd-neo.exe -h || true'

      - name: Show ccache stats (Cygwin)
        if: always()
        shell: pwsh
        run: |
          C:\\tools\\cygwin\\bin\\bash.exe -lc 'set -o igncr; ccache -s'

      - name: Stage portable tree
        id: stage
        # Run script via Cygwin bash with CRLF ignoring enabled
        # Convert the runner temp script path to a POSIX path before sourcing to avoid backslash escaping issues
        shell: 'C:\\tools\\cygwin\\bin\\bash.exe --noprofile --norc -lc "set -o igncr; __f=$(cygpath -u ''{0}''); source \"$__f\""'
        run: |
          # Be robust if pipefail isn't available (should be in bash)
          set -euo pipefail 2>/dev/null || set -eu
          # Avoid glob failures when no matches (used below)
          shopt -s nullglob
          cd "$(cygpath -u "$GITHUB_WORKSPACE")"

          EXE="build/dev-release/apps/dsd-cli/dsd-neo.exe"
          test -f "$EXE"

          STAGE="dist/dsd-neo-cygwin"
          mkdir -p "$STAGE/bin" "$STAGE/etc"
          cp -f "$EXE" "$STAGE/bin/"
          DOCDIR="$STAGE/share/doc/dsd-neo"
          mkdir -p "$DOCDIR"
          cp -f LICENSE COPYRIGHT THIRD_PARTY.md src/third_party/ezpwd/lesser.txt "$DOCDIR/"
          required_licenses=(LICENSE COPYRIGHT THIRD_PARTY.md lesser.txt)
          for f in "${required_licenses[@]}"; do
            if [ ! -f "$DOCDIR/$f" ]; then
              echo "ERROR: missing required license file $f in $DOCDIR" >&2
              exit 1
            fi
          done

          : "${DEPS_PREFIX:?DEPS_PREFIX not set}"

          # Helper: collect DLL dependencies of the given files and copy them into $STAGE/bin
          # Use robust parsing of cygcheck output to grab actual file paths.
          collect_deps() {
            local out dll file fn name cand
            out="$1"; shift
            : > "$out"
            for file in "$@"; do
              [ -f "$file" ] || continue
              /usr/bin/cygcheck -v "$file" 2>/dev/null | /usr/bin/tr -d '\r' | \
                /usr/bin/grep -iE -o '([A-Za-z]:\\\\[^ ]*|/[^ ]*)\\.dll' >> "$out" || true
              # Also try ldd as a secondary source (formats differ)
              /usr/bin/ldd "$file" 2>/dev/null | /usr/bin/tr -d '\r' | \
                /usr/bin/grep -iE -o '([A-Za-z]:\\\\[^ ]*|/[^ ]*)\\.dll' >> "$out" || true
              # Fallback: ask objdump for DLL names and resolve from known locations
              while IFS= read -r name; do
                for cand in \
                  "/bin/$name" \
                  "/usr/bin/$name" \
                  "$DEPS_PREFIX/bin/$name"; do
                  [ -f "$cand" ] && echo "$cand" >> "$out" && break || true
                done
              done < <(/usr/bin/objdump -p "$file" 2>/dev/null | /usr/bin/sed -n 's/^\tDLL Name: \(.*\.dll\)$/\1/p')
            done
            sort -u -o "$out" "$out" || true
            while IFS= read -r dll; do
              [ -z "$dll" ] && continue
              fn=$(cygpath -u "$dll" 2>/dev/null || echo "$dll")
              # Skip Windows system DLLs; copy Cygwin and third-party only
              if echo "$fn" | /usr/bin/grep -qiE '^/cygdrive/[a-z]/windows/'; then
                continue
              fi
              if [ -f "$fn" ]; then
                cp -n "$fn" "$STAGE/bin/" 2>/dev/null || true
              fi
            done < "$out"
          }

          # Rely on closure (below) to harvest all required DLLs.

          # Optional tools: include exe and their DLLs if present
          if command -v pulseaudio >/dev/null 2>&1; then
            PULSEAUDIO_BIN="$(command -v pulseaudio)"
            cp -f "$PULSEAUDIO_BIN" "$STAGE/bin/"
            # Copy PulseAudio modules - required for PA to function
            PA_MOD_SRC="/usr/lib/pulseaudio/modules"
            if [ -d "$PA_MOD_SRC" ]; then
              PA_MOD_DST="$STAGE/lib/pulseaudio/modules"
              mkdir -p "$PA_MOD_DST"
              # Copy only essential modules to keep size down
              for mod in \
                module-native-protocol-tcp.dll \
                module-waveout.dll \
                module-null-sink.dll \
                module-always-sink.dll \
                module-device-restore.dll \
                module-default-device-restore.dll \
                module-rescue-streams.dll \
                module-stream-restore.dll \
                module-suspend-on-idle.dll \
                libprotocol-native.dll \
                libcli.dll; do
                [ -f "$PA_MOD_SRC/$mod" ] && cp -f "$PA_MOD_SRC/$mod" "$PA_MOD_DST/" || true
              done
              echo "Copied PulseAudio modules to $PA_MOD_DST"
              ls -la "$PA_MOD_DST" || true
            else
              echo "WARNING: PulseAudio modules directory not found at $PA_MOD_SRC"
            fi
          fi

          if command -v mintty >/dev/null 2>&1; then
            MINTTY_BIN="$(command -v mintty)"
            cp -f "$MINTTY_BIN" "$STAGE/bin/"
          fi

          # Include cygpath for path conversion in launcher scripts
          if command -v cygpath >/dev/null 2>&1; then
            cp -f "$(command -v cygpath)" "$STAGE/bin/"
          fi

          # Closure: resolve dependencies until fixed point (cap at 10 passes)
          # Include PulseAudio modules in dependency resolution
          pass=1
          while true; do
            before=$(printf "%s\n" "$STAGE"/bin/*.exe "$STAGE"/bin/*.dll "$STAGE"/lib/pulseaudio/modules/*.dll 2>/dev/null | wc -l | awk '{print $1}')
            collect_deps "pass${pass}.txt" "$STAGE"/bin/*.exe "$STAGE"/bin/*.dll "$STAGE"/lib/pulseaudio/modules/*.dll 2>/dev/null
            after=$(printf "%s\n" "$STAGE"/bin/*.exe "$STAGE"/bin/*.dll "$STAGE"/lib/pulseaudio/modules/*.dll 2>/dev/null | wc -l | awk '{print $1}')
            [ "$after" -le "$before" ] && break
            pass=$((pass+1))
            [ "$pass" -gt 10 ] && break
          done

          # Copy launchers and config
          cp -f packaging/windows-cygwin/dsd-neo.bat "$STAGE/"
          cp -f packaging/windows-cygwin/dsd-neo-mintty.bat "$STAGE/" 2>/dev/null || true
          cp -f packaging/windows-cygwin/README-windows.txt "$STAGE/"
          if [ -f packaging/windows-cygwin/etc/pulse/default.pa ]; then
            mkdir -p "$STAGE/etc/pulse"
            cp -f packaging/windows-cygwin/etc/pulse/default.pa "$STAGE/etc/pulse/"
          fi

          # Provide a minimal terminfo set (avoid copying symlinks in full tree)
          if [ -x "/usr/bin/tic" ] && [ -x "/usr/bin/infocmp" ]; then
            mkdir -p "$STAGE/share/terminfo"
            tmp_src=$(mktemp)
            # Common terminals for Windows/mintty/console
            for ent in xterm xterm-256color vt100 vt220 screen cygwin; do
              /usr/bin/infocmp -x -A /usr/share/terminfo "$ent" >> "$tmp_src" 2>/dev/null || true
              echo >> "$tmp_src"
            done
            if [ -s "$tmp_src" ]; then
              /usr/bin/tic -x -o "$STAGE/share/terminfo" "$tmp_src" || true
              # Dereference any symlinks created for aliases (e.g., vt100-am)
              # .NET ZipFile chokes on reparse points; replace links with plain files
              if [ -d "$STAGE/share/terminfo" ]; then
                /usr/bin/find "$STAGE/share/terminfo" -type l -print0 | \
                  while IFS= read -r -d '' link; do
                    tgt=$(/usr/bin/readlink -f "$link" 2>/dev/null || true)
                    if [ -n "$tgt" ] && [ -f "$tgt" ]; then
                      rm -f "$link" || true
                      cp -f "$tgt" "$link" || true
                    fi
                  done
              fi
            fi
            rm -f "$tmp_src"
          fi

          # Emit a manifest of included DLLs for debugging/auditing
          (cd "$STAGE/bin" && ls -1 *.dll 2>/dev/null | sort -f) > "$STAGE/dlls-manifest.txt" || true

      - name: Validate portable dependencies
        shell: 'C:\\tools\\cygwin\\bin\\bash.exe --noprofile --norc -lc "set -o igncr; __f=$(cygpath -u ''{0}''); source \"$__f\""'
        run: |
          set -eu
          STAGE="dist/dsd-neo-cygwin"
          test -f "$STAGE/bin/dsd-neo.exe"
          # Restrict runtime search to staged bin, but call Cygwin tools via absolute paths
          export PATH="$STAGE/bin"
          # Ensure cygcheck reports no missing DLLs for all staged executables
          miss=0
          for exe in "$STAGE"/bin/*.exe; do
            [ -f "$exe" ] || continue
            echo "Validating dependencies for: $exe"
            if /usr/bin/cygcheck -v "$exe" | /usr/bin/grep -E "^  Not Found: " -q; then
              echo "Missing dependencies for $exe:" >&2
              /usr/bin/cygcheck -v "$exe" | /usr/bin/sed -n 's/^  Not Found: //p' >&2 || true
              miss=1
            fi
          done
          if [ "$miss" -ne 0 ]; then
            echo "Validation failed: missing DLLs detected." >&2
            exit 1
          fi

      - name: Smoke test staged binary
        shell: 'C:\\tools\\cygwin\\bin\\bash.exe --noprofile --norc -lc "set -o igncr; __f=$(cygpath -u ''{0}''); source \"$__f\""'
        run: |
          set -eu
          STAGE="dist/dsd-neo-cygwin"
          export PATH="$STAGE/bin:${PATH}"
          "$STAGE/bin/dsd-neo.exe" -h || true

      - name: Archive ZIP
        shell: pwsh
        env:
          REF_TYPE: ${{ github.ref_type }}
          REF_NAME: ${{ github.ref_name }}
          GITHUB_SHA: ${{ github.sha }}
        run: |
          $stage = 'dist/dsd-neo-cygwin'
          $defaultZip = "$stage.zip"
          if ($env:REF_TYPE -eq 'tag' -and $env:REF_NAME) {
            $zip = "dist/dsd-neo-cygwin-x86_64-portable-$($env:REF_NAME).zip"
            $artName = "dsd-neo-cygwin-x86_64-portable-$($env:REF_NAME)"
          } else {
            $zip = "dist/dsd-neo-cygwin-x86_64-portable-nightly.zip"
            $artName = "dsd-neo-cygwin-x86_64-portable-nightly"
          }
          $zipDir = Split-Path -Parent $zip
          if ($zipDir -and !(Test-Path $zipDir)) { New-Item -Type Directory -Force -Path $zipDir | Out-Null }
          if (Test-Path $zip) { Remove-Item -Force $zip }
          Add-Type -AssemblyName System.IO.Compression.FileSystem
          [System.IO.Compression.ZipFile]::CreateFromDirectory($stage, $zip)
          Write-Host "Created: $zip"
          echo "ZIP_PATH=$zip" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          echo "ART_NAME=$artName" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
        id: zip

      - name: Verify ZIP contents (extract and run help)
        shell: pwsh
        run: |
          $zip = '${{ steps.zip.outputs.ZIP_PATH }}'
          if (!(Test-Path $zip)) { throw "ZIP not found: $zip" }
          $dest = Join-Path $env:RUNNER_TEMP ('dsd-neo-cygwin-' + [System.Guid]::NewGuid().ToString('N'))
          New-Item -ItemType Directory -Force -Path $dest | Out-Null
          Add-Type -AssemblyName System.IO.Compression.FileSystem
          [System.IO.Compression.ZipFile]::ExtractToDirectory($zip, $dest)
          $bin = Join-Path $dest 'bin'
          $exe = Join-Path $bin 'dsd-neo.exe'
          if (!(Test-Path $exe)) { throw "Extracted exe not found: $exe" }
          $env:PATH = "$bin;$env:PATH"
          Write-Host "Running: $exe -h"
          & $exe -h

      - name: Upload artifact
        uses: actions/upload-artifact@v5.0.0
        with:
          name: ${{ steps.zip.outputs.ART_NAME }}
          path: ${{ steps.zip.outputs.ZIP_PATH }}
          retention-days: 7

      - name: Upload release asset
        if: startsWith(github.ref, 'refs/tags/')
        uses: softprops/action-gh-release@v2.5.0
        with:
          files: ${{ steps.zip.outputs.ZIP_PATH }}
          name: dsd-neo-cygwin-x86_64-portable-${{ github.ref_name }}
          generate_release_notes: true

      - name: Upload nightly asset (overwrite)
        if: ${{ !startsWith(github.ref, 'refs/tags/') }}
        uses: svenstaro/upload-release-action@v2
        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          tag: nightly
          prerelease: true
          file: ${{ steps.zip.outputs.ZIP_PATH }}
          asset_name: dsd-neo-cygwin-x86_64-portable-nightly.zip
          overwrite: true

  build-native-msvc:
    runs-on: windows-latest
    permissions:
      contents: write
    env:
      # Use a release-only triplet to avoid building debug variants of vcpkg deps.
      VCPKG_DEFAULT_TRIPLET: x64-windows-static-release
      VCPKG_TARGET_TRIPLET: x64-windows-static-release
      # Enable vcpkg binary caching on GitHub Actions cache.
      VCPKG_BINARY_SOURCES: "clear;x-gha,readwrite"
      # Enable sccache GitHub Actions backend.
      SCCACHE_GHA_ENABLED: "true"
    steps:
      - name: Checkout
        uses: actions/checkout@v6.0.1

      - name: Run sccache-cache
        uses: mozilla-actions/sccache-action@v0.0.9

      - name: Initialize sccache
        shell: pwsh
        run: |
          & $env:SCCACHE_PATH --version
          & $env:SCCACHE_PATH --zero-stats

      - name: Setup vcpkg
        uses: lukka/run-vcpkg@v11.5
        with:
          # run-vcpkg v11.5 requires a full 40-char SHA1; update as needed.
          vcpkgGitCommitId: "b5b449f0bb37fbad60171245eb323e08e892e8d7"

      - name: Install vcpkg dependencies (MSVC)
        shell: pwsh
        run: vcpkg install --triplet $env:VCPKG_DEFAULT_TRIPLET --x-manifest-root "$env:GITHUB_WORKSPACE"

      - name: Configure (MSVC Release)
        shell: pwsh
        run: cmake --preset win-msvc-release -DCMAKE_C_COMPILER_LAUNCHER=sccache -DCMAKE_CXX_COMPILER_LAUNCHER=sccache

      - name: Build (MSVC Release)
        shell: pwsh
        run: cmake --build --preset win-msvc-release

      - name: Show sccache stats
        shell: pwsh
        run: |
          & $env:SCCACHE_PATH --show-stats

      - name: Stage native MSVC tree
        id: stage
        shell: pwsh
        run: |
          $exeCandidates = Get-ChildItem -Path 'build/win-msvc-release/apps/dsd-cli' -Recurse -Filter 'dsd-neo.exe' |
            Select-Object -ExpandProperty FullName
          if (-not $exeCandidates) { throw "Exe not found under build/win-msvc-release/apps/dsd-cli" }
          $exe = $exeCandidates[0]
          $stage = 'dist/dsd-neo-msvc'
          $binDir = Join-Path $stage 'bin'
          $docDir = Join-Path $stage 'share/doc/dsd-neo'
          New-Item -ItemType Directory -Force -Path $binDir,$docDir | Out-Null
          Copy-Item -Force $exe $binDir
          Copy-Item -Force LICENSE,COPYRIGHT,THIRD_PARTY.md,'src/third_party/ezpwd/lesser.txt' $docDir -ErrorAction SilentlyContinue
          $required = @('LICENSE','COPYRIGHT','THIRD_PARTY.md','lesser.txt')
          foreach ($f in $required) {
            $p = Join-Path $docDir $f
            if (!(Test-Path $p)) { throw "Missing required license file in staged docs: $p" }
          }

      - name: Smoke test staged binary (MSVC)
        shell: pwsh
        run: |
          $exe = 'dist/dsd-neo-msvc/bin/dsd-neo.exe'
          if (!(Test-Path $exe)) { throw "Staged exe not found: $exe" }
          Write-Host "Running: $exe -h"
          & $exe -h

      - name: Archive native MSVC ZIP
        shell: pwsh
        env:
          REF_TYPE: ${{ github.ref_type }}
          REF_NAME: ${{ github.ref_name }}
        run: |
          $stage = 'dist/dsd-neo-msvc'
          if ($env:REF_TYPE -eq 'tag' -and $env:REF_NAME) {
            $zip = "dist/dsd-neo-msvc-x86_64-native-$($env:REF_NAME).zip"
            $artName = "dsd-neo-msvc-x86_64-native-$($env:REF_NAME)"
          } else {
            $zip = "dist/dsd-neo-msvc-x86_64-native-nightly.zip"
            $artName = "dsd-neo-msvc-x86_64-native-nightly"
          }
          if (Test-Path $zip) { Remove-Item -Force $zip }
          Add-Type -AssemblyName System.IO.Compression.FileSystem
          [System.IO.Compression.ZipFile]::CreateFromDirectory($stage, $zip)
          echo "ZIP_PATH=$zip" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          echo "ART_NAME=$artName" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
        id: zip

      - name: Verify ZIP contents (extract and run help)
        shell: pwsh
        run: |
          $zip = '${{ steps.zip.outputs.ZIP_PATH }}'
          if (!(Test-Path $zip)) { throw "ZIP not found: $zip" }
          $dest = Join-Path $env:RUNNER_TEMP ('dsd-neo-msvc-' + [System.Guid]::NewGuid().ToString('N'))
          New-Item -ItemType Directory -Force -Path $dest | Out-Null
          Add-Type -AssemblyName System.IO.Compression.FileSystem
          [System.IO.Compression.ZipFile]::ExtractToDirectory($zip, $dest)
          $bin = Join-Path $dest 'bin'
          $exe = Join-Path $bin 'dsd-neo.exe'
          if (!(Test-Path $exe)) { throw "Extracted exe not found: $exe" }
          $env:PATH = "$bin;$env:PATH"
          Write-Host "Running: $exe -h"
          & $exe -h

      - name: Upload native MSVC artifact
        uses: actions/upload-artifact@v5.0.0
        with:
          name: ${{ steps.zip.outputs.ART_NAME }}
          path: ${{ steps.zip.outputs.ZIP_PATH }}
          retention-days: 7

      - name: Upload native MSVC release asset
        if: startsWith(github.ref, 'refs/tags/')
        uses: softprops/action-gh-release@v2.5.0
        with:
          files: ${{ steps.zip.outputs.ZIP_PATH }}

      - name: Upload native MSVC nightly asset (overwrite)
        if: ${{ !startsWith(github.ref, 'refs/tags/') }}
        uses: svenstaro/upload-release-action@v2
        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          tag: nightly
          prerelease: true
          file: ${{ steps.zip.outputs.ZIP_PATH }}
          asset_name: dsd-neo-msvc-x86_64-native-nightly.zip
          overwrite: true

  build-native-mingw:
    runs-on: windows-latest
    permissions:
      contents: write
    env:
      # Use a release-only triplet to avoid building debug variants of vcpkg deps.
      VCPKG_DEFAULT_TRIPLET: x64-mingw-static-release
      VCPKG_TARGET_TRIPLET: x64-mingw-static-release
      # Enable vcpkg binary caching on GitHub Actions cache.
      VCPKG_BINARY_SOURCES: "clear;x-gha,readwrite"
      # Enable sccache GitHub Actions backend.
      SCCACHE_GHA_ENABLED: "true"
      VCPKG_OVERLAY_TRIPLETS: ${{ github.workspace }}\vcpkg-triplets
    steps:
      - name: Checkout
        uses: actions/checkout@v6.0.1

      - name: Run sccache-cache
        uses: mozilla-actions/sccache-action@v0.0.9

      - name: Initialize sccache
        shell: pwsh
        run: |
          & $env:SCCACHE_PATH --version
          & $env:SCCACHE_PATH --zero-stats

      - name: Setup MSYS2 (MinGW-w64)
        uses: msys2/setup-msys2@v2.29.0
        with:
          msystem: MINGW64
          # Avoid full MSYS2 system upgrades in CI.
          # We've seen intermittent pacman database signature failures in unrelated repos (e.g. clangarm64)
          # that break the job before we even build. Installing only what we need is more reliable.
          update: false
          install: >-
            mingw-w64-x86_64-gcc
            mingw-w64-x86_64-cmake
            mingw-w64-x86_64-ninja
            mingw-w64-x86_64-make
            mingw-w64-x86_64-pkgconf

      - name: Setup vcpkg
        uses: lukka/run-vcpkg@v11.5
        with:
          # run-vcpkg v11.5 requires a full 40-char SHA1; update as needed.
          vcpkgGitCommitId: "b5b449f0bb37fbad60171245eb323e08e892e8d7"

      - name: Install vcpkg dependencies (MinGW)
        shell: msys2 {0}
        env:
          # Ensure the Windows PATH (with vcpkg.exe) is visible in MSYS2.
          MSYS2_PATH_TYPE: inherit
        run: |
          set -euo pipefail
          VCPKG_EXE="$(cygpath -u "$VCPKG_ROOT")/vcpkg.exe"
          "$VCPKG_EXE" install --triplet "${VCPKG_DEFAULT_TRIPLET}" --x-manifest-root "$GITHUB_WORKSPACE"

      - name: Configure (MinGW Release)
        shell: msys2 {0}
        run: |
          set -euo pipefail
          SCCACHE_EXE="$(cygpath -u "$SCCACHE_PATH")"
          cmake --preset win-mingw-release \
            -DCMAKE_C_COMPILER_LAUNCHER="$SCCACHE_EXE" \
            -DCMAKE_CXX_COMPILER_LAUNCHER="$SCCACHE_EXE"

      - name: Build (MinGW Release)
        shell: msys2 {0}
        run: cmake --build --preset win-mingw-release -j2

      - name: Show sccache stats
        shell: pwsh
        run: |
          & $env:SCCACHE_PATH --show-stats

      - name: Stage native MinGW tree
        id: stage
        shell: pwsh
        run: |
          $exe = 'build/win-mingw-release/apps/dsd-cli/dsd-neo.exe'
          if (!(Test-Path $exe)) { throw "Exe not found: $exe" }
          $stage = 'dist/dsd-neo-mingw'
          $binDir = Join-Path $stage 'bin'
          $docDir = Join-Path $stage 'share/doc/dsd-neo'
          New-Item -ItemType Directory -Force -Path $binDir,$docDir | Out-Null
          Copy-Item -Force $exe $binDir
          Copy-Item -Force LICENSE,COPYRIGHT,THIRD_PARTY.md,'src/third_party/ezpwd/lesser.txt' $docDir -ErrorAction SilentlyContinue
          $required = @('LICENSE','COPYRIGHT','THIRD_PARTY.md','lesser.txt')
          foreach ($f in $required) {
            $p = Join-Path $docDir $f
            if (!(Test-Path $p)) { throw "Missing required license file in staged docs: $p" }
          }

      - name: Smoke test staged binary (MinGW)
        shell: pwsh
        run: |
          $exe = 'dist/dsd-neo-mingw/bin/dsd-neo.exe'
          if (!(Test-Path $exe)) { throw "Staged exe not found: $exe" }
          Write-Host "Running: $exe -h"
          & $exe -h

      - name: Archive native MinGW ZIP
        shell: pwsh
        env:
          REF_TYPE: ${{ github.ref_type }}
          REF_NAME: ${{ github.ref_name }}
        run: |
          $stage = 'dist/dsd-neo-mingw'
          if ($env:REF_TYPE -eq 'tag' -and $env:REF_NAME) {
            $zip = "dist/dsd-neo-mingw-x86_64-native-$($env:REF_NAME).zip"
            $artName = "dsd-neo-mingw-x86_64-native-$($env:REF_NAME)"
          } else {
            $zip = "dist/dsd-neo-mingw-x86_64-native-nightly.zip"
            $artName = "dsd-neo-mingw-x86_64-native-nightly"
          }
          if (Test-Path $zip) { Remove-Item -Force $zip }
          Add-Type -AssemblyName System.IO.Compression.FileSystem
          [System.IO.Compression.ZipFile]::CreateFromDirectory($stage, $zip)
          echo "ZIP_PATH=$zip" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          echo "ART_NAME=$artName" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
        id: zip

      - name: Verify ZIP contents (extract and run help)
        shell: pwsh
        run: |
          $zip = '${{ steps.zip.outputs.ZIP_PATH }}'
          if (!(Test-Path $zip)) { throw "ZIP not found: $zip" }
          $dest = Join-Path $env:RUNNER_TEMP ('dsd-neo-mingw-' + [System.Guid]::NewGuid().ToString('N'))
          New-Item -ItemType Directory -Force -Path $dest | Out-Null
          Add-Type -AssemblyName System.IO.Compression.FileSystem
          [System.IO.Compression.ZipFile]::ExtractToDirectory($zip, $dest)
          $bin = Join-Path $dest 'bin'
          $exe = Join-Path $bin 'dsd-neo.exe'
          if (!(Test-Path $exe)) { throw "Extracted exe not found: $exe" }
          $env:PATH = "$bin;$env:PATH"
          Write-Host "Running: $exe -h"
          & $exe -h

      - name: Upload native MinGW artifact
        uses: actions/upload-artifact@v5.0.0
        with:
          name: ${{ steps.zip.outputs.ART_NAME }}
          path: ${{ steps.zip.outputs.ZIP_PATH }}
          retention-days: 7

      - name: Upload native MinGW release asset
        if: startsWith(github.ref, 'refs/tags/')
        uses: softprops/action-gh-release@v2.5.0
        with:
          files: ${{ steps.zip.outputs.ZIP_PATH }}

      - name: Upload native MinGW nightly asset (overwrite)
        if: ${{ !startsWith(github.ref, 'refs/tags/') }}
        uses: svenstaro/upload-release-action@v2
        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          tag: nightly
          prerelease: true
          file: ${{ steps.zip.outputs.ZIP_PATH }}
          asset_name: dsd-neo-mingw-x86_64-native-nightly.zip
          overwrite: true
