// SPDX-License-Identifier: ISC
/*
 * Copyright (C) 2025 by arancormonk <180709949+arancormonk@users.noreply.github.com>
 */

#include <math.h>
#include <string.h>

#define FIR_MAX_TAPS 1024

typedef struct {
    const float* base; /* design taps at base_sps */
    int base_len;
    int base_sps;
    float taps[FIR_MAX_TAPS];
    float hist[FIR_MAX_TAPS];
    int taps_len;
    int head;
    int last_sps;
    int ready;
} sps_fir;

static inline void
reset_sps_fir(sps_fir* f) {
    if (!f) {
        return;
    }
    memset(f->taps, 0, sizeof(f->taps));
    memset(f->hist, 0, sizeof(f->hist));
    f->taps_len = 0;
    f->head = -1;
    f->last_sps = 0;
    f->ready = 0;
}

static float
interp_base(const float* base, int len, float idx) {
    if (idx < 0.0f || idx > (float)(len - 1)) {
        return 0.0f;
    }
    int i0 = (int)idx;
    int i1 = i0 + 1;
    if (i1 >= len) {
        i1 = len - 1;
    }
    float frac = idx - (float)i0;
    return base[i0] + frac * (base[i1] - base[i0]);
}

static void
design_sps_fir(sps_fir* f, int sps) {
    if (!f || !f->base || f->base_len <= 0 || f->base_sps <= 0 || sps <= 1) {
        if (f) {
            f->ready = 0;
        }
        return;
    }
    double span = (double)(f->base_len - 1) / (double)f->base_sps;
    double desired = span * (double)sps;
    int taps_len = (int)(desired + 0.5) + 1; /* preserve span + center tap */
    if (taps_len < 3) {
        taps_len = 3;
    }
    if ((taps_len & 1) == 0) {
        taps_len += 1; /* prefer odd length for symmetry */
    }
    if (taps_len > FIR_MAX_TAPS) {
        taps_len = FIR_MAX_TAPS;
        if ((taps_len & 1) == 0) {
            taps_len -= 1;
        }
    }

    float mid_new = 0.5f * (float)(taps_len - 1);
    float mid_base = 0.5f * (float)(f->base_len - 1);
    for (int n = 0; n < taps_len; n++) {
        float t_sym = ((float)n - mid_new) / (float)sps;
        float base_idx = t_sym * (float)f->base_sps + mid_base;
        f->taps[n] = interp_base(f->base, f->base_len, base_idx);
    }

    double sum = 0.0;
    for (int n = 0; n < taps_len; n++) {
        sum += f->taps[n];
    }
    if (fabs(sum) < 1e-12) {
        sum = 1.0;
    }
    float inv_sum = (float)(1.0 / sum);
    for (int n = 0; n < taps_len; n++) {
        f->taps[n] *= inv_sum;
        f->hist[n] = 0.0f;
    }

    f->taps_len = taps_len;
    f->head = -1;
    f->last_sps = sps;
    f->ready = 1;
}

static float
apply_sps_fir(sps_fir* f, float sample, int sps) {
    if (!f || sps <= 1) {
        return sample;
    }
    if (!f->ready || sps != f->last_sps) {
        design_sps_fir(f, sps);
    }
    if (!f->ready || f->taps_len <= 0) {
        return sample;
    }

    int head = f->head + 1;
    if (head >= f->taps_len) {
        head = 0;
    }
    f->hist[head] = sample;
    f->head = head;

    float acc = 0.0f;
    int zeros = f->taps_len - 1;
    for (int i = 0; i <= zeros; i++) {
        int idx = head - (zeros - i);
        if (idx < 0) {
            idx += f->taps_len;
        }
        acc += f->taps[i] * f->hist[idx];
    }
    return acc;
}

// M17 Filter -- RRC Alpha = 0.5 at 48 kHz (sps=10)
static const float m17coeffs[81] = {
    -0.003195702904062073f, -0.002930279157647190f, -0.001940667871554463f, -0.000356087678023658f,
    0.001547011339077758f,  0.003389554791179751f,  0.004761898604225673f,  0.005310860846138910f,
    0.004824746306020221f,  0.003297923526848786f,  0.000958710871218619f,  -0.001749908029791816f,
    -0.004238694106631223f, -0.005881783042101693f, -0.006150256456781309f, -0.004745376707651645f,
    -0.001704189656473565f, 0.002547854551539951f,  0.007215575568844704f,  0.011231038205363532f,
    0.013421952197060707f,  0.012730475385624438f,  0.008449554307303753f,  0.000436744366018287f,
    -0.010735380379191660f, -0.023726883538258272f, -0.036498030780605324f, -0.046500883189991064f,
    -0.050979050575999614f, -0.047340680079891187f, -0.033554880492651755f, -0.008513823955725943f,
    0.027696543159614194f,  0.073664520037517042f,  0.126689053778116234f,  0.182990955139333916f,
    0.238080025892859704f,  0.287235637987091563f,  0.326040247765297220f,  0.350895727088112619f,
    0.359452932027607974f,  0.350895727088112619f,  0.326040247765297220f,  0.287235637987091563f,
    0.238080025892859704f,  0.182990955139333916f,  0.126689053778116234f,  0.073664520037517042f,
    0.027696543159614194f,  -0.008513823955725943f, -0.033554880492651755f, -0.047340680079891187f,
    -0.050979050575999614f, -0.046500883189991064f, -0.036498030780605324f, -0.023726883538258272f,
    -0.010735380379191660f, 0.000436744366018287f,  0.008449554307303753f,  0.012730475385624438f,
    0.013421952197060707f,  0.011231038205363532f,  0.007215575568844704f,  0.002547854551539951f,
    -0.001704189656473565f, -0.004745376707651645f, -0.006150256456781309f, -0.005881783042101693f,
    -0.004238694106631223f, -0.001749908029791816f, 0.000958710871218619f,  0.003297923526848786f,
    0.004824746306020221f,  0.005310860846138910f,  0.004761898604225673f,  0.003389554791179751f,
    0.001547011339077758f,  -0.000356087678023658f, -0.001940667871554463f, -0.002930279157647190f,
    -0.003195702904062073f};
#define M17_BASE_SPS     10
#define M17_BASE_TAP_LEN (int)(sizeof(m17coeffs) / sizeof(m17coeffs[0]))

// DMR filter F4EXB - root raised cosine alpha=0.7 at 48 kHz (sps=10)
static const float dmrcoeffs[61] = {
    0.0301506278f,  0.0269200615f,  0.0159662432f,  -0.0013114705f, -0.0216605133f, -0.0404938748f, -0.0528141756f,
    -0.0543747957f, -0.0428325003f, -0.0186176083f, 0.0147202645f,  0.0508418571f,  0.0816392577f,  0.0988113688f,
    0.0957187780f,  0.0691512084f,  0.0206194642f,  -0.0431564563f, -0.1107569268f, -0.1675773224f, -0.1981519842f,
    -0.1889130786f, -0.1308939560f, -0.0218608492f, 0.1325685970f,  0.3190962499f,  0.5182530574f,  0.7070497652f,
    0.8623526878f,  0.9644213921f,  1.0000000000f,  0.9644213921f,  0.8623526878f,  0.7070497652f,  0.5182530574f,
    0.3190962499f,  0.1325685970f,  -0.0218608492f, -0.1308939560f, -0.1889130786f, -0.1981519842f, -0.1675773224f,
    -0.1107569268f, -0.0431564563f, 0.0206194642f,  0.0691512084f,  0.0957187780f,  0.0988113688f,  0.0816392577f,
    0.0508418571f,  0.0147202645f,  -0.0186176083f, -0.0428325003f, -0.0543747957f, -0.0528141756f, -0.0404938748f,
    -0.0216605133f, -0.0013114705f, 0.0159662432f,  0.0269200615f,  0.0301506278f};
#define DMR_BASE_SPS     10
#define DMR_BASE_TAP_LEN (int)(sizeof(dmrcoeffs) / sizeof(dmrcoeffs[0]))

// NXDN48/96 filter - original version (designed for 48 kHz, sps=20)
static const float nxcoeffs[135] = {
    +0.031462429f, +0.031747267f, +0.030401148f, +0.027362877f, +0.022653298f, +0.016379869f, +0.008737200f,
    +0.000003302f, -0.009468531f, -0.019262057f, -0.028914291f, -0.037935027f, -0.045828927f, -0.052119261f,
    -0.056372283f, -0.058221106f, -0.057387924f, -0.053703443f, -0.047122444f, -0.037734535f, -0.025769308f,
    -0.011595336f, +0.004287292f, +0.021260954f, +0.038610717f, +0.055550276f, +0.071252765f, +0.084885375f,
    +0.095646450f, +0.102803611f, +0.105731303f, +0.103946126f, +0.097138329f, +0.085197939f, +0.068234131f,
    +0.046586711f, +0.020828821f, -0.008239664f, -0.039608255f, -0.072081234f, -0.104311776f, -0.134843790f,
    -0.162160200f, -0.184736015f, -0.201094346f, -0.209863285f, -0.209831516f, -0.200000470f, -0.179630919f,
    -0.148282051f, -0.105841323f, -0.052543664f, +0.011020985f, +0.083912428f, +0.164857408f, +0.252278939f,
    +0.344336996f, +0.438979335f, +0.534000832f, +0.627109358f, +0.715995947f, +0.798406824f, +0.872214756f,
    +0.935487176f, +0.986548646f, +1.024035395f, +1.046939951f, +1.054644241f, +1.046939951f, +1.024035395f,
    +0.986548646f, +0.935487176f, +0.872214756f, +0.798406824f, +0.715995947f, +0.627109358f, +0.534000832f,
    +0.438979335f, +0.344336996f, +0.252278939f, +0.164857408f, +0.083912428f, +0.011020985f, -0.052543664f,
    -0.105841323f, -0.148282051f, -0.179630919f, -0.200000470f, -0.209831516f, -0.209863285f, -0.201094346f,
    -0.184736015f, -0.162160200f, -0.134843790f, -0.104311776f, -0.072081234f, -0.039608255f, -0.008239664f,
    +0.020828821f, +0.046586711f, +0.068234131f, +0.085197939f, +0.097138329f, +0.103946126f, +0.105731303f,
    +0.102803611f, +0.095646450f, +0.084885375f, +0.071252765f, +0.055550276f, +0.038610717f, +0.021260954f,
    +0.004287292f, -0.011595336f, -0.025769308f, -0.037734535f, -0.047122444f, -0.053703443f, -0.057387924f,
    -0.058221106f, -0.056372283f, -0.052119261f, -0.045828927f, -0.037935027f, -0.028914291f, -0.019262057f,
    -0.009468531f, +0.000003302f, +0.008737200f, +0.016379869f, +0.022653298f, +0.027362877f, +0.030401148f,
    +0.031747267f, +0.031462429f};
#define NXDN_BASE_SPS     20
#define NXDN_BASE_TAP_LEN (int)(sizeof(nxcoeffs) / sizeof(nxcoeffs[0]))

// dPMR filter - root raised cosine alpha=0.2 at 48 kHz (sps=20)
static const float dpmrcoeffs[135] = {
    -0.0000983004, 0.0058388841,  0.0119748846,  0.0179185547,  0.0232592816,  0.0275919612,  0.0305433586,
    0.0317982965,  0.0311240307,  0.0283911865,  0.0235897433,  0.0168387650,  0.0083888763,  -0.0013831396,
    -0.0119878087, -0.0228442151, -0.0333082708, -0.0427067804, -0.0503756642, -0.0557003599, -0.0581561791,
    -0.0573462646, -0.0530347941, -0.0451732069, -0.0339174991, -0.0196350217, -0.0028997157, 0.0155246961,
    0.0347134030,  0.0536202583,  0.0711271166,  0.0861006725,  0.0974542022,  0.1042112035,  0.1055676660,
    0.1009496091,  0.0900625944,  0.0729301774,  0.0499186839,  0.0217462748,  -0.0105250265, -0.0455148664,
    -0.0815673067, -0.1168095612, -0.1492246435, -0.1767350726, -0.1972941202, -0.2089805758, -0.2100926829,
    -0.1992367833, -0.1754063031, -0.1380470370, -0.0871052089, -0.0230554989, 0.0530929052,  0.1398131936,
    0.2351006721,  0.3365341927,  0.4413570929,  0.5465745033,  0.6490630781,  0.7456885564,  0.8334261381,
    0.9094784589,  0.9713859928,  1.0171250045,  1.0451886943,  1.0546479089,  1.0451886943,  1.0171250045,
    0.9713859928,  0.9094784589,  0.8334261381,  0.7456885564,  0.6490630781,  0.5465745033,  0.4413570929,
    0.3365341927,  0.2351006721,  0.1398131936,  0.0530929052,  -0.0230554989, -0.0871052089, -0.1380470370,
    -0.1754063031, -0.1992367833, -0.2100926829, -0.2089805758, -0.1972941202, -0.1767350726, -0.1492246435,
    -0.1168095612, -0.0815673067, -0.0455148664, -0.0105250265, 0.0217462748,  0.0499186839,  0.0729301774,
    0.0900625944,  0.1009496091,  0.1055676660,  0.1042112035,  0.0974542022,  0.0861006725,  0.0711271166,
    0.0536202583,  0.0347134030,  0.0155246961,  -0.0028997157, -0.0196350217, -0.0339174991, -0.0451732069,
    -0.0530347941, -0.0573462646, -0.0581561791, -0.0557003599, -0.0503756642, -0.0427067804, -0.0333082708,
    -0.0228442151, -0.0119878087, -0.0013831396, 0.0083888763,  0.0168387650,  0.0235897433,  0.0283911865,
    0.0311240307,  0.0317982965,  0.0305433586,  0.0275919612,  0.0232592816,  0.0179185547,  0.0119748846,
    0.0058388841,  -0.0000983004};
#define DPMR_BASE_SPS     20
#define DPMR_BASE_TAP_LEN (int)(sizeof(dpmrcoeffs) / sizeof(dpmrcoeffs[0]))

// P25 C4FM RX de-emphasis filter - OP25 compatible (transfer_function_rx)
// Sinc-based filter that inverts the C4FM transmitter's preemphasis (t/sin(t)).
// Parameters: sample_rate=48000, symbol_rate=4800, span=9, sps=10
// Generated using IFFT of sinc(pi*f/rate) transfer function
// See: https://github.com/boatbod/op25/blob/master/op25/gr-op25_repeater/apps/tx/op25_c4fm_mod.py
#define P25_BASE_SPS      10
static const float p25_base_coeffs[91] = {
    2.5136032328468223e-04f,  2.0151157806489389e-04f,  6.5614198114868653e-05f,  -1.1016182521584872e-04f,
    -2.5912718500147703e-04f, -3.1854080534864679e-04f, -2.5499192412346209e-04f, -8.0811341618403253e-05f,
    1.4587749827445741e-04f,  3.3924177267442553e-04f,  4.1684342104421064e-04f,  3.3300701153002625e-04f,
    1.0159288265298235e-04f,  -2.0205207165260435e-04f, -4.6331126549667987e-04f, -5.6903817400881962e-04f,
    -4.5325595471553667e-04f, -1.3054623551357765e-04f, 2.9771613892566937e-04f,  6.7070306752558281e-04f,
    8.2344079518134800e-04f,  6.5286953790319577e-04f,  1.7063335852203476e-04f,  -4.8022995636450586e-04f,
    -1.0576277820236342e-03f, -1.2984272199126820e-03f, -1.0210516145569011e-03f, -2.1847321285187830e-04f,
    8.9570866257743969e-04f,  1.9159656053379041e-03f,  2.3554729602435079e-03f,  1.8191510018527107e-03f,
    1.9485965513348435e-04f,  -2.1959672874350021e-03f, -4.5451112342681493e-03f, -5.6388787968222262e-03f,
    -4.0771412352218865e-03f, 1.4061759104066391e-03f,  1.1591443394554960e-02f,  2.6478859157413236e-02f,
    4.5134880973750763e-02f,  6.5735325813782261e-02f,  8.5815567034273302e-02f,  1.0268680032016260e-01f,
    1.1393334551393806e-01f,  1.1788155507005367e-01f,  1.1393334551393806e-01f,  1.0268680032016260e-01f,
    8.5815567034273302e-02f,  6.5735325813782275e-02f,  4.5134880973750756e-02f,  2.6478859157413232e-02f,
    1.1591443394554955e-02f,  1.4061759104066391e-03f,  -4.0771412352218891e-03f, -5.6388787968222288e-03f,
    -4.5451112342681519e-03f, -2.1959672874350068e-03f, 1.9485965513348224e-04f,  1.8191510018527107e-03f,
    2.3554729602435071e-03f,  1.9159656053379041e-03f,  8.9570866257743925e-04f,  -2.1847321285187735e-04f,
    -1.0210516145569026e-03f, -1.2984272199126855e-03f, -1.0576277820236353e-03f, -4.8022995636450938e-04f,
    1.7063335852203265e-04f,  6.5286953790319588e-04f,  8.2344079518134519e-04f,  6.7070306752557924e-04f,
    2.9771613892566959e-04f,  -1.3054623551357652e-04f, -4.5325595471553477e-04f, -5.6903817400881995e-04f,
    -4.6331126549668057e-04f, -2.0205207165260435e-04f, 1.0159288265298099e-04f,  3.3300701153002587e-04f,
    4.1684342104421167e-04f,  3.3924177267442786e-04f,  1.4587749827445716e-04f,  -8.0811341618404093e-05f,
    -2.5499192412346220e-04f, -3.1854080534864690e-04f, -2.5912718500147660e-04f, -1.1016182521584800e-04f,
    6.5614198114868558e-05f,  2.0151157806489272e-04f,  2.5136032328468153e-04f};
#define P25_BASE_TAP_LEN (int)(sizeof(p25_base_coeffs) / sizeof(p25_base_coeffs[0]))

static sps_fir g_fir_p25 = {.base = p25_base_coeffs, .base_len = P25_BASE_TAP_LEN, .base_sps = P25_BASE_SPS};
static sps_fir g_fir_dmr = {.base = dmrcoeffs, .base_len = DMR_BASE_TAP_LEN, .base_sps = DMR_BASE_SPS};
static sps_fir g_fir_nxdn = {.base = nxcoeffs, .base_len = NXDN_BASE_TAP_LEN, .base_sps = NXDN_BASE_SPS};
static sps_fir g_fir_dpmr = {.base = dpmrcoeffs, .base_len = DPMR_BASE_TAP_LEN, .base_sps = DPMR_BASE_SPS};
static sps_fir g_fir_m17 = {.base = m17coeffs, .base_len = M17_BASE_TAP_LEN, .base_sps = M17_BASE_SPS};

float
dmr_filter(float sample, int sps) {
    return apply_sps_fir(&g_fir_dmr, sample, sps);
}

float
nxdn_filter(float sample, int sps) {
    return apply_sps_fir(&g_fir_nxdn, sample, sps);
}

float
dpmr_filter(float sample, int sps) {
    return apply_sps_fir(&g_fir_dpmr, sample, sps);
}

float
m17_filter(float sample, int sps) {
    return apply_sps_fir(&g_fir_m17, sample, sps);
}

float
p25_filter(float sample, int sps) {
    return apply_sps_fir(&g_fir_p25, sample, sps);
}

void
init_rrc_filter_memory() {
    reset_sps_fir(&g_fir_p25);
    reset_sps_fir(&g_fir_dmr);
    reset_sps_fir(&g_fir_nxdn);
    reset_sps_fir(&g_fir_dpmr);
    reset_sps_fir(&g_fir_m17);
}
