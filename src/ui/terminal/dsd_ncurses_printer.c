// SPDX-License-Identifier: ISC
/*
 * Copyright (C) 2025 by arancormonk <180709949+arancormonk@users.noreply.github.com>
 */
/*-------------------------------------------------------------------------------
 * dsd_ncurses_printer.c
 * DSD-FME ncurses open, printer, and close
 *
 * ASCII art generated by:
 * https://fsymbols.com/generators/carty/
 *
 * LWVMOBILE
 * 2025-05 DSD-FME Florida Man Edition
 *
 * ilyacodes
 * 2024-03 EDACS-FME display improvements
 *-----------------------------------------------------------------------------*/

#include <dsd-neo/core/dsd.h>
#include <dsd-neo/core/synctype.h>
#include <dsd-neo/runtime/config.h>
#include <dsd-neo/runtime/git_ver.h>
#include <dsd-neo/ui/keymap.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#ifdef USE_RTLSDR
#include <dsd-neo/io/rtl_stream_c.h>
#endif

/* Local quickselect helpers for int arrays (k-th smallest in O(n)) */
static inline void
swap_int_local(int* a, int* b) {
    int t = *a;
    *a = *b;
    *b = t;
}

/* Gamma LUT for density→glyph mapping (sqrt gamma 0.5) */
static int s_gamma_ready = 0;
static float s_gamma_lut[256];

static inline void
gamma_init_once(void) {
    if (s_gamma_ready) {
        return;
    }
    for (int i = 0; i < 256; i++) {
        float x = (float)i / 255.0f;
        s_gamma_lut[i] = sqrtf(x); /* gamma 0.5 */
    }
    s_gamma_ready = 1;
}

static inline double
gamma_map01(double f) {
    if (f <= 0.0) {
        return 0.0;
    }
    if (f >= 1.0) {
        return 1.0;
    }
    gamma_init_once();
    int idx = (int)lrint(f * 255.0);
    if (idx < 0) {
        idx = 0;
    }
    if (idx > 255) {
        idx = 255;
    }
    return (double)s_gamma_lut[idx];
}

static int
select_k_int_local(int* a, int n, int k) {
    int lo = 0, hi = n - 1;
    while (lo <= hi) {
        int mid = lo + (hi - lo) / 2;
        int pivot = a[mid];
        int lt = lo, i = lo, gt = hi;
        while (i <= gt) {
            if (a[i] < pivot) {
                swap_int_local(&a[i++], &a[lt++]);
            } else if (a[i] > pivot) {
                swap_int_local(&a[i], &a[gt--]);
            } else {
                i++;
            }
        }
        if (k < lt) {
            hi = lt - 1;
        } else if (k > gt) {
            lo = gt + 1;
        } else {
            return a[k];
        }
    }
    return a[k];
}

char mbeversionstr[25]; //MBElib version string
static unsigned long long int edacs_channel_tree[33][6];

/* SNR history buffers for sparkline (per modulation) */
enum { SNR_HIST_N = 48 };

static double snr_hist_c4fm[SNR_HIST_N];
static int snr_hist_len_c4fm = 0;
static int snr_hist_head_c4fm = 0;
static double snr_hist_qpsk[SNR_HIST_N];
static int snr_hist_len_qpsk = 0;
static int snr_hist_head_qpsk = 0;
static double snr_hist_gfsk[SNR_HIST_N];
static int snr_hist_len_gfsk = 0;
static int snr_hist_head_gfsk = 0;

/* UI helpers: dynamic headers and horizontal rules sized to terminal width */
static void
ui_print_hr(void) {
    int rows = 0, cols = 80;
    getmaxyx(stdscr, rows, cols);
    if (cols < 1) {
        cols = 80;
    }
    int y = 0, x = 0;
    getyx(stdscr, y, x);
    mvhline(y, 0, '-', cols);
    if (y + 1 < rows) {
        move(y + 1, 0);
    } else {
        addch('\n');
    }
}

static void
ui_print_header(const char* title) {
    int rows = 0, cols = 80;
    getmaxyx(stdscr, rows, cols);
    if (cols < 4) {
        cols = 80;
    }
    const char* t = (title && *title) ? title : "";
    int y = 0, x = 0;
    getyx(stdscr, y, x);
    addstr("--");
    addstr(t);
    int used = 2 + (int)strlen(t);
    if (used < cols) {
        mvhline(y, used, '-', cols - used);
    }
    if (y + 1 < rows) {
        move(y + 1, 0);
    } else {
        addch('\n');
    }
}

/* Print a single left border '|' using the primary UI color (pair 4) */
static inline void
ui_print_lborder(void) {
    attron(COLOR_PAIR(4));
    addch('|');
    attroff(COLOR_PAIR(4));
}

/* Forward declaration for int ascending comparator (used by qsort for percentiles) */
static int cmp_int_asc(const void* a, const void* b);

static void
snr_hist_push(int mod, double snr) {
    if (snr < -50.0) {
        return;
    }
    if (snr > 60.0) {
        snr = 60.0;
    }
    int* head = NULL;
    int* len = NULL;
    double* buf = NULL;
    if (mod == 0) {
        head = &snr_hist_head_c4fm;
        len = &snr_hist_len_c4fm;
        buf = snr_hist_c4fm;
    } else if (mod == 1) {
        head = &snr_hist_head_qpsk;
        len = &snr_hist_len_qpsk;
        buf = snr_hist_qpsk;
    } else {
        head = &snr_hist_head_gfsk;
        len = &snr_hist_len_gfsk;
        buf = snr_hist_gfsk;
    }
    int h = *head;
    buf[h] = snr;
    h = (h + 1) % SNR_HIST_N;
    *head = h;
    if (*len < SNR_HIST_N) {
        (*len)++;
    }
}

static void
print_snr_sparkline(const dsd_opts* opts, int mod) {
    /* Preserve the current color pair so our temporary colors don't clear it */
#ifdef PRETTY_COLORS
    attr_t saved_attrs = 0;
    short saved_pair = 0;
    attr_get(&saved_attrs, &saved_pair, NULL);
#endif
    static const char* uni8[] = {"▁", "▂", "▃", "▄", "▅", "▆", "▇", "█"};
    /* Make the lowest ASCII level visible (no leading space) */
    static const char ascii8[] = ".:;-=+*#"; /* 8 levels */
    /* Respect the UI toggle: only use Unicode blocks when enabled and locale supports it */
    int use_unicode = (opts && opts->eye_unicode && MB_CUR_MAX > 1);
    const int levels = 8;
    const int W = 24;                           /* sparkline width */
    const double clip_lo = 0.0, clip_hi = 30.0; /* dB window */
    const double span = (clip_hi - clip_lo) > 1e-6 ? (clip_hi - clip_lo) : 1.0;

    const double* buf = NULL;
    int len = 0;
    int head = 0;
    if (mod == 0) {
        buf = snr_hist_c4fm;
        len = snr_hist_len_c4fm;
        head = snr_hist_head_c4fm;
    } else if (mod == 1) {
        buf = snr_hist_qpsk;
        len = snr_hist_len_qpsk;
        head = snr_hist_head_qpsk;
    } else {
        buf = snr_hist_gfsk;
        len = snr_hist_len_gfsk;
        head = snr_hist_head_gfsk;
    }
    if (len <= 0) {
        return;
    }
    int start = (head - len + SNR_HIST_N) % SNR_HIST_N;
    int count = len < W ? len : W;
    /* Map most recent to the right; older to the left */
    int idx = (start + (len - count)) % SNR_HIST_N;

    /* Color bands: poor<12 red, 12..18 yellow, >18 green */
    const short C_GOOD = 11, C_MOD = 12, C_POOR = 13;
    for (int x = 0; x < count; x++) {
        double v = buf[idx];
        idx = (idx + 1) % SNR_HIST_N;
        double t = (v - clip_lo) / span;
        if (t < 0.0) {
            t = 0.0;
        }
        if (t > 1.0) {
            t = 1.0;
        }
        int li = (int)floor(t * (levels - 1) + 0.5);
        if (li < 0) {
            li = 0;
        }
        if (li >= levels) {
            li = levels - 1;
        }
        short cp = (v < 12.0) ? C_POOR : (v < 18.0) ? C_MOD : C_GOOD;
#ifdef PRETTY_COLORS
        attron(COLOR_PAIR(cp));
#endif
        if (use_unicode) {
            addstr(uni8[li]);
        } else {
            addch(ascii8[li]);
        }
#ifdef PRETTY_COLORS
        attroff(COLOR_PAIR(cp));
#endif
    }
#ifdef PRETTY_COLORS
    /* Restore previously active color pair (e.g., green call banner) */
    if (saved_pair >= 0) {
        attron(COLOR_PAIR(saved_pair));
    }
#endif
}

/* Render a compact horizontal meter for current SNR using existing glyphs. */
static void
print_snr_meter(const dsd_opts* opts, double snr_db) {
    /* Preserve the current color pair so our temporary colors don't clear it */
#ifdef PRETTY_COLORS
    attr_t saved_attrs = 0;
    short saved_pair = 0;
    attr_get(&saved_attrs, &saved_pair, NULL);
#endif
    /* Color bands match sparkline thresholds */
    const short C_GOOD = 11, C_MOD = 12, C_POOR = 13;
    /* Map 0..30 dB onto 8 glyph levels (same set used elsewhere) */
    static const char* uni8[] = {"▁", "▂", "▃", "▄", "▅", "▆", "▇", "█"};
    static const char ascii8[] = ".:;-=+*#"; /* 8 levels */

    double v = snr_db;
    if (v < 0.0) {
        v = 0.0;
    }
    if (v > 30.0) {
        v = 30.0;
    }
    const int levels = 8;
    int li = (int)floor((v / 30.0) * (levels - 1) + 0.5);
    if (li < 0) {
        li = 0;
    }
    if (li >= levels) {
        li = levels - 1;
    }

    int use_unicode = (opts && opts->eye_unicode && MB_CUR_MAX > 1);
    short cp = (snr_db < 12.0) ? C_POOR : (snr_db < 18.0) ? C_MOD : C_GOOD;
#ifdef PRETTY_COLORS
    attron(COLOR_PAIR(cp));
#endif
    if (use_unicode) {
        addstr(uni8[li]);
    } else {
        addch(ascii8[li]);
    }
#ifdef PRETTY_COLORS
    attroff(COLOR_PAIR(cp));
#endif
#ifdef PRETTY_COLORS
    /* Restore previously active color pair (e.g., green call banner) */
    if (saved_pair >= 0) {
        attron(COLOR_PAIR(saved_pair));
    }
#endif
}

char* DMRBusrtTypes[32] = {
    "PI       ", "VLC      ", "TLC      ", "CSBK     ", "MBCH     ", "MBCC     ", "DATA     ",
    "R12D     ", "R34D     ", "IDLE     ", "R1_D     ", "ERR      ", "DUID ERR ", "R-S ERR  ",
    "CRC ERR  ", "NULL     ", "VOICE",     "         ", "INIT     ", "INIT     ",
    "PTT",      //20 MAC
    "VOICE",    //21 MAC_ACTIVE
    "HANGTIME", //22 MAC
    "PTT END",  //23 MAC
    "IDLE",     //24 MAC
    "HDU",
    "VOICE", //26 LDU1
    "VOICE", //27 LDU2
    "TDU/LC",    "TSBK",
    "SIGNAL", //MAC_SIGNAL
    "SIGNAL"  //MAC_SIGNAL

};

void
ncursesOpen(dsd_opts* opts, dsd_state* state) {

    UNUSED(opts);
    UNUSED(state);

    // state->menuopen = 1; //flag the menu is open, stop processing getFrameSync
    mbe_printVersion(mbeversionstr);
    setlocale(LC_ALL, "");
    initscr(); //Initialize NCURSES screen window
    start_color();

#ifdef PRETTY_COLORS
    init_pair(1, COLOR_YELLOW, COLOR_BLACK);  //Yellow/Amber for frame sync/control channel, NV style
    init_pair(2, COLOR_RED, COLOR_BLACK);     //Red for Terminated Calls
    init_pair(3, COLOR_GREEN, COLOR_BLACK);   //Green for Active Calls
    init_pair(4, COLOR_CYAN, COLOR_BLACK);    //Cyan for Site Extra and Patches
    init_pair(5, COLOR_MAGENTA, COLOR_BLACK); //Magenta for no frame sync/signal
    init_pair(6, COLOR_WHITE, COLOR_BLACK);   //White Card Color Scheme
    init_pair(7, COLOR_BLUE, COLOR_BLACK);    //Blue on Black
    init_pair(8, COLOR_BLACK, COLOR_WHITE);   //Black on White
    init_pair(9, COLOR_RED, COLOR_WHITE);     //Red on White
    init_pair(10, COLOR_BLUE, COLOR_WHITE);   //Blue on White
    /* Quality bands for SNR sparkline */
    init_pair(11, COLOR_GREEN, COLOR_BLACK);  //good
    init_pair(12, COLOR_YELLOW, COLOR_BLACK); //moderate
    init_pair(13, COLOR_RED, COLOR_BLACK);    //poor
    init_pair(14, COLOR_YELLOW, COLOR_BLACK); //DSP status (explicit yellow)
#else
    init_pair(1, COLOR_WHITE, COLOR_BLACK);  //White Card Color Scheme
    init_pair(2, COLOR_WHITE, COLOR_BLACK);  //White Card Color Scheme
    init_pair(3, COLOR_WHITE, COLOR_BLACK);  //White Card Color Scheme
    init_pair(4, COLOR_WHITE, COLOR_BLACK);  //White Card Color Scheme
    init_pair(5, COLOR_WHITE, COLOR_BLACK);  //White Card Color Scheme
    init_pair(6, COLOR_WHITE, COLOR_BLACK);  //White Card Color Scheme
    init_pair(7, COLOR_WHITE, COLOR_BLACK);  //White Card Color Scheme
    init_pair(8, COLOR_BLACK, COLOR_WHITE);  //White Card Color Scheme
    init_pair(9, COLOR_BLACK, COLOR_WHITE);  //White Card Color Scheme
    init_pair(10, COLOR_BLACK, COLOR_WHITE); //White Card Color Scheme
    init_pair(11, COLOR_WHITE, COLOR_BLACK); //fallback
    init_pair(12, COLOR_WHITE, COLOR_BLACK);
    init_pair(13, COLOR_WHITE, COLOR_BLACK);
    init_pair(14, COLOR_YELLOW, COLOR_BLACK); //DSP status stays yellow even on white card scheme
#endif

    noecho();
    cbreak();

    //initialize this
    memset(edacs_channel_tree, 0, sizeof(edacs_channel_tree));

    // When ncurses UI is active, suppress direct stderr logging to prevent
    // screen corruption from background fprintf calls in protocol paths.
    // This avoids mixed ncurses/stdio output overwriting the UI until resize.
    // If console logs are needed, consider adding a file logger later.
    static int stderr_suppressed = 0;
    if (!stderr_suppressed) {
#ifdef __unix__
        FILE* devnull = fopen("/dev/null", "w");
        if (devnull) {
            fflush(stderr);
            dup2(fileno(devnull), fileno(stderr));
            // keep devnull open; stderr now points to it
            stderr_suppressed = 1;
        }
#endif
    }
}

static int lls = -1;

/* Print a compact DSP status summary (which blocks are active). */
static void
print_dsp_status(void) {
#ifdef USE_RTLSDR
    /* Preserve current color pair so our colored header/HR won't force default */
#ifdef PRETTY_COLORS
    attr_t saved_attrs = 0;
    short saved_pair = 0;
    attr_get(&saved_attrs, &saved_pair, NULL);
#endif
    int cq = 0, fll = 0, ted = 0, auto_on = 0;
    rtl_stream_dsp_get(&cq, &fll, &ted, &auto_on);
    int lms = 0, taps = 0, mu = 0, stride = 0, wl = 0, dfe = 0, dft = 0, mf = 0, cma = 0;
    rtl_stream_cqpsk_get(&lms, &taps, &mu, &stride, &wl, &dfe, &dft, &mf, &cma);
    int rrc_en = 0, rrc_a = 0, rrc_s = 0;
    rtl_stream_cqpsk_get_rrc(&rrc_en, &rrc_a, &rrc_s);
    int iqb = rtl_stream_get_iq_balance();

    ui_print_header("DSP");
    ui_print_lborder();
    attron(COLOR_PAIR(14)); /* explicit yellow for DSP items */
    printw(" Auto: %s ", auto_on ? "On" : "Off");
    printw(" IQ BAL: %s ", iqb ? "On" : "Off");
    printw(" FLL: %s ", fll ? "On" : "Off");
    printw(" TED: %s ", ted ? "On" : "Off");
    printw(" CQPSK: %s", cq ? "On" : "Off");
    if (cq) {
        printw(" [LMS: %s WL: %s DFE: %s MF: %s", lms ? "On" : "Off", wl ? "On" : "Off", dfe ? "On" : "Off",
               mf ? (rrc_en ? "RRC" : "On") : "Off");
        if (rrc_en) {
            printw(" a: %d%% s: %d", rrc_a, rrc_s);
        }
        printw("]");
        attroff(COLOR_PAIR(14));
    }
    printw("\n");
    attron(COLOR_PAIR(4));
    ui_print_hr();
    attroff(COLOR_PAIR(4));
    /* Restore previously active color pair (e.g., banner color) */
#ifdef PRETTY_COLORS
    if (saved_pair >= 0) {
        attron(COLOR_PAIR(saved_pair));
    }
#endif
#endif
}

static void
print_constellation_view(dsd_opts* opts, dsd_state* state) {
#ifdef USE_RTLSDR
    /* Fetch a snapshot of recent I/Q points */
    enum { MAXP = 4096 };

    int16_t buf[(size_t)MAXP * 2];
    int n = rtl_stream_constellation_get(buf, MAXP);

    ui_print_header("Constellation");
    if (n <= 0) {
        ui_print_lborder();
        printw(" (no samples yet)\n");
        attron(COLOR_PAIR(4));
        ui_print_hr();
        attroff(COLOR_PAIR(4));
        return;
    }

    /* Determine grid size from terminal */
    int rows = 24, cols = 80;
    getmaxyx(stdscr, rows, cols);
    int W = cols - 4;
    if (W < 32) {
        W = 32;
    }
    /* Make the constellation a bit taller by default for readability */
    int H = rows / 2; /* previously rows/3 */
    if (H < 12) {
        H = 12;
    }

    /* Respect UI toggles */
    int use_unicode = (opts && opts->eye_unicode && MB_CUR_MAX > 1);

    /* Local palettes */
    static const char ascii_palette[] = " .:-=+*#%@"; /* 10 levels */
    const int ascii_len = (int)(sizeof(ascii_palette) - 1);
    /* Blocks (eye-style) */
    static const char* block_palette[] = {" ", "▁", "▂", "▃", "▄", "▅", "▆", "▇", "█"}; /* 9 levels */
    const int block_len = (int)(sizeof(block_palette) / sizeof(block_palette[0]));
    /* Dots of increasing weight/size (preferred for constellation) */
    static const char* dot_palette[] = {" ", "·", "∙", "•", "●", "⬤"}; /* 6 levels */
    const int dot_len = (int)(sizeof(dot_palette) / sizeof(dot_palette[0]));
    int use_dots = 1; /* default to dot style for constellation */

    /* Optional color ramp (blue->cyan->green->yellow->red) */
    static const short color_seq[] = {COLOR_BLUE,    COLOR_CYAN, COLOR_GREEN, COLOR_YELLOW,
                                      COLOR_MAGENTA, COLOR_RED,  COLOR_WHITE};
    const int color_len = (int)(sizeof(color_seq) / sizeof(color_seq[0]));
    const short color_base = 41; /* keep separate from eye's base to avoid clashes */
    const short guide_h_pair = (short)(color_base + 8);
    const short guide_v_pair = (short)(color_base + 9);
    const short guide_x_pair = (short)(color_base + 10);
    static int color_inited = 0;
    if (opts && opts->eye_color && has_colors() && !color_inited) {
        for (int i = 0; i < color_len; i++) {
            init_pair((short)(color_base + i), color_seq[i], COLOR_BLACK);
        }
        init_pair(guide_h_pair, COLOR_YELLOW, COLOR_BLACK);
        init_pair(guide_v_pair, COLOR_CYAN, COLOR_BLACK);
        init_pair(guide_x_pair, COLOR_MAGENTA, COLOR_BLACK);
        color_inited = 1;
    }

    /* Density buffer (reused across frames to avoid malloc/free churn) */
    size_t den_sz = (size_t)H * (size_t)W;
    static unsigned short* s_den = NULL;
    static size_t s_den_cap = 0;
    if (s_den_cap < den_sz) {
        void* nb = realloc(s_den, den_sz * sizeof(unsigned short));
        if (!nb) {
            free(s_den);
            s_den = NULL;
            s_den_cap = 0;
            printw("| (constellation: out of memory)\n");
            ui_print_hr();
            return;
        }
        s_den = (unsigned short*)nb;
        s_den_cap = den_sz;
    }
    unsigned short* den = s_den;
    memset(den, 0, den_sz * sizeof(unsigned short));

    /* Dynamic radial scale using high-percentile magnitude (robust to outliers), then smooth. */
    static int s_maxR = 256; /* smoothed scale for radius (~99th percentile of |IQ|) */
    /* Collect absolute I/Q and magnitude values for percentile computation */
    static int absI[(size_t)MAXP];
    static int absQ[(size_t)MAXP];
    static int magR[(size_t)MAXP];
    for (int k = 0; k < n; k++) {
        int i = buf[(size_t)(k << 1) + 0];
        int q = buf[(size_t)(k << 1) + 1];
        int ai = (i < 0) ? -i : i;
        int aq = (q < 0) ? -q : q;
        absI[k] = ai;
        absQ[k] = aq;
        /* Approximate magnitude without floating point: sqrt(i*i + q*q). */
        long ii = (long)i;
        long qq = (long)q;
        long r2 = ii * ii + qq * qq;
        int r = (int)lrint(sqrt((double)r2));
        magR[k] = r;
    }
    /* Compute 99th percentile radius via quickselect (avoid full sort) */
    /* Use 99th percentile (index ~ 0.99*(n-1)) to ignore rare spikes */
    int idxP = (int)lrint(0.99 * (double)(n - 1));
    if (idxP < 0) {
        idxP = 0;
    }
    if (idxP >= n) {
        idxP = n - 1;
    }
    int pR = select_k_int_local(magR, n, idxP);
    /* Avoid zooming into noise; also keep a sane lower bound */
    if (pR < 64) {
        pR = 64;
    }
    /* EMA smoothing (alpha ~0.2) */
    s_maxR = (int)(0.8 * (double)s_maxR + 0.2 * (double)pR);
    if (s_maxR < 64) {
        s_maxR = 64;
    }

    /* Magnitude gate to reduce near-origin clutter */
    double gate = 0.10;
    if (opts) {
        gate = (opts->mod_qpsk == 1) ? (double)opts->const_gate_qpsk : (double)opts->const_gate_other;
        if (gate < 0.0) {
            gate = 0.0;
        }
        if (gate > 0.90) {
            gate = 0.90;
        }
    }
    const double gate2 = gate * gate;

    /* Accumulate density */
    int cx = W / 2, cy = H / 2;
    /* Use equal scale on both axes so circles stay round on wide terminals. */
    int halfX = (W / 2) - 1;
    int halfY = (H / 2) - 1;
    if (halfX < 1) {
        halfX = 1;
    }
    if (halfY < 1) {
        halfY = 1;
    }
    int scale_eq = (halfX < halfY) ? halfX : halfY;
    /* Terminal cell aspect compensation: rows are visually taller than columns.
       Compress vertical mapping to counteract oval appearance (empirical factor). */
    const double y_aspect = 0.55; /* 0.5–0.6 typical; adjust if needed */
    /* Add a small headroom margin so dense clusters don't pin to the border */
    const double outer_margin = 0.92; /* 92% of the square radius */
    /* Define a centered square plotting region so each quadrant is square in rows/cols */
    int x0 = cx - scale_eq;
    int x1 = cx + scale_eq;
    int y0 = cy - scale_eq;
    int y1 = cy + scale_eq;
    unsigned short dmax = 0;
    for (int k = 0; k < n; k++) {
        int i = buf[(size_t)(k << 1) + 0];
        int q = buf[(size_t)(k << 1) + 1];
        /* Compute raw magnitude for gating and optional unit-circle normalization */
        double ii = (double)i;
        double qq = (double)q;
        double r = sqrt(ii * ii + qq * qq);
        double rn = r / (double)s_maxR; /* normalized radius for gating */
        if ((rn * rn) < gate2) {
            continue;
        }
        double nx, ny;
        if (opts && opts->const_norm_mode == 1) {
            /* Unit-circle normalization (direction only) */
            if (r <= 1e-9) {
                continue; /* skip degenerate */
            }
            nx = ii / r;
            ny = qq / r;
        } else {
            /* Radial (percentile) normalization */
            nx = ii / (double)s_maxR;
            ny = qq / (double)s_maxR;
        }
        int x = cx + (int)lrint(nx * (double)scale_eq * outer_margin);
        int y = cy - (int)lrint(ny * (double)scale_eq * outer_margin * y_aspect);
        if (x < 0) {
            x = 0;
        }
        if (x >= W) {
            x = W - 1;
        }
        if (y < 0) {
            y = 0;
        }
        if (y >= H) {
            y = H - 1;
        }
        unsigned short* cell = &den[(size_t)y * (size_t)W + (size_t)x];
        if (*cell != 0xFFFF) {
            (*cell)++;
            if (*cell > dmax) {
                dmax = *cell;
            }
        }
    }
    if (dmax == 0) {
        dmax = 1; /* avoid div-by-zero */
    }

    /* Render with overlays and optional color (trim to active density vertically) */
    /* Find first/last rows within [y0,y1] that contain any density. */
    int y_start = y0;
    int y_end = y1;
    if (y_start < 0) {
        y_start = 0;
    }
    if (y_end >= H) {
        y_end = H - 1;
    }
    int y_top = -1, y_bot = -1;
    for (int y = y_start; y <= y_end; y++) {
        int has = 0;
        for (int x = x0; x <= x1; x++) {
            if (x >= 0 && x < W) {
                if (den[(size_t)y * (size_t)W + (size_t)x] > 0) {
                    has = 1;
                    break;
                }
            }
        }
        if (has) {
            y_top = y;
            break;
        }
    }
    for (int y = y_end; y >= y_start; y--) {
        int has = 0;
        for (int x = x0; x <= x1; x++) {
            if (x >= 0 && x < W) {
                if (den[(size_t)y * (size_t)W + (size_t)x] > 0) {
                    has = 1;
                    break;
                }
            }
        }
        if (has) {
            y_bot = y;
            break;
        }
    }
    if (y_top >= 0 && y_bot >= y_top) {
        y_start = y_top;
        y_end = y_bot;
    }
    for (int y = y_start; y <= y_end; y++) {
        ui_print_lborder();
        int last_pair = -1;
        for (int x = 0; x < W; x++) {
            /* Determine overlays (restricted to the centered square region) */
            int inside_sq = (x >= x0 && x <= x1 && y >= y0 && y <= y1);
            int is_haxis = inside_sq && (y == cy);
            int is_vaxis = inside_sq && (x == cx);
            int is_diag = 0;
            if (inside_sq && opts && (opts->mod_qpsk == 1)) {
                /* Adjust diagonals to preserve ~45° visually under aspect correction */
                int dx = x - cx;
                int y_d1 = cy + (int)lrint((double)dx * y_aspect);
                int y_d2 = cy - (int)lrint((double)dx * y_aspect);
                is_diag = (y == y_d1) || (y == y_d2);
            }

            unsigned short d = den[(size_t)y * (size_t)W + (size_t)x];
            char ch = ' ';
            int used_guide = 0;

            if (is_haxis || is_vaxis || is_diag) {
                /* Choose overlay char */
                if ((is_haxis && is_vaxis) || (is_vaxis && is_diag) || (is_haxis && is_diag)) {
                    ch = '+';
                } else if (is_haxis) {
                    ch = '-';
                } else if (is_vaxis) {
                    ch = '|';
                } else {
                    ch = (x >= cx) ? '\\' : '/';
                }
                if (opts && opts->eye_color && has_colors()) {
                    short gp = is_diag ? guide_x_pair : (is_haxis ? guide_h_pair : guide_v_pair);
                    if (last_pair >= 0) {
                        attroff(COLOR_PAIR(last_pair));
                        last_pair = -1;
                    }
                    attron(COLOR_PAIR(gp));
                    used_guide = gp;
                }
            } else if (inside_sq && d > 0) {
                /* Density glyph + color */
                double f = (double)d / (double)dmax;
                if (f < 0.0) {
                    f = 0.0;
                }
                if (f > 1.0) {
                    f = 1.0;
                }
                double g = gamma_map01(f); /* gamma brighten via LUT */
                if (opts && opts->eye_color && has_colors()) {
                    int ci = (int)lrint(g * (double)(color_len - 1));
                    if (ci < 0) {
                        ci = 0;
                    }
                    if (ci >= color_len) {
                        ci = color_len - 1;
                    }
                    int pid = color_base + ci;
                    if (pid != last_pair) {
                        if (last_pair >= 0) {
                            attroff(COLOR_PAIR(last_pair));
                        }
                        attron(COLOR_PAIR(pid));
                        last_pair = pid;
                    }
                }
                if (use_unicode) {
                    if (use_dots) {
                        int idx = (int)lrint(g * (double)(dot_len - 1));
                        if (idx < 0) {
                            idx = 0;
                        }
                        if (idx >= dot_len) {
                            idx = dot_len - 1;
                        }
                        ch = 0; /* mark to addstr */
                        addstr(dot_palette[idx]);
                    } else {
                        int idx = (int)lrint(g * (double)(block_len - 1));
                        if (idx < 0) {
                            idx = 0;
                        }
                        if (idx >= block_len) {
                            idx = block_len - 1;
                        }
                        ch = 0; /* mark to addstr */
                        addstr(block_palette[idx]);
                    }
                } else {
                    int idx = (int)lrint(g * (double)(ascii_len - 1));
                    if (idx < 0) {
                        idx = 0;
                    }
                    if (idx >= ascii_len) {
                        idx = ascii_len - 1;
                    }
                    ch = ascii_palette[idx];
                }
            }

            /* Reference cluster centers + quadrant labels (QPSK only) */
            if (inside_sq && opts && (opts->mod_qpsk == 1)) {
                /* Reference points near ~70% radius (independent of mode) */
                double refR = 0.70 * (double)s_maxR;
                int ref_ix[4] = {+1, -1, -1, +1};
                int ref_qx[4] = {+1, +1, -1, -1};
                for (int r = 0; r < 4; r++) {
                    double rii = ref_ix[r] * refR;
                    double rqq = ref_qx[r] * refR;
                    double rx, ry;
                    if (opts->const_norm_mode == 1) {
                        /* In unit-circle mode, map 0.70 radius directly */
                        rx = (rii / (double)s_maxR);
                        ry = (rqq / (double)s_maxR);
                    } else {
                        rx = (rii / (double)s_maxR);
                        ry = (rqq / (double)s_maxR);
                    }
                    int xr = cx + (int)lrint(rx * (double)scale_eq * outer_margin);
                    int yr = cy - (int)lrint(ry * (double)scale_eq * outer_margin * y_aspect);
                    if (xr == x && yr == y) {
                        ch = 'o';
                        if (opts->eye_color && has_colors()) {
                            if (last_pair >= 0) {
                                attroff(COLOR_PAIR(last_pair));
                                last_pair = -1;
                            }
                            attron(COLOR_PAIR(guide_x_pair));
                            used_guide = guide_x_pair;
                        }
                    }
                }
                /* Quadrant labels */
                int qdx = (W / 4);
                int qdy = (H / 4);
                if (y == cy - qdy && x == cx + qdx) {
                    ch = '1';
                } else if (y == cy - qdy && x == cx - qdx) {
                    ch = '2';
                } else if (y == cy + qdy && x == cx - qdx) {
                    ch = '3';
                } else if (y == cy + qdy && x == cx + qdx) {
                    ch = '4';
                }
            }

            if (ch != 0) {
                addch(ch);
            }
            if (used_guide) {
                attroff(COLOR_PAIR(used_guide));
                used_guide = 0;
                /* Restore density color if active */
                if (opts && opts->eye_color && has_colors()) {
                    /* Recompute density pair for this cell */
                    if (d > 0) {
                        double f = (double)d / (double)dmax;
                        if (f < 0.0) {
                            f = 0.0;
                        }
                        if (f > 1.0) {
                            f = 1.0;
                        }
                        double g = gamma_map01(f);
                        int ci = (int)lrint(g * (double)(color_len - 1));
                        if (ci < 0) {
                            ci = 0;
                        }
                        if (ci >= color_len) {
                            ci = color_len - 1;
                        }
                        int pid = color_base + ci;
                        attron(COLOR_PAIR(pid));
                        last_pair = pid;
                    }
                }
            }
        }
        if (opts && opts->eye_color && has_colors()) {
            if (last_pair >= 0) {
                attroff(COLOR_PAIR(last_pair));
            }
        }
        printw("\n");
    }

    /* Legend */
    ui_print_lborder();
    printw(" Ref: axes '+', '/'\\'\\' slicer; 'o' cluster refs\n");
    if (use_unicode) {
        if (use_dots) {
            ui_print_lborder();
            printw(" Density: · • ● ⬤  (low -> high)%s\n",
                   (opts && opts->eye_color && has_colors()) ? "; colored" : "");
        } else {
            ui_print_lborder();
            printw(" Density: ▁ ▂ ▃ ▄ ▅ ▆ ▇ █  (low -> high)%s\n",
                   (opts && opts->eye_color && has_colors()) ? "; colored" : "");
        }
    } else {
        ui_print_lborder();
        printw(" Density: . : - = + * # @  (low -> high)%s\n",
               (opts && opts->eye_color && has_colors()) ? "; colored" : "");
    }
    /* Color bar legend (consistent with Eye Diagram) */
    ui_print_lborder();
    printw(" Norm: %s (toggle with 'n')\n", (opts && opts->const_norm_mode) ? "unit-circle" : "radial (p99)");
    if (opts && opts->eye_color && has_colors()) {
        ui_print_lborder();
        addch('\n');
        ui_print_lborder();
        printw(" Color:   ");
        for (int i = 0; i < color_len; i++) {
            attron(COLOR_PAIR((short)(color_base + i)));
            if (use_unicode) {
                addstr("██");
            } else {
                addstr("##");
            }
            attroff(COLOR_PAIR((short)(color_base + i)));
        }
        printw("  low -> high\n");
        ui_print_lborder();
        printw("          ");
        int barw = color_len * 2;
        for (int x = 0; x < barw; x++) {
            if (x == 0 || x == barw / 2 || x == barw - 1) {
                addch('|');
            } else {
                addch(' ');
            }
        }
        printw("\n");
        ui_print_lborder();
        printw("          0%%");
        int pad_mid = barw / 2 - 2;
        for (int i = 0; i < pad_mid; i++) {
            addch(' ');
        }
        printw("50%%");
        int pad_end = barw - (barw / 2 + 2) - 4;
        for (int i = 0; i < pad_end; i++) {
            addch(' ');
        }
        printw("100%%\n");
    }
    attron(COLOR_PAIR(4));
    attron(COLOR_PAIR(4));
    ui_print_hr();
    attroff(COLOR_PAIR(4));
    attroff(COLOR_PAIR(4));
    /* s_den reused; no free */
#else
    ui_print_header("Constellation");
    printw("| (RTL disabled in this build)\n");
    ui_print_hr();
#endif
}

/* Forward decl for int comparator used in eye/hist quartile computation */
static int cmp_int_asc(const void* a, const void* b);

static void
print_eye_view(dsd_opts* opts, dsd_state* state) {
#ifdef USE_RTLSDR
    /* Fetch a snapshot of recent I-channel samples and SPS */
    enum { MAXS = 16384 };

    static int16_t buf[(size_t)MAXS];
    int sps = 0;
    int n = rtl_stream_eye_get(buf, MAXS, &sps);
    ui_print_header("Eye Diagram (C4FM/FSK)");
    /* Auto-fallback to ASCII if Unicode likely unsupported */
    static int s_unicode_ready = -1;
    static int s_unicode_warned = 0;
    if (s_unicode_ready < 0) {
        int ok = 0;
        if (MB_CUR_MAX > 1) {
            ok = 1; /* basic check: multibyte locale active */
        }
        s_unicode_ready = ok;
    }
    if (opts->eye_unicode && !s_unicode_ready) {
        opts->eye_unicode = 0;
        if (!s_unicode_warned) {
            printw("| (Unicode block glyphs unsupported; falling back to ASCII)\n");
            s_unicode_warned = 1;
        }
    }
    if (n <= 0 || sps <= 0) {
        ui_print_lborder();
        printw(" (no samples or SPS)\n");
        attron(COLOR_PAIR(4));
        ui_print_hr();
        attroff(COLOR_PAIR(4));
        return;
    }
    /* Grid size adaptive */
    int rows = 24, cols = 80;
    getmaxyx(stdscr, rows, cols);
    int W = cols - 4;
    if (W < 32) {
        W = 32;
    }
    int H = rows / 3;
    if (H < 12) {
        H = 12;
    }
    /* Density buffer sized to current grid (reuse across frames) */
    size_t den_sz = (size_t)H * (size_t)W;
    static unsigned short* s_den_eye = NULL;
    static size_t s_den_eye_cap = 0;
    if (s_den_eye_cap < den_sz) {
        void* nb = realloc(s_den_eye, den_sz * sizeof(unsigned short));
        if (!nb) {
            free(s_den_eye);
            s_den_eye = NULL;
            s_den_eye_cap = 0;
            printw("| (eye: out of memory)\n");
            ui_print_hr();
            return;
        }
        s_den_eye = (unsigned short*)nb;
        s_den_eye_cap = den_sz;
    }
    unsigned short* den = s_den_eye;
    memset(den, 0, den_sz * sizeof(unsigned short));
    int mid = H / 2;
    /* Normalize peak with EMA for stability */
    static int s_peak = 256;
    int peak = 1;
    for (int i = 0; i < n; i++) {
        int v = buf[i];
        int a = v < 0 ? -v : v;
        if (a > peak) {
            peak = a;
        }
    }
    if (peak < 64) {
        peak = 64;
    }
    s_peak = (int)(0.8 * (double)s_peak + 0.2 * (double)peak);
    if (s_peak < 64) {
        s_peak = 64;
    }
    /* Build quartiles for reference levels */
    int step_ds = (n > 8192) ? (n / 8192) : 1;
    int m = (n + step_ds - 1) / step_ds;
    if (m > 8192) {
        m = 8192;
    }
    static int qvals[8192];
    int vi = 0;
    for (int i = 0; i < n && vi < m; i += step_ds) {
        qvals[vi++] = (int)buf[i];
    }
    m = vi;
    if (m < 8) {
        qvals[0] = -s_peak;
        qvals[1] = s_peak;
        m = 2;
    }
    /* Quartiles via quickselect */
    int idx1 = (int)((size_t)m / 4);
    int idx2 = (int)((size_t)m / 2);
    int idx3 = (int)((size_t)(3 * (size_t)m) / 4);
    int q2 = select_k_int_local(qvals, m, idx2);
    int q1 = select_k_int_local(qvals, idx2, idx1); /* select within lower half */
    int q3 = select_k_int_local(qvals + idx2 + 1, m - (idx2 + 1), idx3 - (idx2 + 1));
    /* Accumulate density by folding modulo 2 symbols */
    int two_sps = 2 * sps;
    if (two_sps < 8) {
        two_sps = 8;
    }
    for (int i = 0; i < n; i++) {
        double v = (double)buf[i] / (double)s_peak;
        if (v > 1.0) {
            v = 1.0;
        }
        if (v < -1.0) {
            v = -1.0;
        }
        int y = mid - (int)lrint(v * ((double)H / 2.0 - 1.0));
        if (y < 0) {
            y = 0;
        }
        if (y >= H) {
            y = H - 1;
        }
        int phase = i % two_sps;
        int x = (int)lrint(((double)phase / (double)(two_sps - 1)) * (double)(W - 1));
        if (x < 0) {
            x = 0;
        }
        if (x >= W) {
            x = W - 1;
        }
        size_t di = (size_t)y * (size_t)W + (size_t)x;
        if (den[di] < 65535) {
            den[di]++;
        }
    }
    /* Determine max density for mapping */
    unsigned short dmax = 1;
    for (int y = 0; y < H; y++) {
        for (int x = 0; x < W; x++) {
            unsigned short dv = den[(size_t)y * (size_t)W + (size_t)x];
            if (dv > dmax) {
                dmax = dv;
            }
        }
    }
    /* Map density to a higher-contrast palette (ASCII or Unicode) and overlay guides */
    /* ASCII palette (low -> high density) */
    static const char ascii_palette[] = " .:-=+*#%@"; /* 10 levels */
    const int ascii_len = (int)(sizeof(ascii_palette) - 1);
    /* Unicode block palette (UTF-8), width 1 per glyph */
    static const char* uni_palette[] = {" ", "▁", "▂", "▃", "▄", "▅", "▆", "▇", "█"}; /* 9 levels */
    const int uni_len = (int)(sizeof(uni_palette) / sizeof(uni_palette[0]));

    /* Optional color density mapping */
    static int color_inited = 0;
    static const short color_seq[] = {COLOR_BLUE,    COLOR_CYAN, COLOR_GREEN, COLOR_YELLOW,
                                      COLOR_MAGENTA, COLOR_RED,  COLOR_WHITE};
    const int color_len = (int)(sizeof(color_seq) / sizeof(color_seq[0]));
    const short color_base = 21; /* avoid clashing with existing pairs */
    /* Guide color pairs (horizontal, vertical, cross) */
    const short guide_h_pair = (short)(color_base + 8);
    const short guide_v_pair = (short)(color_base + 9);
    const short guide_x_pair = (short)(color_base + 10);
    if (opts->eye_color && has_colors() && !color_inited) {
        for (int i = 0; i < color_len; i++) {
            init_pair((short)(color_base + i), color_seq[i], COLOR_BLACK);
        }
        init_pair(guide_h_pair, COLOR_YELLOW, COLOR_BLACK);
        init_pair(guide_v_pair, COLOR_CYAN, COLOR_BLACK);
        init_pair(guide_x_pair, COLOR_MAGENTA, COLOR_BLACK);
        color_inited = 1;
    }

    /* Compute reference rows for quartiles (approximate C4FM levels) */
    int yq1 = mid - (int)lrint(((double)q1 / (double)s_peak) * ((double)H / 2.0 - 1.0));
    if (yq1 < 0) {
        yq1 = 0;
    }
    if (yq1 >= H) {
        yq1 = H - 1;
    }
    int yq2 = mid - (int)lrint(((double)q2 / (double)s_peak) * ((double)H / 2.0 - 1.0));
    if (yq2 < 0) {
        yq2 = 0;
    }
    if (yq2 >= H) {
        yq2 = H - 1;
    }
    int yq3 = mid - (int)lrint(((double)q3 / (double)s_peak) * ((double)H / 2.0 - 1.0));
    if (yq3 < 0) {
        yq3 = 0;
    }
    if (yq3 >= H) {
        yq3 = H - 1;
    }
    /* Symbol boundary columns (phase 0, 1 symbol, 2 symbols) */
    int xb0 = 0;
    int xb1 = (int)lrint(((double)sps / (double)(two_sps - 1)) * (double)(W - 1));
    if (xb1 < 0) {
        xb1 = 0;
    }
    if (xb1 >= W) {
        xb1 = W - 1;
    }
    int xb2 = W - 1;

    /* Draw with overlays */
    for (int y = 0; y < H; y++) {
        ui_print_lborder();
        int last_pair = -1;
        for (int x = 0; x < W; x++) {
            unsigned short d = den[(size_t)y * (size_t)W + (size_t)x];
            char ch = ' ';
            if (d > 0) {
                /* Gamma to brighten low densities */
                double f = (double)d / (double)dmax;
                if (f < 0.0) {
                    f = 0.0;
                }
                if (f > 1.0) {
                    f = 1.0;
                }
                double g = gamma_map01(f); /* gamma = 0.5 via LUT */
                if (opts->eye_unicode) {
                    int idx = (int)lrint(g * (double)(uni_len - 1));
                    if (idx < 0) {
                        idx = 0;
                    }
                    if (idx >= uni_len) {
                        idx = uni_len - 1;
                    }
                    /* Color mapping (based on g) */
                    if (opts->eye_color && has_colors()) {
                        int ci = (int)lrint(g * (double)(color_len - 1));
                        if (ci < 0) {
                            ci = 0;
                        }
                        if (ci >= color_len) {
                            ci = color_len - 1;
                        }
                        int pid = color_base + ci;
                        if (pid != last_pair) {
                            if (last_pair >= 0) {
                                attroff(COLOR_PAIR(last_pair));
                            }
                            attron(COLOR_PAIR(pid));
                            last_pair = pid;
                        }
                    }
                    /* Unicode draw below unless overlays apply */
                    ch = 0; /* marker to indicate we'll addstr() later */
                    /* overlays handled further below */
                    /* store density index in x-local via idx variable */
                    /* reuse idx below if not overridden */
                    /* To keep scope, repeat calculation */
                    ;
                } else {
                    int idx = (int)lrint(g * (double)(ascii_len - 1));
                    if (idx < 0) {
                        idx = 0;
                    }
                    if (idx >= ascii_len) {
                        idx = ascii_len - 1;
                    }
                    if (opts->eye_color && has_colors()) {
                        int ci = (int)lrint(g * (double)(color_len - 1));
                        if (ci < 0) {
                            ci = 0;
                        }
                        if (ci >= color_len) {
                            ci = color_len - 1;
                        }
                        int pid = color_base + ci;
                        if (pid != last_pair) {
                            if (last_pair >= 0) {
                                attroff(COLOR_PAIR(last_pair));
                            }
                            attron(COLOR_PAIR(pid));
                            last_pair = pid;
                        }
                    }
                    ch = ascii_palette[idx];
                }
            }
            /* Determine overlays */
            int is_hline = (y == yq1 || y == yq2 || y == yq3);
            int is_vline = (x == xb0 || x == xb1 || x == xb2);
            int used_guide = 0;
            if (is_hline || is_vline) {
                /* Choose overlay character */
                if (is_hline && is_vline) {
                    ch = '+';
                } else if (is_hline) {
                    ch = (ch == ' ' || ch == '.' || ch == ':') ? '-' : '=';
                } else {
                    ch = (ch == ' ' || ch == '.' || ch == ':' || ch == '-') ? '|' : '+';
                }
                /* Apply guide colors if enabled */
                if (opts->eye_color && has_colors()) {
                    short gp = is_hline && is_vline ? guide_x_pair : (is_hline ? guide_h_pair : guide_v_pair);
                    if (last_pair >= 0) {
                        attroff(COLOR_PAIR(last_pair));
                        last_pair = -1; /* force reapply after */
                    }
                    attron(COLOR_PAIR(gp));
                    used_guide = gp;
                }
            }
            if (opts->eye_unicode && ch == 0 && !used_guide) {
                /* Redetermine density index for unicode and print glyph */
                unsigned short d2 = den[(size_t)y * (size_t)W + (size_t)x];
                double f2 = (double)d2 / (double)dmax;
                if (f2 < 0.0) {
                    f2 = 0.0;
                }
                if (f2 > 1.0) {
                    f2 = 1.0;
                }
                double g2 = gamma_map01(f2);
                int uidx = (int)lrint(g2 * (double)(uni_len - 1));
                if (uidx < 0) {
                    uidx = 0;
                }
                if (uidx >= uni_len) {
                    uidx = uni_len - 1;
                }
                addstr(uni_palette[uidx]);
            } else {
                addch(ch);
            }
            /* If we used guide color, restore previous density color */
            if (used_guide) {
                attroff(COLOR_PAIR(used_guide));
                used_guide = 0;
                /* Re-enable density color if was active */
                if (opts->eye_color && has_colors()) {
                    /* recompute f to restore approximate density color */
                    double f = (double)d / (double)dmax;
                    if (f < 0.0) {
                        f = 0.0;
                    }
                    if (f > 1.0) {
                        f = 1.0;
                    }
                    double g = gamma_map01(f);
                    int ci = (int)lrint(g * (double)(color_len - 1));
                    if (ci < 0) {
                        ci = 0;
                    }
                    if (ci >= color_len) {
                        ci = color_len - 1;
                    }
                    int pid = color_base + ci;
                    attron(COLOR_PAIR(pid));
                    last_pair = pid;
                }
            }
        }
        if (opts->eye_color && has_colors()) {
            if (last_pair >= 0) {
                attroff(COLOR_PAIR(last_pair));
            }
        }
        addch('\n');
    }
    /* Legend + reference info */
    ui_print_lborder();
    printw(" Ref: '-' Q1/Q3, '=' median; '|' edges; '+' crossings\n");
    if (opts->eye_unicode) {
        ui_print_lborder();
        printw(" Density: ▁ ▂ ▃ ▄ ▅ ▆ ▇ █  (low -> high)%s\n", (opts->eye_color && has_colors()) ? "; colored" : "");
    } else {
        ui_print_lborder();
        printw(" Density: . : - = + * # @  (low -> high)%s\n", (opts->eye_color && has_colors()) ? "; colored" : "");
    }
    if (opts->eye_color && has_colors()) {
        ui_print_lborder();
        addch('\n');
        /* Show a color bar legend for density mapping */
        ui_print_lborder();
        printw(" Color:   ");
        for (int i = 0; i < color_len; i++) {
            attron(COLOR_PAIR((short)(color_base + i)));
            if (opts->eye_unicode) {
                addstr("██");
            } else {
                addstr("##");
            }
            attroff(COLOR_PAIR((short)(color_base + i)));
        }
        printw("  low -> high\n");
        /* Ticks under the color bar: 0%, 50%, 100% */
        ui_print_lborder();
        printw("          ");
        int barw = color_len * 2;
        for (int x = 0; x < barw; x++) {
            if (x == 0 || x == barw / 2 || x == barw - 1) {
                addch('|');
            } else {
                addch(' ');
            }
        }
        printw("\n");
        ui_print_lborder();
        printw("          0%%");
        int pad_mid = barw / 2 - 2;
        for (int i = 0; i < pad_mid; i++) {
            addch(' ');
        }
        printw("50%%");
        int pad_end = barw - (barw / 2 + 2) - 4;
        for (int i = 0; i < pad_end; i++) {
            addch(' ');
        }
        printw("100%%\n");
    }
    /* Prefer post-filter demod SNR when available (only for confirmed C4FM) */
    double snr_db = -1.0;
    int is_c4fm = (opts->mod_c4fm == 1);
    if (state) {
        is_c4fm = is_c4fm && (state->rf_mod == 0);
    }
#ifdef USE_RTLSDR
    if (is_c4fm) {
        snr_db = rtl_stream_get_snr_c4fm();
    }
#endif
    if (is_c4fm && snr_db < -20.0) {
        /* Fallback: quick estimate using current buffer */
        if (sps > 0 && n > 100) {
            int c1 = sps / 2;
            int c2 = (3 * sps) / 2;
            int win = sps / 10;
            if (win < 1) {
                win = 1;
            }
            long long cnt[4] = {0, 0, 0, 0};
            double sum[4] = {0, 0, 0, 0};
            for (int i = 0; i < n; i++) {
                int phase = i % two_sps;
                int inwin = (abs(phase - c1) <= win) || (abs(phase - c2) <= win);
                if (!inwin) {
                    continue;
                }
                int v = (int)buf[i];
                int b = (v <= q1) ? 0 : (v <= q2) ? 1 : (v <= q3) ? 2 : 3;
                cnt[b]++;
                sum[b] += (double)v;
            }
            double mu[4] = {0, 0, 0, 0};
            long long total = 0;
            for (int b = 0; b < 4; b++) {
                if (cnt[b] > 0) {
                    mu[b] = sum[b] / (double)cnt[b];
                }
                total += cnt[b];
            }
            if (total > 50 && cnt[0] && cnt[1] && cnt[2] && cnt[3]) {
                double nsum = 0.0;
                for (int i = 0; i < n; i++) {
                    int phase = i % two_sps;
                    int inwin = (abs(phase - c1) <= win) || (abs(phase - c2) <= win);
                    if (!inwin) {
                        continue;
                    }
                    int v = (int)buf[i];
                    int b = (v <= q1) ? 0 : (v <= q2) ? 1 : (v <= q3) ? 2 : 3;
                    double e = (double)v - mu[b];
                    nsum += e * e;
                }
                double noise_var = nsum / (double)total;
                double mu_all = 0.0;
                for (int b = 0; b < 4; b++) {
                    mu_all += mu[b] * (double)cnt[b] / (double)total;
                }
                double ssum = 0.0;
                for (int b = 0; b < 4; b++) {
                    double d = mu[b] - mu_all;
                    ssum += (double)cnt[b] * d * d;
                }
                double sig_var = ssum / (double)total;
                if (noise_var > 1e-9 && sig_var > 1e-9) {
                    snr_db = 10.0 * log10(sig_var / noise_var);
                }
            }
        }
    }
    if (is_c4fm && snr_db >= 0.0) {
        ui_print_lborder();
        printw(" Rows: Q1=%d  Median=%d  Q3=%d   SPS=%d  SNR=%.1f dB\n", yq1, yq2, yq3, sps, snr_db);
    } else {
        ui_print_lborder();
        printw(" Rows: Q1=%d  Median=%d  Q3=%d   SPS=%d  SNR=n/a\n", yq1, yq2, yq3, sps);
    }
    attron(COLOR_PAIR(4));
    ui_print_hr();
    attroff(COLOR_PAIR(4));
    /* den buffer reused across frames; do not free here */
#else
    ui_print_header("Eye Diagram");
    printw("| (RTL disabled in this build)\n");
    ui_print_hr();
#endif
}

/* Comparator for ascending sort of int values (used in FSK histogram quartiles) */
static int
cmp_int_asc(const void* a, const void* b) {
    int ia = *(const int*)a;
    int ib = *(const int*)b;
    return (ia > ib) - (ia < ib);
}

static void
print_fsk_hist_view(void) {
#ifdef USE_RTLSDR
    enum { MAXS = 8192 };

    static int16_t buf[(size_t)MAXS];
    int sps = 0;
    int n = rtl_stream_eye_get(buf, MAXS, &sps);
    ui_print_header("FSK 4-Level Histogram");
    if (n <= 0) {
        ui_print_lborder();
        printw(" (no samples)\n");
        attron(COLOR_PAIR(4));
        ui_print_hr();
        attroff(COLOR_PAIR(4));
        return;
    }
    /* Compute peak and mean DC offset */
    int peak = 1;
    int64_t sum = 0;
    for (int i = 0; i < n; i++) {
        int v = (int)buf[i];
        int a = v < 0 ? -v : v;
        if (a > peak) {
            peak = a;
        }
        sum += v;
    }
    if (peak < 64) {
        peak = 64;
    }
    double dc_norm = (double)sum / (double)n / (double)peak; /* ~[-1,1] */

    /* Adaptive quartile thresholds over recent I-channel samples. */
    /* Downsample set for faster sort if needed */
    int step = (n > 4096) ? (n / 4096) : 1;
    int m = (n + step - 1) / step;
    if (m < 8) {
        m = n, step = 1; /* ensure adequate sample count */
    }
    /* Copy sampled values into a temp array for sorting */
    static int vals[8192];
    if (m > 8192) {
        m = 8192;
    }
    int vi = 0;
    for (int i = 0; i < n && vi < m; i += step) {
        vals[vi++] = (int)buf[i];
    }
    m = vi;
    /* Quartiles via quickselect */
    int idx1 = (int)((size_t)m / 4);
    int idx2 = (int)((size_t)m / 2);
    int idx3 = (int)((size_t)(3 * (size_t)m) / 4);
    int q2 = select_k_int_local(vals, m, idx2);
    int q1 = select_k_int_local(vals, idx2, idx1);
    int q3 = select_k_int_local(vals + idx2 + 1, m - (idx2 + 1), idx3 - (idx2 + 1));
    /* Bin using quartile boundaries */
    int64_t bin[4] = {0, 0, 0, 0};
    for (int i = 0; i < n; i++) {
        int v = (int)buf[i];
        int b = 0;
        if (v <= q1) {
            b = 0;
        } else if (v <= q2) {
            b = 1;
        } else if (v <= q3) {
            b = 2;
        } else {
            b = 3;
        }
        bin[b]++;
    }
    /* Draw quartile ruler across value span (min..max) */
    int minv = vals[0];
    int maxv = vals[m - 1];
    if (maxv == minv) {
        maxv = minv + 1; /* avoid div-by-zero */
    }
    const int WR = 60;
    char ruler[(size_t)WR];
    for (int x = 0; x < WR; x++) {
        ruler[x] = '-';
    }
    int p1 = (int)lrint(((double)(q1 - minv) / (double)(maxv - minv)) * (double)(WR - 1));
    int p2 = (int)lrint(((double)(q2 - minv) / (double)(maxv - minv)) * (double)(WR - 1));
    int p3 = (int)lrint(((double)(q3 - minv) / (double)(maxv - minv)) * (double)(WR - 1));
    if (p1 < 0) {
        p1 = 0;
    }
    if (p1 >= WR) {
        p1 = WR - 1;
    }
    if (p2 < 0) {
        p2 = 0;
    }
    if (p2 >= WR) {
        p2 = WR - 1;
    }
    if (p3 < 0) {
        p3 = 0;
    }
    if (p3 >= WR) {
        p3 = WR - 1;
    }
    ruler[p1] = '|';
    ruler[p2] = '+'; /* median */
    ruler[p3] = '|';
    ui_print_lborder();
    printw(" Ruler:  ");
    for (int x = 0; x < WR; x++) {
        addch(ruler[x]);
    }
    printw("  (Q1='|', Median='+', Q3='|')\n");

    /* Draw bars */
    const int W = 60;
    int64_t maxc = 1;
    for (int i = 0; i < 4; i++) {
        if (bin[i] > maxc) {
            maxc = bin[i];
        }
    }
    const char* labels[4] = {"L3(-)", "L1(-)", "L1(+)", "L3(+)"};
    ui_print_lborder();
    printw(" DC Offset: %+0.2f%% of full-scale\n", dc_norm * 100.0);
    for (int i = 0; i < 4; i++) {
        int w = (int)((double)bin[i] / (double)maxc * (double)W + 0.5);
        if (w < 0) {
            w = 0;
        }
        if (w > W) {
            w = W;
        }
        ui_print_lborder();
        printw(" %-6s ", labels[i]);
        for (int x = 0; x < w; x++) {
            addch('#');
        }
        for (int x = w; x < W; x++) {
            addch(' ');
        }
        printw(" %lld\n", (long long)bin[i]);
    }
    attron(COLOR_PAIR(4));
    ui_print_hr();
    attroff(COLOR_PAIR(4));
#else
    ui_print_header("FSK 4-Level Histogram");
    printw("| (RTL disabled in this build)\n");
    ui_print_hr();
#endif
}

static void
print_spectrum_view(dsd_opts* opts) {
#ifdef USE_RTLSDR
    int nfft = rtl_stream_spectrum_get_size();
    if (nfft < 64) {
        nfft = 64;
    }
    if (nfft > 1024) {
        nfft = 1024;
    }
    static float bins_static[1024];
    float* bins = bins_static; /* nfft clamped to <= 1024 above */
    int rate = 0;
    int n = rtl_stream_spectrum_get(bins, nfft, &rate);
    ui_print_header("Spectrum Analyzer");
    if (n <= 0) {
        printw("| (no spectrum yet)\n");
        ui_print_hr();
        return;
    }
    int rows = 24, cols = 80;
    getmaxyx(stdscr, rows, cols);
    int W = cols - 4;
    if (W < 32) {
        W = 32;
    }
    int H = rows / 3;
    if (H < 10) {
        H = 10;
    }
    /* Downsample or upsample bins to match width W */
    static float col[(size_t)2048];
    if (W > (int)(sizeof col / sizeof col[0])) {
        W = (int)(sizeof col / sizeof col[0]);
    }
    if (n >= W) {
        for (int x = 0; x < W; x++) {
            int i0 = (int)((long long)x * n / W);
            int i1 = (int)((long long)(x + 1) * n / W);
            if (i1 <= i0) {
                i1 = i0 + 1;
            }
            if (i1 > n) {
                i1 = n;
            }
            /* Use max within the column to preserve narrow peaks */
            float s = -1e9f;
            for (int i = i0; i < i1; i++) {
                if (bins[i] > s) {
                    s = bins[i];
                }
            }
            col[x] = s;
        }
    } else {
        for (int x = 0; x < W; x++) {
            int src = (int)((long long)x * n / W);
            if (src < 0) {
                src = 0;
            }
            if (src >= n) {
                src = n - 1;
            }
            col[x] = bins[src];
        }
    }
    /* Auto-scale dB floor to 60 dB span around recent max */
    float vmax = -1e9f;
    for (int x = 0; x < W; x++) {
        if (col[x] > vmax) {
            vmax = col[x];
        }
    }
    float vmin = vmax - 60.0f;
    float span = (vmax - vmin);
    if (span < 1.0f) {
        span = 1.0f;
    }

    int use_unicode = (opts && opts->eye_unicode && MB_CUR_MAX > 1);
#ifdef PRETTY_COLORS
    const short C_GOOD = 11, C_MOD = 12, C_POOR = 13;
#endif
    for (int y = 0; y < H; y++) {
        for (int x = 0; x < W; x++) {
            float v = col[x];
            if (v < vmin) {
                v = vmin;
            }
            if (v > vmax) {
                v = vmax;
            }
            float t = (v - vmin) / span; /* 0..1 */
            int h = (int)lrint(t * (H - 1));
            int filled = (H - 1 - y) <= h;
#ifdef PRETTY_COLORS
            /* Color by relative height bands */
            short cp = (t < 0.33f) ? C_POOR : (t < 0.66f) ? C_MOD : C_GOOD;
            if (opts && opts->eye_color && has_colors()) {
                attron(COLOR_PAIR(cp));
            }
#endif
            if (filled) {
                if (use_unicode) {
                    addstr("█");
                } else {
                    addch('#');
                }
            } else {
                addch(' ');
            }
#ifdef PRETTY_COLORS
            if (opts && opts->eye_color && has_colors()) {
                attroff(COLOR_PAIR(cp));
            }
#endif
        }
        addch('\n');
    }
    /* Legend */
    float span_hz = (float)rate;
    int nfft2 = rtl_stream_spectrum_get_size();
    ui_print_lborder();
    printw(" Span: %.1f kHz  \u0394f(FFT): %.1f Hz  \u0394f(col): %.1f Hz  FFT: %d  Glyphs: %s%s\n", span_hz / 1000.0f,
           (rate > 0 && nfft2 > 0) ? (span_hz / (float)nfft2) : 0.0f, (rate > 0 && W > 0) ? (span_hz / (float)W) : 0.0f,
           nfft2, use_unicode ? "Unicode" : "ASCII", (opts && opts->eye_color && has_colors()) ? "; colored" : "");
    /* Frequency ticks around DC */
    ui_print_lborder();
    printw(" Freq: -%.1fk   0   +%.1fk\n", (span_hz * 0.5f) / 1000.0f, (span_hz * 0.5f) / 1000.0f);
    /* Amplitude scale relative to current peak */
    ui_print_lborder();
    printw(" Scale: top=%.1f dB  floor=%.1f dB (relative)\n", vmax, vmin);
#ifdef PRETTY_COLORS
    if (opts && opts->eye_color && has_colors()) {
        printw("| Color:   ");
        attron(COLOR_PAIR(C_POOR));
        if (use_unicode) {
            addstr("██");
        } else {
            addstr("##");
        }
        attroff(COLOR_PAIR(C_POOR));
        printw(" low  ");
        attron(COLOR_PAIR(C_MOD));
        if (use_unicode) {
            addstr("██");
        } else {
            addstr("##");
        }
        attroff(COLOR_PAIR(C_MOD));
        printw(" mid  ");
        attron(COLOR_PAIR(C_GOOD));
        if (use_unicode) {
            addstr("██");
        } else {
            addstr("##");
        }
        attroff(COLOR_PAIR(C_GOOD));
        printw(" high\n");
    }
#endif
    ui_print_hr();
#else
    ui_print_header("Spectrum Analyzer");
    printw("| (RTL disabled in this build)\n");
    ui_print_hr();
#endif
}

static int
compute_p25p1_voice_avg_err(const dsd_state* s, double* out_avg) {
    int len = s->p25_p1_voice_err_hist_len;
    if (len <= 0) {
        return 0;
    }
    double avg = (double)s->p25_p1_voice_err_hist_sum / (double)len;
    if (out_avg) {
        *out_avg = avg;
    }
    return 1;
}

static int
compute_p25p2_voice_avg_err(const dsd_state* s, int slot, double* out_avg) {
    if (slot < 0 || slot > 1) {
        return 0;
    }
    int len = s->p25_p2_voice_err_hist_len;
    if (len <= 0) {
        return 0;
    }
    double avg = (double)s->p25_p2_voice_err_hist_sum[slot] / (double)len;
    if (out_avg) {
        *out_avg = avg;
    }
    return 1;
}

void
ncursesPrinter(dsd_opts* opts, dsd_state* state) {
    uint8_t idas = 0;
    int level = 0;
    int c = 0;
    int i = 0;

    if (opts->audio_in_type != 1) //can't run getch/menu when using STDIN -
    {
        timeout(0);  //
        c = getch(); //
    }

    //Variable reset/set section

    //set lls sync types
    if (state->synctype >= 0) {
        lls = state->synctype;
    }

    //EDACS Channel Tree
    if ((lls == 14 || lls == 15 || lls == 37 || lls == 38) && state->carrier == 1) {

        if (state->edacs_vc_lcn != -1) {
            edacs_channel_tree[state->edacs_vc_lcn][0] = lls;
            edacs_channel_tree[state->edacs_vc_lcn][1] = state->edacs_vc_lcn;
            edacs_channel_tree[state->edacs_vc_lcn][2] = state->lasttg;
            //EDACS standard does not provide source LIDs on channel update messages; instead, for the sake of display, let's
            //assume the prior source for a given LCN is still accurate, unless we have an updated one provided (or the call
            //type has changed under us).
            //
            //If you MUST have perfectly-accurate source LIDs, look at the logged CC messages yourself - incorrect source LIDs
            //may be displayed if we miss an initial call channel assignment.
            if (state->ea_mode == 1
                || (state->lastsrc != 0 || edacs_channel_tree[state->edacs_vc_lcn][4] != state->edacs_vc_call_type)) {
                edacs_channel_tree[state->edacs_vc_lcn][3] = state->lastsrc;
            }
            if (state->ea_mode == 0 && state->lastsrc == 0x800) { //this was from a grant update, so set this to 0
                edacs_channel_tree[state->edacs_vc_lcn][3] = 0;
            }
            edacs_channel_tree[state->edacs_vc_lcn][4] = state->edacs_vc_call_type;
            edacs_channel_tree[state->edacs_vc_lcn][5] = time(NULL);
        }
    }

    //Start Printing Section
    erase();
    if (opts->ncurses_compact == 1) {
        ui_print_hr();
        printw("| Digital Speech Decoder: DSD-neo %s (%s)  | Enter=Menu  q=Quit\n", GIT_TAG, GIT_HASH);
        ui_print_hr();
    }
    if (opts->ncurses_compact == 0) {
        attron(COLOR_PAIR(6));
        ui_print_hr();
        printw("| Digital Speech Decoder: DSD-neo %s (%s)  | Enter=Menu  q=Quit\n", GIT_TAG, GIT_HASH);
        ui_print_hr();
        attroff(COLOR_PAIR(6));
        attron(COLOR_PAIR(4));
    }

    //fix color/pair issue when compact and trunking enabled
    if (opts->ncurses_compact == 1 && opts->p25_trunk == 1) {
        attron(COLOR_PAIR(4));
    }

    // Transient toast message (e.g., mute toggled)
    if (state) {
        time_t now = time(NULL);
        if (state->ui_msg[0] != '\0' && state->ui_msg_expire > now) {
            attron(COLOR_PAIR(2));
            printw("| %s\n", state->ui_msg);
            attroff(COLOR_PAIR(2));
            ui_print_hr();
        } else if (state->ui_msg_expire <= now && state->ui_msg[0] != '\0') {
            // clear stale message
            state->ui_msg[0] = '\0';
        }
    }

    ui_print_header("Input Output");
    if (opts->audio_in_type == 0) {
        printw("| Pulse Signal Input:  %i kHz; %i Ch; ", opts->pulse_digi_rate_in / 1000, opts->pulse_digi_in_channels);
        if (opts->pa_input_idx[0] != 0) {
            printw(" D: %s;", opts->pa_input_idx);
        }
        if (opts->use_rigctl == 1) {
            printw("RIG: %s:%d; ", opts->tcp_hostname, opts->rigctlportno);
        }
        printw("\n");
    }

    if (opts->audio_in_type == 5) {
        printw("| OSS Signal Input: %i kHz; 1 Ch;", SAMPLE_RATE_IN / 1000);
        if (opts->use_rigctl == 1) {
            printw("RIG: %s:%d; ", opts->tcp_hostname, opts->rigctlportno);
        }
        printw("\n");
    }

    if (opts->audio_in_type == 4) {
        printw("| Dibit Bin Input: %s \n", opts->audio_in_dev);
    }

    if (opts->audio_in_type == 44) {
        printw("| Symbol Float Input: %s \n", opts->audio_in_dev);
    }

    if (opts->m17decoderip == 1 && opts->udp_sockfd) {
        printw("| M17 UDP IP Frame Input: %s:%d \n", opts->m17_hostname, opts->m17_portno);
    }

    if (opts->audio_in_type == 8) {
        printw("| TCP Signal Input: %s:%d; %d kHz; 1 Ch; ", opts->tcp_hostname, opts->tcp_portno,
               opts->wav_sample_rate / 1000);
        if (opts->use_rigctl == 1) {
            printw("RIG: %s:%d; ", opts->tcp_hostname, opts->rigctlportno);
        }
        printw("\n");
    }

    if (opts->audio_in_type == 6) {
        const char* host = (opts->udp_in_bindaddr[0] ? opts->udp_in_bindaddr : "127.0.0.1");
        printw("| UDP Signal Input: %s:%d; %d kHz; 1 Ch; ", host, opts->udp_in_portno, opts->wav_sample_rate / 1000);
        if (opts->udp_in_packets == 0ULL) {
            printw("[Waiting]");
        } else {
            printw("Pkts:%llu Drops:%llu", (unsigned long long)opts->udp_in_packets,
                   (unsigned long long)opts->udp_in_drops);
        }
        printw("\n");
    }

    if (opts->audio_in_type == 2) {
        printw("| WAV Audio Input: %s; %d kHz; \n", opts->audio_in_dev, opts->wav_sample_rate);
    }

    if (opts->audio_in_type == 1) {
        printw("| STDIN Standard Input: - Menu Disabled when using STDIN!\n");
        // printw ("| NCURSES Menu Disabled when using STDIN! - Use CTRL + C to Close. \n");
    }

    if (opts->audio_in_type == 3) {
        printw("| RTL: %d;", opts->rtl_dev_index);
        /* Show applied tuner gain when available (actual driver value),
           otherwise fall back to requested value. */
        {
            int g10 = 0, is_auto = 1;
            int have = 0;
#ifdef USE_RTLSDR
            /* Header is already included indirectly via other UI modules. */
            extern int rtl_stream_get_gain(int* out_tenth_db, int* out_is_auto);
            if (rtl_stream_get_gain(&g10, &is_auto) == 0) {
                have = 1;
            }
#endif
            if (have) {
                if (is_auto) {
                    printw(" G: AGC;");
                } else {
                    int gdB = (g10 >= 0) ? (g10 + 5) / 10 : (g10 - 5) / 10;
                    printw(" G: %idB;", gdB);
                }
            } else {
                if (opts->rtl_gain_value == 0) {
                    printw(" G: AGC;");
                } else {
                    printw(" G: %idB;", opts->rtl_gain_value);
                }
            }
        }
        printw(" V: %iX;", opts->rtl_volume_multiplier);
        printw(" PPM: %i;", opts->rtlsdr_ppm_error); //Adjust manually now with { and }
        printw(" SQL: %.1f dB;", pwr_to_dB(opts->rtl_squelch_level));
        printw(" PWR: %.1f dB;", pwr_to_dB(opts->rtl_pwr));
        printw(" BW: %i;", opts->rtl_bandwidth);
        printw(" FRQ: %i;", opts->rtlsdr_center_freq);
        if (opts->rtl_udp_port != 0) {
            printw("\n| External RTL Tuning on UDP Port: %i", opts->rtl_udp_port);
        }
        printw("\n");
        /* Show compact DSP status directly above audio sections (optional) */
        if (opts->show_dsp_panel) {
            print_dsp_status();
        }
        /* Signal quality is shown inline above; no duplicate line here. */
    }

    if (opts->audio_out_type == 0 && opts->analog_only == 0) {
        printw("| Pulse Digital Output: %i kHz; %i Ch; G: %02.0f%%", opts->pulse_digi_rate_out / 1000,
               opts->pulse_digi_out_channels, state->aout_gain * 2);
        if (opts->pulse_digi_out_channels == 2) {
            printw(" G: %02.0f%%", state->aout_gainR * 2);
        }
        if (opts->floating_point == 1) {
            printw(" FLOAT: %02.0f%%;", opts->audio_gain * 2);
        }
        if (opts->audio_gain == 0) {
            printw(" (+|-) Auto  ");
        }
        if (opts->audio_gain > 0) {
            printw(" (+|-) Manual");
        }
        if (opts->use_hpf_d == 1) {
            printw(" HPF");
        }
        if (opts->call_alert == 1) {
            printw(" *CA!"); //Call Alert
        }
        if (opts->pa_output_idx[0] != 0) {
            printw(" D: %s;", opts->pa_output_idx);
        }

        printw(" \n");
    }

    if (opts->audio_out_type == 0 && (opts->frame_provoice == 1 || opts->monitor_input_audio == 1)) {
        printw("| Pulse Analog Output: %i kHz; %i Ch; G: %02.0f%% (/|*) ", opts->pulse_raw_rate_out / 1000,
               opts->pulse_raw_out_channels, opts->audio_gainA);
        if (opts->audio_gainA == 0.0f) {
            printw("Auto   ");
        } else {
            printw("Manual ");
        }
        if (opts->audio_in_type != 3) {
            printw("PWR: %.1f dB; ", pwr_to_dB(opts->rtl_pwr));
        }
        if (opts->use_lpf == 1) {
            printw("F: |LP|");
        } else {
            printw("F: |  |");
        }
        if (opts->use_hpf == 1) {
            printw("HP|");
        } else {
            printw("  |");
        }
        if (opts->use_pbf == 1) {
            printw("PB|");
        } else {
            printw("  |");
        }
        if (opts->pa_output_idx[0] != 0) {
            printw(" D: %s;", opts->pa_output_idx);
        }
        printw(" \n");
    }

    if (opts->audio_out_type == 5 || opts->audio_out_type == 2) {
        printw("| OSS Audio Output: %i kHz; %i Ch; G: %02.0f%%", opts->pulse_digi_rate_out / 1000,
               opts->pulse_digi_out_channels, state->aout_gain * 2);
        if (opts->pulse_digi_out_channels == 2) {
            printw(" G: %02.0f%%", state->aout_gainR * 2);
        }
        if (opts->audio_gain == 0) {
            printw(" (+/-) Auto  ");
        }
        if (opts->audio_gain > 0) {
            printw(" (+/-) Manual");
        }
        if (opts->use_hpf_d == 1) {
            printw(" HPF");
        }
        if (opts->call_alert == 1) {
            printw(" *CA!"); //Call Alert
        }

        if ((opts->audio_out_type == 5 && opts->pulse_digi_rate_out == 48000 && opts->pulse_digi_out_channels == 1)
            && (opts->frame_provoice == 1 || opts->monitor_input_audio == 1)) {
            printw("\n| Analog Monitor PWR: %.1f dB; G: %02.0f%% (/|*) ", pwr_to_dB(opts->rtl_pwr), opts->audio_gainA);
            if (opts->audio_gainA == 0.0f) {
                printw("Auto   ");
            } else {
                printw("Manual ");
            }
            if (opts->use_lpf == 1) {
                printw("F: |LP|");
            } else {
                printw("F: |  |");
            }
            if (opts->use_hpf == 1) {
                printw("HP|");
            } else {
                printw("  |");
            }
            if (opts->use_pbf == 1) {
                printw("PB|");
            } else {
                printw("  |");
            }
        }
        printw(" \n");
    }

    if (opts->audio_out_type == 8) {
        printw("| UDP Digital Output: %s:%d; %d kHz %d Ch; %02.0f%%", opts->udp_hostname, opts->udp_portno,
               opts->pulse_digi_rate_out / 1000, opts->pulse_digi_out_channels, state->aout_gain * 2);
        if (opts->pulse_digi_out_channels == 2) {
            printw(" G: %02.0f%%", state->aout_gainR * 2);
        }
        if (opts->audio_gain == 0) {
            printw(" (+/-) Auto  ");
        }
        if (opts->audio_gain > 0) {
            printw(" (+/-) Manual");
        }
        if (opts->use_hpf_d == 1) {
            printw(" HPF");
        }
        if (opts->call_alert == 1) {
            printw(" *CA!"); //Call Alert
        }
        if ((opts->audio_out_type == 5 && opts->pulse_digi_rate_out == 48000 && opts->pulse_digi_out_channels == 1)
            && (opts->frame_provoice == 1 || opts->monitor_input_audio == 1)) {
            printw(" - Monitor PWR: %.1f dB ", pwr_to_dB(opts->rtl_pwr));
        }
        printw(" \n");
        if (opts->udp_sockfdA != 0) //Analog Output on udp port +2
        {
            printw("| UDP Analog Output: %s:%d; 48 kHz 1 Ch; G: %02.0f%% (/|*) ", opts->udp_hostname,
                   opts->udp_portno + 2, opts->audio_gainA);
            if (opts->audio_gainA == 0.0f) {
                printw("A ");
            } else {
                printw("M ");
            }
            if (opts->audio_in_type != 3) {
                printw("PWR: %.1f dB; ", pwr_to_dB(opts->rtl_pwr));
            }
            if (opts->use_lpf == 1) {
                printw("F: |LP|");
            } else {
                printw("F: |  |");
            }
            if (opts->use_hpf == 1) {
                printw("HP|");
            } else {
                printw("  |");
            }
            if (opts->use_pbf == 1) {
                printw("PB|");
            } else {
                printw("  |");
            }
            printw(" \n");
        }
    }

    if (opts->m17encoder == 1) {
        printw("| M17 Encoder:");
        if (state->m17encoder_tx == 1 && state->m17_vox == 0) {
            printw(" Toggle TX (\\) On ;");
        }
        if (state->m17encoder_tx == 0 && state->m17_vox == 0) {
            printw(" Toggle TX (\\) Off;");
        }
        if (state->m17_vox == 1) {
            printw(" Vox Mode;");
        }
        printw(" Input Gain (/|*): %02.0f%% ", opts->audio_gainA);

        if (opts->use_lpf == 1) {
            printw("F: |LP|");
        } else {
            printw("F: |  |");
        }
        if (opts->use_hpf == 1) {
            printw("HP|");
        } else {
            printw("  |");
        }
        if (opts->use_pbf == 1) {
            printw("PB|");
        } else {
            printw("  |");
        }
        if (opts->audio_in_type != 3 && state->m17_vox == 1) {
            printw(" SQL: %.1f : %.1f dB;", pwr_to_dB(opts->rtl_pwr), pwr_to_dB(opts->rtl_squelch_level));
        }
        printw("\n");
    }

    if (opts->m17_use_ip == 1) {
        printw("| M17 UDP IP Frame Output: %s:%d \n", opts->m17_hostname, opts->m17_portno);
    }

    if (opts->mbe_out_dir[0] != 0 && opts->dmr_stereo == 0) {
        printw("| Writing MBE data files to directory %s\n", opts->mbe_out_dir);
    }

    if (opts->wav_out_raw) {
        printw("| Raw Audio Output: %s\n", opts->wav_out_file_raw);
    }

    if (opts->symbol_out_f) //don't display when not actively capturing
    {
        printw("| Symbol Bin Output: %s\n", opts->symbol_out_file);
    }

    if (opts->dmr_stereo_wav == 0 && opts->wav_out_file[0] != 0) {
        printw("| Decoded WAV Output: %s\n", opts->wav_out_file);
    }

    //new Per Call setup would just be random names until closed,
    //so no need to show, and will be in the event history anyways
    if (opts->dmr_stereo_wav == 1) {
        printw("| Per Call Wav File Enabled to Directory: %s \n", opts->wav_out_dir);
    }

#ifdef PRETTY_COLORS
    if (opts->p25_trunk == 1 && (opts->use_rigctl == 1 || opts->audio_in_type == 3)) {
        printw("| Trunking -");
        if (opts->trunk_tune_group_calls == 0) {
            attron(COLOR_PAIR(2));
        }
        printw(" Group(g)");
        attron(COLOR_PAIR(4));
        if (opts->trunk_tune_private_calls == 0) {
            attron(COLOR_PAIR(2));
        }
        printw(" Private(u)");
        attron(COLOR_PAIR(4));
        if (opts->trunk_tune_data_calls == 0) {
            attron(COLOR_PAIR(2));
        }
        printw(" Data(d)");
        attron(COLOR_PAIR(4));
        if (opts->trunk_tune_enc_calls == 0) {
            attron(COLOR_PAIR(2));
        }
        printw(" Encrypted(e)");
        attron(COLOR_PAIR(4));
        printw(" Calls");
        if (opts->trunk_use_allow_list == 1) {
            printw(" - White List Mode\n");
        } else {
            printw(" - Black List Mode\n");
        }
        // P25 SM summary line + early ENC LO counter
        /* printw("| P25 SM: tunes=%u releases=%u cc_cand add=%u used=%u cnt=%d idx=%d enc_lo_early=%u\n",
               state->p25_sm_tune_count, state->p25_sm_release_count, state->p25_cc_cand_added, state->p25_cc_cand_used,
               state->p25_cc_cand_count, state->p25_cc_cand_idx, state->p25_p2_enc_lo_early); */
        // Only show P25-specific voice/RS metrics when decoding P25
        int is_p25p1 = (lls == 0 || lls == 1);
        int is_p25p2 = (lls == 35 || lls == 36);
        if (is_p25p1 || is_p25p2) {
            // P25p1 voice error snapshot (IMBE ECC) + moving average
            double avgv = 0.0;
            if (compute_p25p1_voice_avg_err(state, &avgv)) {
                printw("| P1 Voice: ERR [%X][%X] Avg BER:%4.1f%%\n", state->errs & 0xF, state->errs2 & 0xF, avgv);
            } else {
                printw("| P1: ERR [%X][%X]\n", state->errs & 0xF, state->errs2 & 0xF);
            }
        }
        if (is_p25p2 || (is_p25p1 && opts->p25_trunk == 1)) {
            // P25p2 voice avg (per slot)
            double avgl = 0.0, avgr = 0.0;
            int hasl = compute_p25p2_voice_avg_err(state, 0, &avgl);
            int hasr = compute_p25p2_voice_avg_err(state, 1, &avgr);
            if (hasl || hasr) {
                if (hasl && hasr) {
                    printw("| P2 Voice: Avg BER - S1:%4.1f%%, S2:%4.1f%%\n", avgl, avgr);
                } else if (hasl) {
                    printw("| P2 Voice: Avg BER - S1:%4.1f%%\n", avgl);
                } else {
                    printw("| P2 Voice: Avg BER - S2:%4.1f%%\n", avgr);
                }
            }

            if ((state->p25_p2_rs_facch_ok | state->p25_p2_rs_facch_err | state->p25_p2_rs_sacch_ok
                 | state->p25_p2_rs_sacch_err | state->p25_p2_rs_ess_ok | state->p25_p2_rs_ess_err)
                != 0) {
                // P25p2 RS summary line
                printw("| P2 RS: FACCH %u/%u SACCH %u/%u ESS %u/%u\n", state->p25_p2_rs_facch_ok,
                       state->p25_p2_rs_facch_err, state->p25_p2_rs_sacch_ok, state->p25_p2_rs_sacch_err,
                       state->p25_p2_rs_ess_ok, state->p25_p2_rs_ess_err);
            }
        }
    }
#else //set on to UPPER CASE, off to lower case
    if (opts->p25_trunk == 1 && (opts->use_rigctl == 1 || opts->audio_in_type == 3)) {
        printw("| Trunking -");
        if (opts->trunk_tune_group_calls == 0) {
            printw(" group(g)");
        } else {
            printw(" GROUP(g)");
        }
        if (opts->trunk_tune_private_calls == 0) {
            printw(" private(u)");
        } else {
            printw(" PRIVATE(u)");
        }
        if (opts->trunk_tune_data_calls == 0) {
            printw(" data(d)");
        } else {
            printw(" DATA(d)");
        }
        if (opts->trunk_tune_enc_calls == 0) {
            printw(" encrypted(e)");
        } else {
            printw(" ENCRYPTED(e)");
        }
        printw(" Calls");
        if (opts->trunk_use_allow_list == 1) {
            printw(" - White List Mode\n");
        } else {
            printw(" - Black List Mode\n");
        }
        // P25 SM summary line + early ENC LO counter
        /* printw("| P25 SM: tunes=%u releases=%u cc_cand add=%u used=%u cnt=%d idx=%d enc_lo_early=%u\n",
               state->p25_sm_tune_count, state->p25_sm_release_count, state->p25_cc_cand_added, state->p25_cc_cand_used,
               state->p25_cc_cand_count, state->p25_cc_cand_idx, state->p25_p2_enc_lo_early); */
        // Only show P25-specific voice/RS metrics when decoding P25
        int is_p25p1_n = (lls == 0 || lls == 1);
        int is_p25p2_n = (lls == 35 || lls == 36);
        if (is_p25p1_n) {
            double avgv = 0.0;
            if (compute_p25p1_voice_avg_err(state, &avgv)) {
                printw("| P1 Voice: ERR [%X][%X] Avg BER:%4.1f%%\n", state->errs & 0xF, state->errs2 & 0xF, avgv);
            } else {
                printw("| P1 Voice: ERR [%X][%X]\n", state->errs & 0xF, state->errs2 & 0xF);
            }
        }
        if (is_p25p2_n) {
            double avgl = 0.0, avgr = 0.0;
            int hasl = compute_p25p2_voice_avg_err(state, 0, &avgl);
            int hasr = compute_p25p2_voice_avg_err(state, 1, &avgr);
            if (hasl || hasr) {
                if (hasl && hasr) {
                    printw("| P2 Voice: Avg BER - S1:%4.1f%%, S2:%4.1f%%\n", avgl, avgr);
                } else if (hasl) {
                    printw("| P2 Voice: Avg BER - S1:%4.1f%%\n", avgl);
                } else {
                    printw("| P2 Voice: Avg BER - S2:%4.1f%%\n", avgr);
                }
            }
            printw("| P2 RS: FACCH %u/%u SACCH %u/%u ESS %u/%u\n", state->p25_p2_rs_facch_ok,
                   state->p25_p2_rs_facch_err, state->p25_p2_rs_sacch_ok, state->p25_p2_rs_sacch_err,
                   state->p25_p2_rs_ess_ok, state->p25_p2_rs_ess_err);
        }
    }
#endif
//print additional information for EDACS modes and toggles
#ifdef PRETTY_COLORS
    if (opts->p25_trunk == 1 && opts->frame_provoice == 1) {
        printw("| \\--EDACS -");
        if (state->ea_mode == -1) {
            attron(COLOR_PAIR(2));
            printw(" Standard/Network");
            printw(" Extended Address");
            attron(COLOR_PAIR(4));
        } else if (state->ea_mode == 0) {
            printw(" Standard/Network");
            attron(COLOR_PAIR(2));
            printw(" Extended Address");
            attron(COLOR_PAIR(4));
        } else if (state->ea_mode == 1) {
            attron(COLOR_PAIR(2));
            printw(" Standard/Network");
            attron(COLOR_PAIR(4));
            printw(" Extended Address");
        }
        printw(" Mode (S);");

        printw(" ESK: %02X", state->esk_mask);
        printw(" (A);");

        if (state->ea_mode == 0) {
            printw(" AFS: %d:%d:%d;", state->edacs_a_bits, state->edacs_f_bits, state->edacs_s_bits);
        }

        //TG Hold on EDACS, if specified by user
        if (state->tg_hold != 0) {
            // Compute AFS for display purposes only
            int a = (state->tg_hold >> state->edacs_a_shift) & state->edacs_a_mask;
            int f = (state->tg_hold >> state->edacs_f_shift) & state->edacs_f_mask;
            int s = state->tg_hold & state->edacs_s_mask;
            if (state->ea_mode == 1) {
                printw("\n|  \\TG HOLD: %d; ", state->tg_hold);
            } else {
                char afs_str[8];
                getAfsString(state, afs_str, a, f, s);
                printw("\n|  \\TG HOLD: %d [%s]; ", state->tg_hold, afs_str);
            }
        }

        attron(COLOR_PAIR(4));
        printw("\n");
    }
#else //set on to UPPER CASE, off to lower case
    if (opts->p25_trunk == 1 && opts->frame_provoice == 1) {
        printw("| \\--EDACS -");
        if (state->ea_mode == -1) {
            printw(" standard/network");
            printw(" extended address");
        } else if (state->ea_mode == 0) {
            printw(" STANDARD/NETWORK");
            printw(" extended address");
        } else if (state->ea_mode == 1) {
            printw(" standard/network");
            printw(" EXTENDED ADDRESS");
        }
        printw(" Mode (S);");

        printw(" ESK: %02X", state->esk_mask);
        printw(" (A) Toggle; ");

        if (state->ea_mode == 0) {
            printw(" AFS: %d:%d:%d;", state->edacs_a_bits, state->edacs_f_bits, state->edacs_s_bits);
        }

        //TG Hold on EDACS, if specified by user
        if (state->tg_hold != 0) {
            // Compute AFS for display purposes only
            int a = (state->tg_hold >> state->edacs_a_shift) & state->edacs_a_mask;
            int f = (state->tg_hold >> state->edacs_f_shift) & state->edacs_f_mask;
            int s = state->tg_hold & state->edacs_s_mask;
            if (state->ea_mode == 1) {
                printw("\n|  \\TG HOLD: %d; ", state->tg_hold);
            } else {
                char afs_str[8];
                getAfsString(state, afs_str, a, f, s);
                printw("\n|  \\TG HOLD: %d [%s]; ", state->tg_hold, afs_str);
            }
        }

        printw("\n");
    }
#endif
    // if (opts->aggressive_framesync == 0) printw ("| Selective CRC ERR Bypass Enabled (RAS) \n");
    if (state->M == 1) {
        if (state->R != 0) {
            printw("| Forcing Key Priority -- NXDN Sc Key: %05lld \n", state->R);
        }
        if (state->K != 0) {
            printw("| Forcing Key Priority -- Moto BP Key: %03lld \n", state->K);
        }
        if (state->K1 != 0) {
            printw("| Forcing Key Priority -- Hytera BP Key: %016llX \n", state->K1);
        }
        if (state->K != 0 && state->K1 != 0) {
            printw("| Warning! Multiple DMR Key Types Loaded! \n"); //warning may not be required
        }
    }
    if (state->M == 0x21) {
        if (state->R != 0) {
            printw("| Forcing Key Priority -- RC4 Key: %010llX \n", state->R);
        }
    }
    if (state->M == 0x16) {
        printw("| Forcing Key Priority -- TYT 16-bit Key: %04llX \n", state->H);
    }

    if (opts->scanner_mode == 1) {
        printw("| Scan Mode: ");
        if (state->lcn_freq_roll != 0) {
            printw(" Frequency: %.06lf Mhz", (double)state->trunk_lcn_freq[state->lcn_freq_roll - 1] / 1000000);
        }
        printw(
            " Speed: %.02lf sec \n",
            opts->trunk_hangtime); //not sure values less than 1 make a difference, may be system/environment dependent
    }

    if (opts->reverse_mute == 1) {
        printw("| Reverse Mute - Muting Unencrypted Voice\n");
    }
    // if (opts->call_alert == 1)   printw ("| Call Alert Tone Enabled\n");

    ui_print_hr();
#ifdef USE_RTLSDR
    /* Only show RTL-SDR section and render visualizers when RTL input is active */
    if (opts->audio_in_type == 3) {
        ui_print_header("RTL-SDR Visual Aids");
        int nfft = rtl_stream_spectrum_get_size();
        /* Controls/status line: only show controls relevant to active views */
        printw("| Const View:  %s (%c)", opts->constellation ? "On" : "Off", DSD_KEY_CONST_VIEW_UPPER);
        if (opts->constellation == 1) {
            printw("  Gate: %.02f (</>)  Norm: %s (%c)",
                   (opts->mod_qpsk == 1) ? opts->const_gate_qpsk : opts->const_gate_other,
                   opts->const_norm_mode ? "unit" : "radial", DSD_KEY_CONST_NORM);
        }
        printw("  Eye: %s (%c)", opts->eye_view ? "On" : "Off", DSD_KEY_EYE_VIEW);
        if (opts->eye_view == 1) {
            printw("  Uni: %s (%c) Col: %s (%c)", opts->eye_unicode ? "On" : "off", DSD_KEY_EYE_UNICODE,
                   opts->eye_color ? "On" : "Off", DSD_KEY_EYE_COLOR);
        }
        printw("  Hist: %s (%c)", opts->fsk_hist_view ? "On" : "Off", DSD_KEY_FSK_HIST);
        printw("  Spec: %s (%c)", opts->spectrum_view ? "On" : "Off", DSD_KEY_SPECTRUM);
        if (opts->spectrum_view == 1) {
            printw("  FFT:%d (%c/%c)", nfft, DSD_KEY_SPEC_DEC, DSD_KEY_SPEC_INC);
        }
        addch('\n');
        ui_print_hr();

        if (opts->constellation == 1) {
            print_constellation_view(opts, state);
        }
        if (opts->eye_view == 1) {
            print_eye_view(opts, state);
        }
        if (opts->fsk_hist_view == 1) {
            print_fsk_hist_view();
        }
        if (opts->spectrum_view == 1) {
            print_spectrum_view(opts);
        }
    }
#endif
    /* Ensure our primary UI color remains active after visual aids */
    attron(COLOR_PAIR(4));

    if (state->carrier == 1) {
        attron(COLOR_PAIR(3));
        level = (int)state->max / 164; //only update on carrier present
        if (opts->mod_qpsk == 1) {
            level = (int)state->max / 328; //test values here
        }
        if (opts->audio_in_type == 4) {
            level = 50; //hard set when reading symbol bin files, otherwise, it will just be near zero
        }
        if (level > 100) {
            level = 100; //cap max at 100 to prevent it going over
        }
    } else {
        level = 0;
    }

    ui_print_header("Audio Decode");
    if (opts->p25_trunk == 1 && opts->p25_is_tuned == 1) {
        printw("| Tuner state: Busy\n");
    }
    if (opts->p25_trunk == 1 && opts->p25_is_tuned == 0) {
        printw("| Tuner state: Free\n");
    }
    printw("| Demod/Rate:  ");
    if (opts->mod_qpsk == 1) {
        printw("[QPSK]");
    }
    if (opts->mod_c4fm == 1) {
        printw("[C4FM]");
    }
    if (opts->mod_gfsk == 1) {
        printw("[GFSK]");
    }
    printw("[%d] \n", (48000 * opts->wav_interpolator) / state->samplesPerSymbol);
    /* (RTL-SDR controls moved to dedicated section above) */
    if (opts->m17encoder == 1) {
        printw("| Encoding:    [%s] \n", opts->output_name);
    }
    printw("| Decoding:    [%s] ", opts->output_name);
    if (opts->aggressive_framesync == 0) {
        printw("CRC/(RAS) ");
    }
    /* Demod SNR (per modulation) */
#ifdef USE_RTLSDR
    {
        double snr = -100.0;
        const char* m = "";
        /* Simple stale detection for cases where SNR stops updating */
        static double last_c4_snr = -999.0; /* C4FM */
        static int last_c4_stable = 0;
        if (state->rf_mod == 0) {
            snr = rtl_stream_get_snr_c4fm();
            m = "C4FM";
            /* If missing or appears stale, compute a quick fallback from the eye buffer */
            if (snr <= -50.0) {
                double fb = rtl_stream_estimate_snr_c4fm_eye();
                if (fb > -50.0) {
                    snr = fb;
                    last_c4_stable = 0;
                }
            } else {
                double delta = fabs(snr - last_c4_snr);
                if (delta < 0.05) {
                    if (++last_c4_stable >= 40) { /* ~couple seconds of no change */
                        double fb = rtl_stream_estimate_snr_c4fm_eye();
                        if (fb > -50.0) {
                            snr = fb;
                        }
                        last_c4_stable = 0;
                    }
                } else {
                    last_c4_stable = 0;
                }
                last_c4_snr = snr;
            }
        } else if (state->rf_mod == 1) {
            snr = rtl_stream_get_snr_cqpsk();
            m = "QPSK";
            /* Fallback: prefer constellation-based QPSK estimator; else use best of C4FM/GFSK */
            static double last_qp_snr = -999.0;
            static int last_qp_stable = 0;
            if (snr <= -50.0) {
                double fb = rtl_stream_estimate_snr_qpsk_const();
                if (fb > -50.0) {
                    snr = fb;
                    last_qp_stable = 0;
                } else {
                    double snr_c = rtl_stream_get_snr_c4fm();
                    double snr_g = rtl_stream_get_snr_gfsk();
                    double snr_fb = (snr_c > snr_g) ? snr_c : snr_g;
                    if (snr_fb > -50.0) {
                        snr = snr_fb;
                    }
                }
            } else {
                double delta = fabs(snr - last_qp_snr);
                if (delta < 0.05) {
                    if (++last_qp_stable >= 40) {
                        double fb = rtl_stream_estimate_snr_qpsk_const();
                        if (fb > -50.0) {
                            snr = fb;
                        }
                        last_qp_stable = 0;
                    }
                } else {
                    last_qp_stable = 0;
                }
                last_qp_snr = snr;
            }
        } else if (state->rf_mod == 2) {
            snr = rtl_stream_get_snr_gfsk();
            m = "GFSK";
            /* Stale/NA fallback: estimate from eye buffer (2-level) */
            static double last_gf_snr = -999.0;
            static int last_gf_stable = 0;
            if (snr <= -50.0) {
                double fb = rtl_stream_estimate_snr_gfsk_eye();
                if (fb > -50.0) {
                    snr = fb;
                    last_gf_stable = 0;
                }
            } else {
                double delta = fabs(snr - last_gf_snr);
                if (delta < 0.05) {
                    if (++last_gf_stable >= 40) {
                        double fb = rtl_stream_estimate_snr_gfsk_eye();
                        if (fb > -50.0) {
                            snr = fb;
                        }
                        last_gf_stable = 0;
                    }
                } else {
                    last_gf_stable = 0;
                }
                last_gf_snr = snr;
            }
        }
        if (snr > -50.0) {
            /* Show current SNR as a compact, colorized meter */
            printw(" SNR: %.1f dB ", snr);
            printw("[");
            print_snr_meter(opts, snr);
            printw("]");
            printw(" (%s)", m);
        } else {
            /* Show placeholder so users can see the field even when no estimate */
            printw(" SNR: n/a (%s) []", m[0] ? m : "-");
        }
    }
#endif
#ifndef USE_RTLSDR
    /* If built without RTL support, still show a placeholder */
    printw(" SNR: n/a []");
#endif
    printw("\n");
    printw("| In Level:    [%02d%%] \n", level);
    /* Quick hint for output mute toggle */
    printw("| Output:      [%s] (x to toggle)\n", (opts->audio_out == 0) ? "Muted" : "On");

    if (opts->dmr_stereo == 0) {
        printw("| Voice Error: [%X][%X]", state->errs & 0xF, state->errs2 & 0xF);
        double avgv = 0.0;
        if (compute_p25p1_voice_avg_err(state, &avgv)) {
            printw(" Avg:%4.1f%%", avgv);
        }
        if (opts->slot1_on == 0) {
            printw(" Off");
        }
        if (opts->slot1_on == 1) {
            printw(" On");
        }
        printw("\n");
    }

    if (opts->dmr_stereo == 1) {
        printw("| Voice Error: [%X][%X] Slot 1 (1)", state->errs & 0xF, state->errs2 & 0xF);
        if (opts->slot1_on == 0) {
            printw(" Off");
        }
        if (opts->slot1_on == 1) {
            printw(" On");
        }
        if (opts->slot_preference == 0) {
            printw(" *Preferred (3)");
        }
        printw("\n");
        printw("| Voice Error: [%X][%X] Slot 2 (2)", state->errsR & 0xF, state->errs2R & 0xF);
        if (opts->slot2_on == 0) {
            printw(" Off");
        }
        if (opts->slot2_on == 1) {
            printw(" On");
        }
        if (opts->slot_preference == 1) {
            printw(" *Preferred (3)");
        }
        printw("\n");
    }
    ui_print_hr();

    ui_print_header("Call Info");

    //DSTAR
    if (lls == 6 || lls == 7 || lls == 18 || lls == 19) {
        printw("| %s ", SyncTypes[lls]);
        printw("\n");
        printw("| RPT2: %s", state->dstar_rpt2);
        printw(" RPT1: %s", state->dstar_rpt1);
        printw("\n");
        printw("| DEST: %s", state->dstar_dst);
        printw("  SRC: %s", state->dstar_src);
        printw("\n");
        printw("| TEXT: %s", state->dstar_txt);
        printw("\n");
        printw("| DATA: %s", state->dstar_gps);
        printw("\n");
    }

    //M17
    if (lls == 8 || lls == 9 || lls == 16 || lls == 17) {

        printw("| ");
        printw("M17: ");

        //insert data type and frame information
        if (state->m17_str_dt == 0) {
            printw("Reserved");
        }
        if (state->m17_str_dt == 1) {
            printw("Data ");
        }
        if (state->m17_str_dt == 2) {
            printw("Voice (3200) ");
        }
        if (state->m17_str_dt == 3) {
            printw("Voice (1600) + Data");
        }

        printw("\n");
        printw("| ");

        printw("DST: ");
        if (state->m17_dst == 0xFFFFFFFFFFFF) {
            printw("BROADCAST ");
        } else if (state->m17_dst != 0 && state->m17_dst >= 0xEE6B28000000) {
            printw("RESERVED (%012llx) ", state->m17_dst);
        } else {
            printw("%s", state->m17_dst_str);
        }

        printw("\n");
        printw("| ");

        printw("SRC: ");
        if (state->m17_src != 0 && state->m17_src >= 0xEE6B28000000) {
            printw("RESERVED (%012llx)", state->m17_src);
        } else {
            printw("%s", state->m17_src_str);
        }

        printw("\n");
        printw("| ");

        printw("CAN: %02d ", state->m17_can);

        printw("\n");
        printw("| ");

        //fill in any extra info, like Meta (IV, etc)
        if (state->m17_enc == 1) {
            printw(" Scrambler - Type: %d", state->m17_enc_st);
        }

        if (state->m17_enc == 2) {
            attron(COLOR_PAIR(1));
            printw("AES-CTR - IV: ");
            //display packed meta as IV
            for (i = 0; i < 16; i++) {
                printw("%02X", state->m17_meta[i]);
            }
        }

        if (state->m17_enc == 3) {
            printw(" Reserved Enc - Type: %d", state->m17_enc_st);
        }

        printw("\n");
    }

    //YSF
    if (lls == 30 || lls == 31) {
        // printw ("\n");
        printw("| ");
        printw("Fusion - ");
        //insert data type and frame information
        if (state->ysf_dt == 0) {
            printw("V/D1 ");
        }
        if (state->ysf_dt == 1) {
            printw("DATA ");
        }
        if (state->ysf_dt == 2) {
            printw("V/D2 ");
        }
        if (state->ysf_dt == 3) {
            printw("VWFR ");
        }
        printw(" ");
        if (state->ysf_cm == 0) {
            printw("Group/CQ ");
        }
        if (state->ysf_cm == 3) {
            printw("Private  ");
        }
        if (state->ysf_cm == 1) {
            printw("Radio ID ");
        }
        if (state->ysf_cm == 2) {
            printw("Reserved ");
        }

        if (state->ysf_fi == 0) {
            printw("HC ");
        }
        if (state->ysf_fi == 1) {
            printw("CC ");
        }
        if (state->ysf_fi == 2) {
            printw("TC ");
        }
        if (state->ysf_fi == 3) {
            printw("XX ");
        }

        printw("\n");
        printw("| ");
        //NOTE: In Radio ID Mode, the DST will be split on Destination and Source Radio ID values
        printw("DST: %s ", state->ysf_tgt);
        printw("SRC: %s ", state->ysf_src);
        printw("\n");
        printw("| ");
        printw("UPL: %s ", state->ysf_upl);
        printw("DNL: %s ", state->ysf_dnl);
        printw("\n");
        printw("| ");
        printw("RM1: %s ", state->ysf_rm1);
        printw("RM2: %s ", state->ysf_rm2);
        printw("\n");
        printw("| ");
        printw("RM3: %s ", state->ysf_rm3);
        printw("RM4: %s ", state->ysf_rm4);

        //these texts can get pretty long and out of sorts, and lots of 0x20 spaces
        //just going to leave these to only be in the console output

        // printw ("\n");
        // printw ("| ");
        // printw ("TXT: ");
        // for (i = 4; i < 8; i++)
        // {
        //   for (int j = 0; j < 20; j++)
        //   {
        //     //no spaces and no asterisks
        //     if (state->ysf_txt[i][j] != 0x2A)
        //       printw ("%c", state->ysf_txt[i][j]);
        //   }
        //   // printw (" "); //just a single space between each 'block'
        // }

        printw("\n");
    }

    //NXDN
    if (lls == 28 || lls == 29) {
        if (strcmp(state->nxdn_location_category, "Type-D") == 0) {
            idas = 1;
        }

        if (opts->p25_trunk == 1) {

            printw("| ");
            if (opts->p25_is_tuned == 0) {
                if (idas == 0) {
                    printw("Monitoring RCCH Channel"); //Control Channel
                }
                if (idas == 1) {
                    printw("Monitoring RTCH2 Channel"); //Idas RTCH2 Channel
                }
                if (state->p25_cc_freq != 0) {
                    printw(" - Frequency: %.06lf Mhz ", (double)state->p25_cc_freq / 1000000);
                }
            } else if (opts->p25_is_tuned == 1) {
                if (idas == 0) {
                    printw("Monitoring RTCH Channel"); //Traffic Channel
                }
                if (idas == 1) {
                    printw("Monitoring RTCH2 Channel"); //Idas RTCH2
                }
                if (state->p25_vc_freq[0] != 0) {
                    printw(" - Frequency: %.06lf Mhz ", (double)state->p25_vc_freq[0] / 1000000);
                }
            }

            printw("\n");
        }

        printw("| ");
        // #ifdef LIMAZULUTWEAKS
        if (idas == 0) {
            printw("NXDN - RAN: %02d; ", state->nxdn_last_ran);
        }
        if (idas == 1) {
            printw("IDAS - Area: %02d; ", state->nxdn_last_ran);
        }
        // #else
        // if (idas == 0) printw ("NXDN - RAN: [%02d] ", rn);
        // if (idas == 1) printw ("IDAS - Area: [%02d] ", rn);
        // #endif
        if (state->nxdn_location_site_code != 0) {
            printw("Cat: %s; ", state->nxdn_location_category);
            printw("Sys Code: %d; ", state->nxdn_location_sys_code);
            printw("Site Code: %d; ", state->nxdn_location_site_code);
        }

        //if system supports Direct Frequency Assignment
        if (state->nxdn_rcn == 1) {
            printw("DFA ");
        }

        printw("\n");
        printw("| ");
        printw("TGT: [%5d] ", state->nxdn_last_tg);
        printw("SRC: [%5d] ", state->nxdn_last_rid);
        printw("Alias: [%s]", state->generic_talker_alias[0]);

        //Group Name Labels from CSV import
        for (int k = 0; k < state->group_tally; k++) {
            if (state->group_array[k].groupNumber == state->nxdn_last_tg) {
                printw("TG: ");
                attron(COLOR_PAIR(4));
                printw(" [%s]", state->group_array[k].groupName);
                printw("[%s] ", state->group_array[k].groupMode);
            } else if (state->group_array[k].groupNumber == state->nxdn_last_rid) {
                attron(COLOR_PAIR(4));
                printw(" [%s]", state->group_array[k].groupName);
            }
            if (state->carrier == 1) {
                attron(COLOR_PAIR(3));
            }
        }

        if (state->carrier == 1) {
            printw(" %s ", state->nxdn_call_type);
        }
        printw("\n|");
        if (state->nxdn_cipher_type > 0) {
            // printw (" ALG: %d Key ID: %02X ", state->nxdn_cipher_type, state->nxdn_key);
            printw(" ALG: %d Key ID: %02d ", state->nxdn_cipher_type, state->nxdn_key);
        }
        if (state->nxdn_cipher_type == 0x1 && state->carrier == 1) {
            if (state->R == 0) {
                attron(COLOR_PAIR(2));
            }
            printw("Scrambler ");
            if (state->R == 0) {
                attroff(COLOR_PAIR(2));
            }
            attron(COLOR_PAIR(3));
            if (state->R != 0) {
                attron(COLOR_PAIR(1));
                printw("Seed: %04llX ", state->payload_miN);
                printw("Key: %05lld ", state->R);
                attron(COLOR_PAIR(3));
            }
        }
        if (state->nxdn_cipher_type == 0x2 && state->carrier == 1) {
            attron(COLOR_PAIR(1));
            printw("IV: %016llX ", state->payload_miN);
            attron(COLOR_PAIR(2));
            printw("DES1 ");
            if (state->R != 0) {
                printw("Key: %016llX ", state->R);
            }
            attroff(COLOR_PAIR(2));
            attron(COLOR_PAIR(3));
        }
        if (state->nxdn_cipher_type == 0x3 && state->carrier == 1) {
            attron(COLOR_PAIR(1));
            printw("IV: %016llX ", state->payload_miN);
            attron(COLOR_PAIR(2));
            printw("AES-256 ");
            if (state->aes_key_loaded[0] == 1) {
                printw("KS: %016llX", state->A4[0]);
            }
            attroff(COLOR_PAIR(2));
            attron(COLOR_PAIR(3));
        }
        if (state->nxdn_cipher_type > 0x3 && state->carrier == 1) {
            attron(COLOR_PAIR(2));
            printw("Unknown Encryption ");
            attroff(COLOR_PAIR(2));
            attron(COLOR_PAIR(3));
        }

        //Active Trunking Channels (NXDN and IDAS)
        if (1 == 1) //opts->p25_trunk
        {
            printw("\n");
            printw("| ");

            //active channel display
            attron(COLOR_PAIR(4));
            for (int i = 0; i < 16; i++) {
                if (state->active_channel[i] != 0) {
                    printw("%s", state->active_channel[i]);
                }
            }

            if (state->carrier == 1) {
                attron(COLOR_PAIR(3));
            } else {
                /* When no active call, keep UI in idle cyan instead of default white */
                attron(COLOR_PAIR(4));
            }
        }

        //TG Hold, if specified by user
        if (state->tg_hold != 0) {
            printw("TG HOLD: %d", state->tg_hold);
        }

        printw("\n");
    }

    //P25 and DMR BS/MS
    if (lls == 0 || lls == 1 || lls == 12 || lls == 13 || lls == 10 || lls == 11 || lls == 32 || lls == 33 || lls == 34
        || lls == 35 || lls == 36) {
        printw("| ");
        if (lls > 1 && lls < 30) {
            printw("DMR BS - DCC: %02i; ", state->dmr_color_code);
            // printw ("%s %s", state->dmr_branding, state->dmr_branding_sub);
            printw("%s ", state->dmr_branding);
            printw("%s", state->dmr_branding_sub);
            printw("%s", state->dmr_site_parms); //site id, net id, etc
            if (state->dmr_rest_channel > 0) {
                printw("Rest LSN: %02d; ", state->dmr_rest_channel);
                if (state->trunk_chan_map[state->dmr_rest_channel] != 0) {
                    printw("Freq: %.06lf Mhz", (double)state->trunk_chan_map[state->dmr_rest_channel] / 1000000);
                }
            } else if (state->p25_cc_freq != 0) {
                printw("Freq: %.06lf MHz", (double)state->p25_cc_freq / 1000000);
            }

        } else if (lls == 32 || lls == 33 || lls == 34) {
            printw("DMR MS - DCC: %02i; ", state->dmr_color_code);
        } else if (lls == 0 || lls == 1) //P1
        {
            printw("P25p1  - %05llX:%03llX:%03llX; RFSS: %lld SITE: %lld ", state->p2_wacn, state->p2_sysid,
                   state->p2_cc, state->p2_rfssid, state->p2_siteid);
            if (state->p25_cc_freq != 0) {
                printw("Freq: %.06lf MHz", (double)state->p25_cc_freq / 1000000);
            }

            //load talker aliases here (Moto, Tait, Harris)
            for (int16_t i = 0; i < state->group_tally; i++) {
                if (state->group_array[i].groupNumber == state->lastsrc) //or state->lastsrc
                {
                    sprintf(state->generic_talker_alias[0], "%s", state->group_array[i].groupName);
                    break;
                }
            }

        } else if (lls == 35 || lls == 36) //P2
        {
            printw("P25p2  - %05llX:%03llX:%03llX; RFSS: %lld SITE: %lld ", state->p2_wacn, state->p2_sysid,
                   state->p2_cc, state->p2_rfssid, state->p2_siteid);
            if (state->p2_wacn == 0 || state->p2_sysid == 0 || state->p2_cc == 0) {
                attron(COLOR_PAIR(2));
                printw(" Phase 2 Missing Parameters ");
                attron(COLOR_PAIR(3));
            } else if (state->p2_wacn == 0xFFFFF || state->p2_sysid == 0xFFF || state->p2_cc == 0xFFF) {
                attron(COLOR_PAIR(2));
                printw(" Phase 2 Invalid Parameters ");
                attron(COLOR_PAIR(3));
            } else {
                if (state->p25_cc_freq != 0) {
                    printw("Freq: %.06lf MHz", (double)state->p25_cc_freq / 1000000);
                }
            }

            //load talker aliases here (Moto, Tait, Harris)
            for (int16_t i = 0; i < state->group_tally; i++) {
                if (state->group_array[i].groupNumber == state->lastsrc) {
                    sprintf(state->generic_talker_alias[0], "%s", state->group_array[i].groupName);
                    break;
                }
            }

            //load talker aliases here (Moto, Tait, Harris)
            for (int16_t i = 0; i < state->group_tally; i++) {
                if (state->group_array[i].groupNumber == state->lastsrcR) {
                    sprintf(state->generic_talker_alias[1], "%s", state->group_array[i].groupName);
                    break;
                }
            }
        }

        printw("\n");
        //Slot 1 [0]
        printw("| SLOT 1 - ");
        if (state->dmrburstL < 16 && state->carrier == 1 && state->lasttg > 0 && state->lastsrc > 0) {
            attron(COLOR_PAIR(2));
        }
        // Only show IDs when the left slot is actively in a call; otherwise avoid stale values
        // Active when:
        //  - DMR voice (16)
        //  - P25p2: PTT/VOICE/HANGTIME (20/21/22)
        //  - P25p1 voice frames (26/27)
        int show_l_ids = (state->dmrburstL == 16) || (state->dmrburstL >= 20 && state->dmrburstL <= 22)
                         || (state->dmrburstL == 26) || (state->dmrburstL == 27);
        if (show_l_ids) {
            printw("TGT: [%8i] SRC: [%8i] ", state->lasttg, state->lastsrc);
        } else {
            // Blank out IDs cleanly when slot 1 is not in an active call
            printw("TGT: [        ] SRC: [        ] ");
        }
        if (state->dmrburstL != 16 && state->carrier == 1 && state->lasttg > 0 && state->lastsrc > 0) {
            attroff(COLOR_PAIR(2));
            attron(COLOR_PAIR(3));
        }

        printw("%s | ", state->call_string[0]);
        printw("%s ", DMRBusrtTypes[state->dmrburstL]);

        if (opts->slot_preference == 1 && opts->audio_out_type == 5 && opts->audio_out == 1
            && (state->dmrburstL == 16 || state->dmrburstL == 21)
            && (state->dmrburstR == 16 || state->dmrburstR == 21)) {
            printw("*M*");
        }

        printw("\n");

        printw("| V XTRA | "); //10 spaces

        if (state->dmrburstL == 16 && state->payload_algid == 0
            && state->dmr_so & 0x40) //4F or CF mask? & 0xCF currently //&& (state->dmr_so & 0xCF) == 0x40
        {
            attron(COLOR_PAIR(5));
            printw(" **BP** ");
            attroff(COLOR_PAIR(5));
            attron(COLOR_PAIR(3));
        }

        if (state->dmrburstL == 16 && state->payload_algid == 0 && state->K > 0 && state->dmr_fid == 0x10
            && state->dmr_so & 0x40) {
            attron(COLOR_PAIR(1));
            printw("BP Key: %3lld ", state->K);
            attroff(COLOR_PAIR(1));
            attron(COLOR_PAIR(3));
        }

        if (state->dmrburstL == 16 && state->payload_algid == 0 && state->H > 0 && state->dmr_fid == 0x68
            && state->dmr_so & 0x40) {
            attron(COLOR_PAIR(1));
            printw("Hytera BP Key: %010llX ", state->H);
            attroff(COLOR_PAIR(1));
            attron(COLOR_PAIR(3));
        }

        //ALG, KeyID, MI                            //was key_id
        if (state->dmrburstL == 16 && state->payload_algid > 0 && state->dmr_so & 0x40) {
            attron(COLOR_PAIR(1));
            printw("ALG: 0x%02X KEY: 0x%02X MI: 0x%08llX ", state->payload_algid, state->payload_keyid,
                   state->payload_mi);
            attroff(COLOR_PAIR(1));
            attron(COLOR_PAIR(3));
        }

        //P25 FDMA/TDMA
        if (state->dmrburstL > 19 && state->payload_algid > 0 && state->payload_algid != 0x80) {
            attron(COLOR_PAIR(1));
            printw("ALG: 0x%02X KEY: 0x%04X MI: 0x%016llX ", state->payload_algid, state->payload_keyid,
                   state->payload_miP);
            attroff(COLOR_PAIR(1));
            attron(COLOR_PAIR(3));
        }

        //Anytone 0x01 will never show here since its converted to 0x21 for handling
        if (state->payload_algid == 0xAA || state->payload_algid == 0x21 || state->payload_algid == 0x01) {
            attron(COLOR_PAIR(1));
            printw("RC4 ");
            if (state->R != 0) {
                printw("Key: %010llX ", state->R);
            }
            attron(COLOR_PAIR(3));
        }
        if (state->payload_algid == 0x81 || state->payload_algid == 0x22) {
            attron(COLOR_PAIR(1));
            printw("DES1 ");
            if (state->R != 0) {
                printw("Key: %010llX ", state->R);
            }
            attron(COLOR_PAIR(3));
        }
        if (state->payload_algid == 0x9F) {
            attron(COLOR_PAIR(1));
            printw("DES-XL ");
            if (state->R != 0) {
                printw("Key: %010llX ", state->R);
            }
            attron(COLOR_PAIR(3));
        }
        if (state->payload_algid == 0x82) {
            attron(COLOR_PAIR(1));
            printw("DES2 ");
            attron(COLOR_PAIR(3));
        }
        if (state->payload_algid == 0x83) {
            attron(COLOR_PAIR(1));
            printw("DES3 ");
            attron(COLOR_PAIR(3));
        }
        if (state->payload_algid == 0x89 || state->payload_algid == 0x24) {
            attron(COLOR_PAIR(1));
            printw("AES-128 ");
            if (state->aes_key_loaded[0] != 0) {
                printw("KS: %016llX ", state->A2[0]);
            }
            attron(COLOR_PAIR(3));
        }
        if (state->payload_algid == 0x84 || state->payload_algid == 0x25 || state->payload_algid == 0x05) {
            attron(COLOR_PAIR(1));
            printw("AES-256 ");
            if (state->aes_key_loaded[0] != 0) {
                printw("KS: %016llX ", state->A4[0]);
            }
            attron(COLOR_PAIR(3));
        }
        if (state->payload_algid == 0x02) {
            attron(COLOR_PAIR(1));
            printw("Hytera Enhanced");
            if (state->R != 0) {
                printw(" Key: %010llX", state->R);
            }
            attron(COLOR_PAIR(3));
        }

        printw("\n");

        //printw ("|        | "); //10 spaces
        printw("| D XTRA | ");

        attron(COLOR_PAIR(4));

        if (state->dmrburstL == 16 || state->dmrburstL == 21 || state->dmrburstL == 26 || state->dmrburstL == 27
            || state->dmrburstL == 32) //only during call
        {

            attron(COLOR_PAIR(4));

            //Embedded GPS (not LRRP)
            printw("%s ", state->dmr_embedded_gps[0]);

            //Embedded Talker Alias String (show when present during active call)
            if (state->generic_talker_alias[0][0] != '\0') {
                printw("%s ", state->generic_talker_alias[0]);
            }

            attroff(COLOR_PAIR(5));
            if (state->carrier == 1) {
                attron(COLOR_PAIR(3));
            }
        }

        //LRRP
        if (state->dmrburstL != 16) //only during data and no trunking
        {
            attron(COLOR_PAIR(4));
            printw("%s", state->dmr_lrrp_gps[0]);
        }

        //Group Name Labels from CSV import
        if (state->dmrburstL == 16 || state->dmrburstL > 19) {
            for (int k = 0; k < state->group_tally; k++) {
                if (state->group_array[k].groupNumber == state->lasttg) {
                    attron(COLOR_PAIR(4));
                    printw(" [%s]", state->group_array[k].groupName);
                    printw("[%s] ", state->group_array[k].groupMode);
                    if (state->carrier == 1) {
                        attron(COLOR_PAIR(3));
                    }
                }
            }
        }

        if (state->carrier == 1) {
            attron(COLOR_PAIR(3));
        } else {
            /* Restore idle cyan after extras when carrier drops */
            attron(COLOR_PAIR(4));
        }

        printw("\n");

        //Slot 2 [1] -- Also Including DMR MS now to keep the display more 'uniform' in nature
        // if (lls < 30 || lls == 35 || lls == 36)
        {
            printw("| SLOT 2 - ");
            if (state->dmrburstR < 16 && state->carrier == 1 && state->lasttgR > 0 && state->lastsrcR > 0) {
                attron(COLOR_PAIR(2));
            }
            // Only show IDs when the right slot is actively in a call; otherwise avoid stale values
            // Active when:
            //  - DMR voice (16)
            //  - P25p2: PTT/VOICE/HANGTIME (20/21/22)
            //  - P25p1 voice frames (26/27) [right slot used for MS/dual displays]
            int show_r_ids = (state->dmrburstR == 16) || (state->dmrburstR >= 20 && state->dmrburstR <= 22)
                             || (state->dmrburstR == 26) || (state->dmrburstR == 27);
            if (show_r_ids) {
                printw("TGT: [%8i] SRC: [%8i] ", state->lasttgR, state->lastsrcR);
            } else {
                // Blank out IDs cleanly when slot 2 is not in an active call
                printw("TGT: [        ] SRC: [        ] ");
            }
            if (state->dmrburstR != 16 && state->carrier == 1 && state->lasttgR > 0 && state->lastsrcR > 0) {
                attroff(COLOR_PAIR(2));
                attron(COLOR_PAIR(3));
            }

            printw("%s | ", state->call_string[1]);
            printw("%s ", DMRBusrtTypes[state->dmrburstR]);

            if (opts->slot_preference == 0 && opts->audio_out_type == 5 && opts->audio_out == 1
                && (state->dmrburstL == 16 || state->dmrburstL == 21)
                && (state->dmrburstR == 16 || state->dmrburstR == 21)) {
                printw("*M*");
            }

            printw("\n");

            printw("| V XTRA | "); //10 spaces

            if (state->dmrburstR == 16 && state->payload_algidR == 0 && state->dmr_soR & 0x40) //4F or CF mask?
            {
                attron(COLOR_PAIR(5));
                printw(" **BP** ");
                attroff(COLOR_PAIR(5));
                attron(COLOR_PAIR(3));
            }

            if (state->dmrburstR == 16 && state->payload_algidR == 0 && state->K > 0 && state->dmr_soR & 0x40
                && state->dmr_fidR == 0x10) {
                attron(COLOR_PAIR(1));
                printw("BP Key: %3lld ", state->K);
                attroff(COLOR_PAIR(1));
                attron(COLOR_PAIR(3));
            }
            if (state->dmrburstR == 16 && state->payload_algidR == 0 && state->H > 0 && state->dmr_soR & 0x40
                && state->dmr_fidR == 0x68) {
                attron(COLOR_PAIR(1));
                printw("Hytera BP Key: %010llX ", state->H);
                attroff(COLOR_PAIR(1));
                attron(COLOR_PAIR(3));
            }
            //ALG, KeyID, MI 2                          //was keyidR
            if (state->dmrburstR == 16 && state->payload_algidR > 0 && state->dmr_soR & 0x40) {
                attron(COLOR_PAIR(1));
                printw("ALG: 0x%02X KEY: 0x%02X MI: 0x%08llX ", state->payload_algidR, state->payload_keyidR,
                       state->payload_miR);
                attroff(COLOR_PAIR(1));
                attron(COLOR_PAIR(3));
            }
            //P25-P1 and P2
            if (state->dmrburstR > 19 && state->payload_algidR > 0 && state->payload_algidR != 0x80) {
                attron(COLOR_PAIR(1));
                printw("ALG: 0x%02X KEY: 0x%04X MI: 0x%016llX ", state->payload_algidR, state->payload_keyidR,
                       state->payload_miN);
                attroff(COLOR_PAIR(1));
                attron(COLOR_PAIR(3));
            }

            //Anytone 0x01 will never show here since its converted to 0x21 for handling
            if (state->payload_algidR == 0xAA || state->payload_algidR == 0x21 || state->payload_algidR == 0x01) {
                attron(COLOR_PAIR(1));
                printw("RC4 ");
                if (state->RR != 0) {
                    printw("Key: %010llX ", state->RR);
                }
                attron(COLOR_PAIR(3));
            }
            if (state->payload_algidR == 0x81 || state->payload_algidR == 0x22) {
                attron(COLOR_PAIR(1));
                printw("DES1 ");
                if (state->RR != 0) {
                    printw("Key: %010llX ", state->RR);
                }
                attron(COLOR_PAIR(3));
            }
            if (state->payload_algidR == 0x9F) {
                attron(COLOR_PAIR(1));
                printw("DES-XL ");
                if (state->RR != 0) {
                    printw("Key: %010llX ", state->RR);
                }
                attron(COLOR_PAIR(3));
            }
            if (state->payload_algidR == 0x82) {
                attron(COLOR_PAIR(1));
                printw("DES2 ");
                attron(COLOR_PAIR(3));
            }
            if (state->payload_algidR == 0x83) {
                attron(COLOR_PAIR(1));
                printw("DES3 ");
                attron(COLOR_PAIR(3));
            }
            if (state->payload_algidR == 0x89 || state->payload_algidR == 0x24) {
                attron(COLOR_PAIR(1));
                printw("AES-128 ");
                if (state->aes_key_loaded[1] != 0) {
                    printw("KS: %016llX ", state->A2[1]);
                }
                attron(COLOR_PAIR(3));
            }
            if (state->payload_algidR == 0x84 || state->payload_algidR == 0x25 || state->payload_algidR == 0x05) {
                attron(COLOR_PAIR(1));
                printw("AES-256 ");
                if (state->aes_key_loaded[1] != 0) {
                    printw("KS: %016llX ", state->A4[1]);
                }
                attron(COLOR_PAIR(3));
            }
            if (state->payload_algidR == 0x02) {
                attron(COLOR_PAIR(1));
                printw("Hytera Enhanced");
                if (state->RR != 0) {
                    printw(" Key: %010llX", state->RR);
                }
                attron(COLOR_PAIR(3));
            }

            printw("\n");

            //printw ("|        | ");
            printw("| D XTRA | ");

            attron(COLOR_PAIR(4));

            if (state->dmrburstR == 16 || state->dmrburstR == 21) //only during call
            {

                //Embedded GPS (not LRRP)
                attron(COLOR_PAIR(4));
                printw("%s ", state->dmr_embedded_gps[1]);

                //Embedded Talker Alias String (show when present during active call)
                if (state->generic_talker_alias[1][0] != '\0') {
                    printw("%s ", state->generic_talker_alias[1]);
                }

                attroff(COLOR_PAIR(5));
                if (state->carrier == 1) {
                    attron(COLOR_PAIR(3));
                }
            }

            //LRRP
            if (state->dmrburstR != 16) //only during data and no trunking
            {
                attron(COLOR_PAIR(4));
                printw("%s", state->dmr_lrrp_gps[1]);
            }

            //Group Name Labels from CSV import
            if (state->dmrburstR == 16 || state->dmrburstR > 19) {
                for (int k = 0; k < state->group_tally; k++) {
                    if (state->group_array[k].groupNumber == state->lasttgR) {
                        attron(COLOR_PAIR(4));
                        printw(" [%s]", state->group_array[k].groupName);
                        printw("[%s] ", state->group_array[k].groupMode);
                    }
                    if (state->carrier == 1) {
                        attron(COLOR_PAIR(3));
                    }
                }
            }

            if (state->carrier == 1) {
                attron(COLOR_PAIR(3));
            } else {
                /* Keep cyan when idle to avoid white fallback */
                attron(COLOR_PAIR(4));
            }

            printw("\n");

            if (1 == 1) //opts->p25_trunk == 1
            {
                printw("|        | "); //Active Trunking Channels

                //active channel display
                attron(COLOR_PAIR(4));
                for (int i = 0; i < 31; i++) //up to 31 idas channels
                {
                    if (state->active_channel[i] != 0) {
                        printw("%s", state->active_channel[i]);
                    }
                }

                if (state->carrier == 1) {
                    attron(COLOR_PAIR(3));
                } else {
                    /* Keep cyan when idle to avoid white fallback */
                    attron(COLOR_PAIR(4));
                }
                printw("\n");
            }

            if (1 == 1) //opts->p25_trunk == 1
            {
                printw("|        | "); //Currently Tuned Frequency

                // Tuned Frequency Display
                if (state->p25_vc_freq[0] != 0) {
                    attron(COLOR_PAIR(4));
                    printw("Frequency: %.06lf MHz  ", (double)state->p25_vc_freq[0] / 1000000);
                }

                //TG Hold, if specified by user
                if (state->tg_hold != 0) {
                    printw("TG HOLD: %d", state->tg_hold);
                }

                if (state->carrier == 1) {
                    attron(COLOR_PAIR(3));
                } else {
                    /* Keep cyan when idle to avoid white fallback */
                    attron(COLOR_PAIR(4));
                }
                printw("\n");
            }

        } // end if not MS
    } //end DMR BS Types

    //dPMR
    if (lls == 20 || lls == 21 || lls == 22 || lls == 23 || lls == 24 || lls == 25 || lls == 26 || lls == 27) {
        printw("| DCC: [%i] ", state->dpmr_color_code);
        printw("TGT: [%s] SRC: [%s] ", state->dpmr_target_id, state->dpmr_caller_id);
        printw("\n| ");
        if (state->dPMRVoiceFS2Frame.Version[0] == 3) {
            attron(COLOR_PAIR(2));
            printw("Scrambler ");
            attroff(COLOR_PAIR(2));
            attron(COLOR_PAIR(3));
            if (state->R != 0) {
                attron(COLOR_PAIR(1));
                printw("KEY VALUE: [%05lld] ", state->R);
                //printw ("SEED: [%04llX]", state->payload_miN);
                attron(COLOR_PAIR(3));
            }
        }
        printw("\n");
    }

    //EDACS and ProVoice
    if (lls == 14 || lls == 15 || lls == 37 || lls == 38) {
        attroff(COLOR_PAIR(3)); //colors off for EDACS
        if (state->edacs_site_id != 0) {
            if (opts->p25_is_tuned == 0) {
                printw("| Monitoring CC - LCN [%02d]\n", state->edacs_cc_lcn);
            } else {
                printw("| Monitoring VC - LCN [%02d]\n", state->edacs_tuned_lcn);
                //since we are tuned, keep updating the time so it doesn't disappear during call
                edacs_channel_tree[state->edacs_tuned_lcn][5] = time(NULL);
            }
            printw("| SITE [%03lld][%02llX]", state->edacs_site_id, state->edacs_site_id);

            if (state->ea_mode == 1) {
                printw(" Extended Addressing");
            } else {
                printw(" Standard/Networked");
            }
            if (state->esk_mask == 0xA0) {
                printw(" w/  ESK");
            } else {
                printw(" w/o ESK");
            }
            printw("\n");
        }
        for (i = 1; i <= state->edacs_lcn_count; i++) {
            // Compute AFS for display purposes only
            int a = (edacs_channel_tree[i][2] >> state->edacs_a_shift) & state->edacs_a_mask;
            int f = (edacs_channel_tree[i][2] >> state->edacs_f_shift) & state->edacs_f_mask;
            int s = edacs_channel_tree[i][2] & state->edacs_s_mask;
            printw("| - LCN [%02d][%010.06lf] MHz", i, (double)state->trunk_lcn_freq[i - 1] / 1000000);

            //print Control Channel on LCN line with the current Control Channel
            if ((i) == state->edacs_cc_lcn) {
                attron(COLOR_PAIR(1)); //yellow
                printw(" Control Channel");
                attroff(COLOR_PAIR(1));
            }

            int print_call = 0;
            //print active calls on corresponding LCN line
            if ((i != state->edacs_cc_lcn) && time(NULL) - edacs_channel_tree[i][5] < 2) {
                print_call = 3;
                attron(COLOR_PAIR(3));
            }
            //print dying or dead calls in red for x seconds longer
            else if ((i != state->edacs_cc_lcn) && (time(NULL) - edacs_channel_tree[i][5] >= 2)
                     && (time(NULL) - edacs_channel_tree[i][5] < 5)) {
                print_call = 2;
                attron(COLOR_PAIR(2));
            }

            if (print_call != 0) {
                if (state->ea_mode == 1) {
                    // Voice call
                    if ((edacs_channel_tree[i][4] & EDACS_IS_VOICE) != 0) {
                        // Group call
                        if ((edacs_channel_tree[i][4] & EDACS_IS_GROUP) != 0) {
                            printw(" TGT [%8lld] SRC [%8lld]", edacs_channel_tree[i][2], edacs_channel_tree[i][3]);
                        }
                        // I-Call
                        else if ((edacs_channel_tree[i][4] & EDACS_IS_INDIVIDUAL) != 0) {
                            printw(" TGT [%8lld] SRC [%8lld] I-Call", edacs_channel_tree[i][2],
                                   edacs_channel_tree[i][3]);
                        }
                        // System all-call
                        else if ((edacs_channel_tree[i][4] & EDACS_IS_ALL_CALL) != 0) {
                            printw(" TGT [ SYSTEM ] SRC [%8lld] All-Call", edacs_channel_tree[i][3]);
                        }
                        // Interconnect call
                        else if ((edacs_channel_tree[i][4] & EDACS_IS_INTERCONNECT) != 0) {
                            printw(" TGT [ SYSTEM ] SRC [%8lld] Interconnect", edacs_channel_tree[i][3]);
                        }
                        // Test call
                        else if ((edacs_channel_tree[i][4] & EDACS_IS_TEST_CALL) != 0) {
                            printw(" TGT [ SYSTEM ] SRC [ SYSTEM ] Test Call");
                        }
                        // Unknown call
                        else {
                            printw(" Unknown call type");
                        }

                        // Call flags
                        if ((edacs_channel_tree[i][4] & EDACS_IS_TEST_CALL) != 0) {
                        } else if ((edacs_channel_tree[i][4] & EDACS_IS_DIGITAL) == 0) {
                            printw(" [Ana]");
                        } else {
                            printw(" [Dig]");
                        }
                        if ((edacs_channel_tree[i][4] & EDACS_IS_EMERGENCY) != 0) {
                            printw("[EM]");
                        }
                    } else {
                        // Data call
                        printw(" TGT [  DATA  ] SRC [%8lld] Data", edacs_channel_tree[i][3]);
                    }
                } else {
                    // Voice call
                    if ((edacs_channel_tree[i][4] & EDACS_IS_VOICE) != 0) {
                        // Group call
                        if ((edacs_channel_tree[i][4] & EDACS_IS_GROUP) != 0) {
                            char afs_str[8];
                            getAfsString(state, afs_str, a, f, s);
                            printw(" TGT [%6lld][%s] SRC [%5lld]", edacs_channel_tree[i][2], afs_str,
                                   edacs_channel_tree[i][3]);
                        }
                        // I-Call
                        else if ((edacs_channel_tree[i][4] & EDACS_IS_INDIVIDUAL) != 0) {
                            if (getAfsStringLength(state) == 6) {
                                printw(" TGT [%6lld][ UNIT ] SRC [%5lld] I-Call", edacs_channel_tree[i][2],
                                       edacs_channel_tree[i][3]);
                            } else {
                                printw(" TGT [%6lld][  UNIT ] SRC [%5lld] I-Call", edacs_channel_tree[i][2],
                                       edacs_channel_tree[i][3]);
                            }
                        }
                        // System all-call
                        else if ((edacs_channel_tree[i][4] & EDACS_IS_ALL_CALL) != 0) {
                            if (getAfsStringLength(state) == 6) {
                                printw(" TGT [    SYSTEM    ] SRC [%5lld] All-Call", edacs_channel_tree[i][3]);
                            } else {
                                printw(" TGT [     SYSTEM    ] SRC [%5lld] All-Call", edacs_channel_tree[i][3]);
                            }
                        }
                        // Interconnect call
                        else if ((edacs_channel_tree[i][4] & EDACS_IS_INTERCONNECT) != 0) {
                            if (getAfsStringLength(state) == 6) {
                                printw(" TGT [    SYSTEM    ] SRC [%5lld] Interconnect", edacs_channel_tree[i][3]);
                            } else {
                                printw(" TGT [     SYSTEM    ] SRC [%5lld] Interconnect", edacs_channel_tree[i][3]);
                            }
                        }
                        // Test call
                        else if ((edacs_channel_tree[i][4] & EDACS_IS_TEST_CALL) != 0) {
                            if (getAfsStringLength(state) == 6) {
                                printw(" TGT [    SYSTEM    ] SRC [ SYS ] Test Call");
                            } else {
                                printw(" TGT [     SYSTEM    ] SRC [ SYS ] Test Call");
                            }
                        }
                        // Unknown call
                        else {
                            printw(" Unknown call type");
                        }

                        // Call flags
                        if ((edacs_channel_tree[i][4] & EDACS_IS_TEST_CALL) != 0) {
                        } else if ((edacs_channel_tree[i][4] & EDACS_IS_DIGITAL) == 0) {
                            printw(" [Ana]");
                        } else {
                            printw(" [Dig]");
                        }
                        if ((edacs_channel_tree[i][4] & EDACS_IS_AGENCY_CALL) != 0) {
                            printw("[A]");
                        }
                        if ((edacs_channel_tree[i][4] & EDACS_IS_FLEET_CALL) != 0) {
                            printw("[F]");
                        }
                        if ((edacs_channel_tree[i][4] & EDACS_IS_EMERGENCY) != 0) {
                            printw("[EM]");
                        }
                    }
                    // Data call
                    else if (getAfsStringLength(state) == 6) {
                        printw(" TGT [     DATA     ] SRC [%5lld] Data", edacs_channel_tree[i][3]);
                    } else {
                        printw(" TGT [      DATA     ] SRC [%5lld] Data", edacs_channel_tree[i][3]);
                    }
                }
                for (int k = 0; k < state->group_tally; k++) {
                    if (state->group_array[k].groupNumber == edacs_channel_tree[i][2]
                        && edacs_channel_tree[i][2] != 0) {
                        printw(" [%s]", state->group_array[k].groupName);
                        printw("[%s]", state->group_array[k].groupMode);
                        break;
                    } else if (state->group_array[k].groupNumber == edacs_channel_tree[i][3]
                               && edacs_channel_tree[i][3] != 0) {
                        printw(" [%s]", state->group_array[k].groupName);
                        printw("[%s]", state->group_array[k].groupMode);
                        break;
                    }
                }

                if (print_call == 3) {
                    attroff(COLOR_PAIR(3));
                } else if (print_call == 2) {
                    attroff(COLOR_PAIR(2));
                }
            }

            if (i == state->edacs_tuned_lcn && opts->p25_is_tuned == 1) {
                printw(" **T**"); //asterisk which lcn is tuned
            }
            printw("\n");
        }
        if (state->carrier == 1) {
            attron(COLOR_PAIR(3));
        }
    }

    //fence bottom
    ui_print_hr();
    //colors off
    if (state->carrier == 1) { //same as above
        attroff(COLOR_PAIR(3));
    }
    //only print event history if enabled
    attron(COLOR_PAIR(4)); //cyan for history
    {
        char hdr[160];
        snprintf(hdr, sizeof(hdr), "Latest Event History ([|])  Slot %d (\\)  Cycle (h): Short/Long/Off",
                 state->eh_slot + 1);
        ui_print_header(hdr);
    }
    if (opts->ncurses_history != 0) {
        for (uint16_t i = (state->eh_index + 1); i < (state->eh_index + 11); i++) {
            uint16_t string_size = 71; //short uniform size that doesn't exceed the fence
            if (opts->ncurses_history == 2) {
                string_size = 1999; //full string size
            }
            uint8_t slot = state->eh_slot;
            uint8_t color_pair = state->event_history_s[slot]
                                     .Event_History_Items[i % 255]
                                     .color_pair; //this is the color pair assignment for this line
            attron(COLOR_PAIR(4));

            char text_string[2000];
            memset(text_string, 0, sizeof(text_string));
            sprintf(text_string, "%s", "BUMBLEBEETUNA");
            if (strncmp(text_string, state->event_history_s[slot].Event_History_Items[i % 255].event_string, 13) != 0) {
                memcpy(text_string, state->event_history_s[slot].Event_History_Items[i % 255].event_string,
                       string_size * sizeof(char));
                text_string[string_size] = 0; //terminate string
                printw("| #%03d ", i % 255);
                attron(COLOR_PAIR(color_pair)); //this is where the custom color switch occurs for the event_string
                printw("%s\n", text_string);
                attron(COLOR_PAIR(4));
            } else {
                printw("| #%03d \n", i % 255); //empty event, but since we can freely scroll now, keeps things uniform
            }

            sprintf(text_string, "%s", "BUMBLEBEETUNA");
            if (strncmp(text_string, state->event_history_s[slot].Event_History_Items[i % 255].text_message, 13) != 0) {
                printw("|");
                attron(COLOR_PAIR(4)); //feel free to change this to any value you want
                printw("      %s\n", state->event_history_s[slot].Event_History_Items[i % 255].text_message);
                attron(COLOR_PAIR(4));
            }

            if (strncmp(text_string, state->event_history_s[slot].Event_History_Items[i % 255].alias, 13) != 0) {
                printw("|");
                attron(COLOR_PAIR(4)); //feel free to change this to any value you want
                printw("      Alias: %s \n", state->event_history_s[slot].Event_History_Items[i % 255].alias);
                attron(COLOR_PAIR(4));
            }

            if (strncmp(text_string, state->event_history_s[slot].Event_History_Items[i % 255].gps_s, 13) != 0) {
                printw("|");
                attron(COLOR_PAIR(4)); //feel free to change this to any value you want
                printw("      GPS: %s \n", state->event_history_s[slot].Event_History_Items[i % 255].gps_s);
                attron(COLOR_PAIR(4));
            }

            if (strncmp(text_string, state->event_history_s[slot].Event_History_Items[i % 255].internal_str, 13) != 0) {
                printw("|");
                attron(COLOR_PAIR(4)); //feel free to change this to any value you want
                printw("      DSD-neo: %s \n", state->event_history_s[slot].Event_History_Items[i % 255].internal_str);
                attron(COLOR_PAIR(4));
            }
        }
    }

    ui_print_hr();
    attroff(COLOR_PAIR(4)); //cyan for history

    refresh();

    //handle input
    ncurses_input_handler(opts, state, c);
}

void
ncursesClose() {
    endwin();
}
