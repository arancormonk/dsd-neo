// SPDX-License-Identifier: ISC
/*
 * Copyright (C) 2025 by arancormonk <180709949+arancormonk@users.noreply.github.com>
 */
/*-------------------------------------------------------------------------------
 * dsd_ncurses_printer.c
 * DSD-FME ncurses open, printer, and close
 *
 * ASCII art generated by:
 * https://fsymbols.com/generators/carty/
 *
 * LWVMOBILE
 * 2025-05 DSD-FME Florida Man Edition
 *
 * ilyacodes
 * 2024-03 EDACS-FME display improvements
 *-----------------------------------------------------------------------------*/

#include <dsd-neo/core/dsd.h>
#include <dsd-neo/core/synctype.h>
#include <dsd-neo/protocol/p25/p25_p2_sm_min.h>
#include <dsd-neo/protocol/p25/p25_sm_watchdog.h>
#include <dsd-neo/protocol/p25/p25_trunk_sm.h>
#include <dsd-neo/runtime/config.h>
#include <dsd-neo/runtime/git_ver.h>
#include <dsd-neo/ui/keymap.h>
#include <math.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#ifdef USE_RTLSDR
#include <dsd-neo/io/rtl_stream_c.h>
#endif

#ifdef __unix__
#include <unistd.h> // dup, dup2, close
#endif

/* When ncurses UI is active, we temporarily suppress stderr to avoid stdio
 * mixed with the curses screen. Keep track so we can restore on close. */
#ifdef __unix__
static int s_stderr_suppressed = 0;
static int s_saved_stderr_fd = -1;
#endif

/* Local quickselect helpers for int arrays (k-th smallest in O(n)) */
static inline void
swap_int_local(int* a, int* b) {
    int t = *a;
    *a = *b;
    *b = t;
}

/* Gamma LUT for density→glyph mapping (sqrt gamma 0.5) */
static int s_gamma_ready = 0;
static float s_gamma_lut[256];

static inline void
gamma_init_once(void) {
    if (s_gamma_ready) {
        return;
    }
    for (int i = 0; i < 256; i++) {
        float x = (float)i / 255.0f;
        s_gamma_lut[i] = sqrtf(x); /* gamma 0.5 */
    }
    s_gamma_ready = 1;
}

static inline double
gamma_map01(double f) {
    if (f <= 0.0) {
        return 0.0;
    }
    if (f >= 1.0) {
        return 1.0;
    }
    gamma_init_once();
    int idx = (int)lrint(f * 255.0);
    if (idx < 0) {
        idx = 0;
    }
    if (idx > 255) {
        idx = 255;
    }
    return (double)s_gamma_lut[idx];
}

/* Determine if an Active Channel label refers to a locked-out target.
 * Supports both "TG:" (group) and "TGT:" (target/private/data) fields.
 * Returns 1 when the referenced ID is marked with groupMode "DE" or "B". */
static int
ui_is_locked_from_label(const dsd_state* state, const char* label) {
    if (!state || !label || !*label) {
        return 0;
    }
    /* Try group first ("TG:") */
    const char* pos = strstr(label, "TG:");
    if (!pos) {
        /* Fallback to generic target ("TGT:") often used for private/data */
        pos = strstr(label, "TGT:");
    }
    if (!pos) {
        return 0;
    }
    pos += 3; /* skip TG: or TGT: prefix; both are 3 chars before ':' */
    if (*pos == ':') {
        pos++;
    }
    while (*pos == ' ') {
        pos++;
    }
    char* endp = NULL;
    long id = strtol(pos, &endp, 10);
    if (endp == pos || id <= 0) {
        return 0;
    }
    for (unsigned int k = 0; k < state->group_tally; k++) {
        if (state->group_array[k].groupNumber == (unsigned long)id) {
            const char* m = state->group_array[k].groupMode;
            if (strcmp(m, "DE") == 0 || strcmp(m, "B") == 0) {
                return 1;
            }
            break;
        }
    }
    return 0;
}

static int
select_k_int_local(int* a, int n, int k) {
    int lo = 0, hi = n - 1;
    while (lo <= hi) {
        int mid = lo + (hi - lo) / 2;
        int pivot = a[mid];
        int lt = lo, i = lo, gt = hi;
        while (i <= gt) {
            if (a[i] < pivot) {
                swap_int_local(&a[i++], &a[lt++]);
            } else if (a[i] > pivot) {
                swap_int_local(&a[i], &a[gt--]);
            } else {
                i++;
            }
        }
        if (k < lt) {
            hi = lt - 1;
        } else if (k > gt) {
            lo = gt + 1;
        } else {
            return a[k];
        }
    }
    return a[k];
}

char mbeversionstr[25]; //MBElib version string
static unsigned long long int edacs_channel_tree[33][6];

/* SNR history buffers for sparkline (per modulation) */
enum { SNR_HIST_N = 48 };

static double snr_hist_c4fm[SNR_HIST_N];
static int snr_hist_len_c4fm = 0;
static int snr_hist_head_c4fm = 0;
static double snr_hist_qpsk[SNR_HIST_N];
static int snr_hist_len_qpsk = 0;
static int snr_hist_head_qpsk = 0;
static double snr_hist_gfsk[SNR_HIST_N];
static int snr_hist_len_gfsk = 0;
static int snr_hist_head_gfsk = 0;

/* UI helpers: dynamic headers and horizontal rules sized to terminal width */
static void
ui_print_hr(void) {
    int rows = 0, cols = 80;
    getmaxyx(stdscr, rows, cols);
    (void)rows;
    (void)rows;
    if (cols < 1 || rows < 1) {
        cols = 80;
    }
    int y = 0, x = 0;
    getyx(stdscr, y, x);
    (void)x;
    mvhline(y, 0, '-', cols);
    if (y + 1 < rows) {
        move(y + 1, 0);
    } else {
        addch('\n');
    }
}

static void
ui_print_header(const char* title) {
    int rows = 0, cols = 80;
    getmaxyx(stdscr, rows, cols);
    (void)rows;
    (void)rows;
    if (cols < 4) {
        cols = 80;
    }
    const char* t = (title && *title) ? title : "";
    int y = 0, x = 0;
    getyx(stdscr, y, x);
    (void)x;
    addstr("--");
    addstr(t);
    int used = 2 + (int)strlen(t);
    if (used < cols) {
        mvhline(y, used, '-', cols - used);
    }
    if (y + 1 < rows) {
        move(y + 1, 0);
    } else {
        addch('\n');
    }
}

/* Print a single left border '|' using the primary UI color (pair 4) */
static inline void
ui_print_lborder(void) {
    attr_t saved_attrs = 0;
    short saved_pair = 0;
    attr_get(&saved_attrs, &saved_pair, NULL);
    attron(COLOR_PAIR(4));
    addch('|');
    /* Restore whatever color pair was active before drawing the border */
    attron(COLOR_PAIR(saved_pair));
}

/* Print a single left border '|' using the Active/Green color (pair 3)
 * Used for sections that should visually align with "active" styling even when idle. */
static inline void
ui_print_lborder_green(void) {
    attr_t saved_attrs = 0;
    short saved_pair = 0;
    attr_get(&saved_attrs, &saved_pair, NULL);
    attron(COLOR_PAIR(3));
    addch('|');
    /* Restore previously active color pair */
    attron(COLOR_PAIR(saved_pair));
}

/* Classify whether a channel mapping matches the active P25 IDEN parameters. */
static int
ui_is_iden_channel(const dsd_state* state, int ch16, long int freq) {
    if (!state || ch16 <= 0 || ch16 >= 65535) {
        return 0;
    }
    // Suppress IDEN classification when not on a P25 system
    int lls = state->synctype;
    int is_p25p1 = (lls == 0 || lls == 1);
    int is_p25p2 = (lls == 35 || lls == 36);
    if (!(is_p25p1 || is_p25p2)) {
        return 0;
    }
    int iden = (ch16 >> 12) & 0xF;
    if (iden < 0 || iden > 15) {
        return 0;
    }
    long base = state->p25_base_freq[iden];
    long spac = state->p25_chan_spac[iden];
    if (base == 0 || spac == 0) {
        return 0;
    }
    static const int slots_per_carrier[16] = {1, 1, 1, 2, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2};
    int type = state->p25_chan_type[iden] & 0xF;
    int denom = 1;
    if ((state->p25_chan_tdma[iden] & 0x1) != 0) {
        if (type < 0 || type > 15) {
            return 0;
        }
        denom = slots_per_carrier[type];
        if (denom <= 0) {
            return 0;
        }
    } else if (state->p25_cc_is_tdma == 1) {
        denom = 2; // conservative fallback (matches compute path)
    }
    int raw = ch16 & 0xFFF;
    int step = raw / denom;
    long int calc = (base * 5) + (step * spac * 125);
    return (calc == freq) ? 1 : 0;
}

/* Match channel/freq to an IDEN index; returns 1 if matched and sets *out_iden, else 0. */
static int
ui_match_iden_channel(const dsd_state* state, int ch16, long int freq, int* out_iden) {
    if (!state) {
        return 0;
    }
    if (!ui_is_iden_channel(state, ch16, freq)) {
        return 0;
    }
    int iden = (ch16 >> 12) & 0xF;
    if (out_iden) {
        *out_iden = iden;
    }
    return 1;
}

/* Map IDEN nibble (0..15) to a color pair in 21..28 (wrap by 8) */
static inline short
ui_iden_color_pair(int iden) {
    if (iden < 0) {
        iden = 0;
    }
    int idx = iden & 7;
    return (short)(21 + idx);
}

/* Small helpers to align key/value fields to a consistent value column. */
static inline void
ui_print_label_pad(const char* label) {
    const int value_col = 14; /* column (from label start) where values begin */
    int lab_len = (int)strlen(label);
    if (lab_len < 0) {
        lab_len = 0;
    }
    /* Draw border using the current active color (green during decode, cyan otherwise) */
    addch('|');
    addch(' ');
    addstr(label);
    addch(':');
    int need = value_col - (lab_len + 1); /* +1 for ':' */
    if (need < 1) {
        need = 1; /* at least one space after ':' */
    }
    for (int i = 0; i < need; i++) {
        addch(' ');
    }
}

static void
ui_print_kv_line(const char* label, const char* fmt, ...) {
    ui_print_label_pad(label);
    va_list ap;
    va_start(ap, fmt);
    vw_printw(stdscr, fmt, ap);
    va_end(ap);
    addch('\n');
}

/* Forward declaration for int ascending comparator (used by qsort for percentiles) */
static int cmp_int_asc(const void* a, const void* b);

static __attribute__((unused)) void
snr_hist_push(int mod, double snr) {
    if (snr < -50.0) {
        return;
    }
    if (snr > 60.0) {
        snr = 60.0;
    }
    int* head = NULL;
    int* len = NULL;
    double* buf = NULL;
    if (mod == 0) {
        head = &snr_hist_head_c4fm;
        len = &snr_hist_len_c4fm;
        buf = snr_hist_c4fm;
    } else if (mod == 1) {
        head = &snr_hist_head_qpsk;
        len = &snr_hist_len_qpsk;
        buf = snr_hist_qpsk;
    } else {
        head = &snr_hist_head_gfsk;
        len = &snr_hist_len_gfsk;
        buf = snr_hist_gfsk;
    }
    int h = *head;
    buf[h] = snr;
    h = (h + 1) % SNR_HIST_N;
    *head = h;
    if (*len < SNR_HIST_N) {
        (*len)++;
    }
}

static __attribute__((unused)) void
print_snr_sparkline(const dsd_opts* opts, int mod) {
    /* Preserve the current color pair so our temporary colors don't clear it */
#ifdef PRETTY_COLORS
    attr_t saved_attrs = 0;
    short saved_pair = 0;
    attr_get(&saved_attrs, &saved_pair, NULL);
#endif
    static const char* uni8[] = {"▁", "▂", "▃", "▄", "▅", "▆", "▇", "█"};
    /* Make the lowest ASCII level visible (no leading space) */
    static const char ascii8[] = ".:;-=+*#"; /* 8 levels */
    /* Respect the UI toggle: only use Unicode blocks when enabled and locale supports it */
    int use_unicode = (opts && opts->eye_unicode && MB_CUR_MAX > 1);
    const int levels = 8;
    const int W = 24;                           /* sparkline width */
    const double clip_lo = 0.0, clip_hi = 30.0; /* dB window */
    const double span = (clip_hi - clip_lo) > 1e-6 ? (clip_hi - clip_lo) : 1.0;

    const double* buf = NULL;
    int len = 0;
    int head = 0;
    if (mod == 0) {
        buf = snr_hist_c4fm;
        len = snr_hist_len_c4fm;
        head = snr_hist_head_c4fm;
    } else if (mod == 1) {
        buf = snr_hist_qpsk;
        len = snr_hist_len_qpsk;
        head = snr_hist_head_qpsk;
    } else {
        buf = snr_hist_gfsk;
        len = snr_hist_len_gfsk;
        head = snr_hist_head_gfsk;
    }
    if (len <= 0) {
        return;
    }
    int start = (head - len + SNR_HIST_N) % SNR_HIST_N;
    int count = len < W ? len : W;
    /* Map most recent to the right; older to the left */
    int idx = (start + (len - count)) % SNR_HIST_N;

    /* Color bands: poor<12 red, 12..18 yellow, >18 green */
    const short C_GOOD = 11, C_MOD = 12, C_POOR = 13;
    for (int x = 0; x < count; x++) {
        double v = buf[idx];
        idx = (idx + 1) % SNR_HIST_N;
        double t = (v - clip_lo) / span;
        if (t < 0.0) {
            t = 0.0;
        }
        if (t > 1.0) {
            t = 1.0;
        }
        int li = (int)floor(t * (levels - 1) + 0.5);
        if (li < 0) {
            li = 0;
        }
        if (li >= levels) {
            li = levels - 1;
        }
        short cp = (v < 12.0) ? C_POOR : (v < 18.0) ? C_MOD : C_GOOD;
#ifdef PRETTY_COLORS
        attron(COLOR_PAIR(cp));
#endif
        if (use_unicode) {
            addstr(uni8[li]);
        } else {
            addch(ascii8[li]);
        }
#ifdef PRETTY_COLORS
        attroff(COLOR_PAIR(cp));
#endif
    }
#ifdef PRETTY_COLORS
    /* Restore previously active color pair (e.g., green call banner) */
    if (saved_pair >= 0) {
        attron(COLOR_PAIR(saved_pair));
    }
#endif
}

/* Render a compact horizontal meter for current SNR using existing glyphs. */
static void
print_snr_meter(const dsd_opts* opts, double snr_db) {
    /* Preserve the current color pair so our temporary colors don't clear it */
#ifdef PRETTY_COLORS
    attr_t saved_attrs = 0;
    short saved_pair = 0;
    attr_get(&saved_attrs, &saved_pair, NULL);
#endif
    /* Color bands match sparkline thresholds */
    const short C_GOOD = 11, C_MOD = 12, C_POOR = 13;
    /* Map 0..30 dB onto 8 glyph levels (same set used elsewhere) */
    static const char* uni8[] = {"▁", "▂", "▃", "▄", "▅", "▆", "▇", "█"};
    static const char ascii8[] = ".:;-=+*#"; /* 8 levels */

    double v = snr_db;
    if (v < 0.0) {
        v = 0.0;
    }
    if (v > 30.0) {
        v = 30.0;
    }
    const int levels = 8;
    int li = (int)floor((v / 30.0) * (levels - 1) + 0.5);
    if (li < 0) {
        li = 0;
    }
    if (li >= levels) {
        li = levels - 1;
    }

    int use_unicode = (opts && opts->eye_unicode && MB_CUR_MAX > 1);
    short cp = (snr_db < 12.0) ? C_POOR : (snr_db < 18.0) ? C_MOD : C_GOOD;
#ifdef PRETTY_COLORS
    attron(COLOR_PAIR(cp));
#endif
    if (use_unicode) {
        addstr(uni8[li]);
    } else {
        addch(ascii8[li]);
    }
#ifdef PRETTY_COLORS
    attroff(COLOR_PAIR(cp));
#endif
#ifdef PRETTY_COLORS
    /* Restore previously active color pair (e.g., green call banner) */
    if (saved_pair >= 0) {
        attron(COLOR_PAIR(saved_pair));
    }
#endif
}

char* DMRBusrtTypes[32] = {
    "PI       ", "VLC      ", "TLC      ", "CSBK     ", "MBCH     ", "MBCC     ", "DATA     ",
    "R12D     ", "R34D     ", "IDLE     ", "R1_D     ", "ERR      ", "DUID ERR ", "R-S ERR  ",
    "CRC ERR  ", "NULL     ", "VOICE",     "         ", "INIT     ", "INIT     ",
    "PTT",      //20 MAC
    "VOICE",    //21 MAC_ACTIVE
    "HANGTIME", //22 MAC
    "PTT END",  //23 MAC
    "IDLE",     //24 MAC
    "HDU",
    "VOICE", //26 LDU1
    "VOICE", //27 LDU2
    "TDU/LC",    "TSBK",
    "SIGNAL", //MAC_SIGNAL
    "SIGNAL"  //MAC_SIGNAL

};

void
ncursesOpen(dsd_opts* opts, dsd_state* state) {

    UNUSED(opts);
    UNUSED(state);

    // state->menuopen = 1; //flag the menu is open, stop processing getFrameSync
    mbe_printVersion(mbeversionstr);
    setlocale(LC_ALL, "");
    initscr(); //Initialize NCURSES screen window
    start_color();
    // Ensure special keys (arrows, keypad Enter) are decoded as KEY_* constants
    keypad(stdscr, TRUE);

#ifdef PRETTY_COLORS
    init_pair(1, COLOR_YELLOW, COLOR_BLACK);  //Yellow/Amber for frame sync/control channel, NV style
    init_pair(2, COLOR_RED, COLOR_BLACK);     //Red for Terminated Calls
    init_pair(3, COLOR_GREEN, COLOR_BLACK);   //Green for Active Calls
    init_pair(4, COLOR_CYAN, COLOR_BLACK);    //Cyan for Site Extra and Patches
    init_pair(5, COLOR_MAGENTA, COLOR_BLACK); //Magenta for no frame sync/signal
    init_pair(6, COLOR_WHITE, COLOR_BLACK);   //White Card Color Scheme
    init_pair(7, COLOR_BLUE, COLOR_BLACK);    //Blue on Black
    init_pair(8, COLOR_BLACK, COLOR_WHITE);   //Black on White
    init_pair(9, COLOR_RED, COLOR_WHITE);     //Red on White
    init_pair(10, COLOR_BLUE, COLOR_WHITE);   //Blue on White
    /* Quality bands for SNR sparkline */
    init_pair(11, COLOR_GREEN, COLOR_BLACK);  //good
    init_pair(12, COLOR_YELLOW, COLOR_BLACK); //moderate
    init_pair(13, COLOR_RED, COLOR_BLACK);    //poor
    init_pair(14, COLOR_YELLOW, COLOR_BLACK); //DSP status (explicit yellow)
    /* IDEN color palette (per-bandplan); 8 slots, wrap IDEN nibble modulo 8 */
    init_pair(21, COLOR_YELLOW, COLOR_BLACK);
    init_pair(22, COLOR_GREEN, COLOR_BLACK);
    init_pair(23, COLOR_CYAN, COLOR_BLACK);
    init_pair(24, COLOR_MAGENTA, COLOR_BLACK);
    init_pair(25, COLOR_BLUE, COLOR_BLACK);
    init_pair(26, COLOR_WHITE, COLOR_BLACK);
    init_pair(27, COLOR_RED, COLOR_BLACK);
    init_pair(28, COLOR_BLACK, COLOR_WHITE); /* high contrast alt */
#else
    init_pair(1, COLOR_WHITE, COLOR_BLACK);  //White Card Color Scheme
    init_pair(2, COLOR_WHITE, COLOR_BLACK);  //White Card Color Scheme
    init_pair(3, COLOR_WHITE, COLOR_BLACK);  //White Card Color Scheme
    init_pair(4, COLOR_WHITE, COLOR_BLACK);  //White Card Color Scheme
    init_pair(5, COLOR_WHITE, COLOR_BLACK);  //White Card Color Scheme
    init_pair(6, COLOR_WHITE, COLOR_BLACK);  //White Card Color Scheme
    init_pair(7, COLOR_WHITE, COLOR_BLACK);  //White Card Color Scheme
    init_pair(8, COLOR_BLACK, COLOR_WHITE);  //White Card Color Scheme
    init_pair(9, COLOR_BLACK, COLOR_WHITE);  //White Card Color Scheme
    init_pair(10, COLOR_BLACK, COLOR_WHITE); //White Card Color Scheme
    init_pair(11, COLOR_WHITE, COLOR_BLACK); //fallback
    init_pair(12, COLOR_WHITE, COLOR_BLACK);
    init_pair(13, COLOR_WHITE, COLOR_BLACK);
    init_pair(14, COLOR_YELLOW, COLOR_BLACK); //DSP status stays yellow even on white card scheme
    /* IDEN color palette fallback */
    for (int p = 21; p <= 28; p++) {
        init_pair(p, COLOR_WHITE, COLOR_BLACK);
    }
#endif

    noecho();
    cbreak();

    //initialize this
    memset(edacs_channel_tree, 0, sizeof(edacs_channel_tree));

    // When ncurses UI is active, suppress direct stderr logging to prevent
    // screen corruption from background fprintf calls in protocol paths.
    // This avoids mixed ncurses/stdio output overwriting the UI until resize.
#ifdef __unix__
    if (!s_stderr_suppressed) {
        // Backup current stderr FD, then redirect to /dev/null.
        int backup_fd = dup(fileno(stderr));
        if (backup_fd >= 0) {
            FILE* devnull = fopen("/dev/null", "w");
            if (devnull) {
                fflush(stderr);
                dup2(fileno(devnull), fileno(stderr));
                fclose(devnull);
                s_saved_stderr_fd = backup_fd;
                s_stderr_suppressed = 1;
            } else {
                // If we cannot open /dev/null, discard backup.
                close(backup_fd);
            }
        }
    }
#endif
}

static int lls = -1;

/* Print a compact DSP status summary (which blocks are active). */
static void
print_dsp_status(void) {
#ifdef USE_RTLSDR
    /* Preserve current color pair so our colored header/HR won't force default */
#ifdef PRETTY_COLORS
    attr_t saved_attrs = 0;
    short saved_pair = 0;
    attr_get(&saved_attrs, &saved_pair, NULL);
#endif
    int cq = 0, fll = 0, ted = 0, auto_on = 0;
    rtl_stream_dsp_get(&cq, &fll, &ted, &auto_on);
    int lms = 0, taps = 0, mu = 0, stride = 0, wl = 0, dfe = 0, dft = 0, mf = 0, cma = 0;
    rtl_stream_cqpsk_get(&lms, &taps, &mu, &stride, &wl, &dfe, &dft, &mf, &cma);
    int rrc_en = 0, rrc_a = 0, rrc_s = 0;
    rtl_stream_cqpsk_get_rrc(&rrc_en, &rrc_a, &rrc_s);
    int iqb = rtl_stream_get_iq_balance();

    ui_print_header("DSP");
    ui_print_lborder();
    attron(COLOR_PAIR(14)); /* explicit yellow for DSP items */
    printw(" Auto: %s ", auto_on ? "On" : "Off");
    printw(" IQ BAL: %s ", iqb ? "On" : "Off");
    printw(" FLL: %s ", fll ? "On" : "Off");
    printw(" TED: %s ", ted ? "On" : "Off");
    printw(" CQPSK: %s", cq ? "On" : "Off");
    if (cq) {
        printw(" [LMS: %s WL: %s DFE: %s MF: %s", lms ? "On" : "Off", wl ? "On" : "Off", dfe ? "On" : "Off",
               mf ? (rrc_en ? "RRC" : "On") : "Off");
        if (rrc_en) {
            printw(" a: %d%% s: %d", rrc_a, rrc_s);
        }
        printw("]");
        attroff(COLOR_PAIR(14));
    }
    printw("\n");
    attron(COLOR_PAIR(4));
    ui_print_hr();
    attroff(COLOR_PAIR(4));
    /* Restore previously active color pair (e.g., banner color) */
#ifdef PRETTY_COLORS
    if (saved_pair >= 0) {
        attron(COLOR_PAIR(saved_pair));
    }
#endif
#endif
}

static void
print_constellation_view(dsd_opts* opts, dsd_state* state) {
    UNUSED(state);
#ifdef USE_RTLSDR
    /* Fetch a snapshot of recent I/Q points */
    enum { MAXP = 4096 };

    int16_t buf[(size_t)MAXP * 2];
    int n = rtl_stream_constellation_get(buf, MAXP);

    ui_print_header("Constellation");
    if (n <= 0) {
        ui_print_lborder();
        printw(" (no samples yet)\n");
        attron(COLOR_PAIR(4));
        ui_print_hr();
        attroff(COLOR_PAIR(4));
        return;
    }

    /* Determine grid size from terminal */
    int rows = 24, cols = 80;
    getmaxyx(stdscr, rows, cols);
    int W = cols - 4;
    if (W < 32) {
        W = 32;
    }
    /* Make the constellation a bit taller by default for readability */
    int H = rows / 2; /* previously rows/3 */
    if (H < 12) {
        H = 12;
    }

    /* Respect UI toggles */
    int use_unicode = (opts && opts->eye_unicode && MB_CUR_MAX > 1);

    /* Local palettes */
    static const char ascii_palette[] = " .:-=+*#%@"; /* 10 levels */
    const int ascii_len = (int)(sizeof(ascii_palette) - 1);
    /* Blocks (eye-style) */
    static const char* block_palette[] = {" ", "▁", "▂", "▃", "▄", "▅", "▆", "▇", "█"}; /* 9 levels */
    const int block_len = (int)(sizeof(block_palette) / sizeof(block_palette[0]));
    /* Dots of increasing weight/size (preferred for constellation) */
    static const char* dot_palette[] = {" ", "·", "∙", "•", "●", "⬤"}; /* 6 levels */
    const int dot_len = (int)(sizeof(dot_palette) / sizeof(dot_palette[0]));
    int use_dots = 1; /* default to dot style for constellation */

    /* Optional color ramp (blue->cyan->green->yellow->red) */
    static const short color_seq[] = {COLOR_BLUE,    COLOR_CYAN, COLOR_GREEN, COLOR_YELLOW,
                                      COLOR_MAGENTA, COLOR_RED,  COLOR_WHITE};
    const int color_len = (int)(sizeof(color_seq) / sizeof(color_seq[0]));
    const short color_base = 41; /* keep separate from eye's base to avoid clashes */
    const short guide_h_pair = (short)(color_base + 8);
    const short guide_v_pair = (short)(color_base + 9);
    const short guide_x_pair = (short)(color_base + 10);
    static int color_inited = 0;
    if (opts && opts->eye_color && has_colors() && !color_inited) {
        for (int i = 0; i < color_len; i++) {
            init_pair((short)(color_base + i), color_seq[i], COLOR_BLACK);
        }
        init_pair(guide_h_pair, COLOR_YELLOW, COLOR_BLACK);
        init_pair(guide_v_pair, COLOR_CYAN, COLOR_BLACK);
        init_pair(guide_x_pair, COLOR_MAGENTA, COLOR_BLACK);
        color_inited = 1;
    }

    /* Density buffer (reused across frames to avoid malloc/free churn) */
    size_t den_sz = (size_t)H * (size_t)W;
    static unsigned short* s_den = NULL;
    static size_t s_den_cap = 0;
    if (s_den_cap < den_sz) {
        void* nb = realloc(s_den, den_sz * sizeof(unsigned short));
        if (!nb) {
            free(s_den);
            s_den = NULL;
            s_den_cap = 0;
            printw("| (constellation: out of memory)\n");
            ui_print_hr();
            return;
        }
        s_den = (unsigned short*)nb;
        s_den_cap = den_sz;
    }
    unsigned short* den = s_den;
    if (den_sz > 0 && den != NULL) {
        memset(den, 0, den_sz * sizeof(unsigned short));
    }
    if (den == NULL) {
        return;
    }

    /* Dynamic radial scale using high-percentile magnitude (robust to outliers), then smooth. */
    static int s_maxR = 256; /* smoothed scale for radius (~99th percentile of |IQ|) */
    /* Collect absolute I/Q and magnitude values for percentile computation */
    static int absI[(size_t)MAXP];
    static int absQ[(size_t)MAXP];
    static int magR[(size_t)MAXP];
    for (int k = 0; k < n; k++) {
        int i = buf[(size_t)(k << 1) + 0];
        int q = buf[(size_t)(k << 1) + 1];
        int ai = (i < 0) ? -i : i;
        int aq = (q < 0) ? -q : q;
        absI[k] = ai;
        absQ[k] = aq;
        /* Approximate magnitude without floating point: sqrt(i*i + q*q). */
        (void)absI;
        (void)absQ;
        long ii = (long)i;
        long qq = (long)q;
        long r2 = ii * ii + qq * qq;
        int r = (int)lrint(sqrt((double)r2));
        magR[k] = r;
    }
    /* Compute 99th percentile radius via quickselect (avoid full sort) */
    /* Use 99th percentile (index ~ 0.99*(n-1)) to ignore rare spikes */
    int idxP = (int)lrint(0.99 * (double)(n - 1));
    if (idxP < 0) {
        idxP = 0;
    }
    if (idxP >= n) {
        idxP = n - 1;
    }
    int pR = select_k_int_local(magR, n, idxP);
    /* Avoid zooming into noise; also keep a sane lower bound */
    if (pR < 64) {
        pR = 64;
    }
    /* EMA smoothing (alpha ~0.2) */
    s_maxR = (int)(0.8 * (double)s_maxR + 0.2 * (double)pR);
    if (s_maxR < 64) {
        s_maxR = 64;
    }

    /* Magnitude gate to reduce near-origin clutter */
    double gate = 0.10;
    if (opts) {
        gate = (opts->mod_qpsk == 1) ? (double)opts->const_gate_qpsk : (double)opts->const_gate_other;
        if (gate < 0.0) {
            gate = 0.0;
        }
        if (gate > 0.90) {
            gate = 0.90;
        }
    }
    const double gate2 = gate * gate;

    /* Accumulate density */
    int cx = W / 2, cy = H / 2;
    /* Use equal scale on both axes so circles stay round on wide terminals. */
    int halfX = (W / 2) - 1;
    int halfY = (H / 2) - 1;
    if (halfX < 1) {
        halfX = 1;
    }
    if (halfY < 1) {
        halfY = 1;
    }
    int scale_eq = (halfX < halfY) ? halfX : halfY;
    /* Terminal cell aspect compensation: rows are visually taller than columns.
       Compress vertical mapping to counteract oval appearance (empirical factor). */
    const double y_aspect = 0.55; /* 0.5–0.6 typical; adjust if needed */
    /* Add a small headroom margin so dense clusters don't pin to the border */
    const double outer_margin = 0.92; /* 92% of the square radius */
    /* Define a centered square plotting region so each quadrant is square in rows/cols */
    int x0 = cx - scale_eq;
    int x1 = cx + scale_eq;
    int y0 = cy - scale_eq;
    int y1 = cy + scale_eq;
    unsigned short dmax = 0;
    for (int k = 0; k < n; k++) {
        int i = buf[(size_t)(k << 1) + 0];
        int q = buf[(size_t)(k << 1) + 1];
        /* Compute raw magnitude for gating and optional unit-circle normalization */
        double ii = (double)i;
        double qq = (double)q;
        double r = sqrt(ii * ii + qq * qq);
        double rn = r / (double)s_maxR; /* normalized radius for gating */
        if ((rn * rn) < gate2) {
            continue;
        }
        double nx, ny;
        if (opts && opts->const_norm_mode == 1) {
            /* Unit-circle normalization (direction only) */
            if (r <= 1e-9) {
                continue; /* skip degenerate */
            }
            nx = ii / r;
            ny = qq / r;
        } else {
            /* Radial (percentile) normalization */
            nx = ii / (double)s_maxR;
            ny = qq / (double)s_maxR;
        }
        int x = cx + (int)lrint(nx * (double)scale_eq * outer_margin);
        int y = cy - (int)lrint(ny * (double)scale_eq * outer_margin * y_aspect);
        if (x < 0) {
            x = 0;
        }
        if (x >= W) {
            x = W - 1;
        }
        if (y < 0) {
            y = 0;
        }
        if (y >= H) {
            y = H - 1;
        }
        unsigned short* cell = &den[(size_t)y * (size_t)W + (size_t)x];
        if (*cell != 0xFFFF) {
            (*cell)++;
            if (*cell > dmax) {
                dmax = *cell;
            }
        }
    }
    if (dmax == 0) {
        dmax = 1; /* avoid div-by-zero */
    }

    /* Render with overlays and optional color (trim to active density vertically) */
    /* Find first/last rows within [y0,y1] that contain any density. */
    int y_start = y0;
    int y_end = y1;
    if (y_start < 0) {
        y_start = 0;
    }
    if (y_end >= H) {
        y_end = H - 1;
    }
    int y_top = -1, y_bot = -1;
    for (int y = y_start; y <= y_end; y++) {
        int has = 0;
        for (int x = x0; x <= x1; x++) {
            if (x >= 0 && x < W) {
                if (den[(size_t)y * (size_t)W + (size_t)x] > 0) {
                    has = 1;
                    break;
                }
            }
        }
        if (has) {
            y_top = y;
            break;
        }
    }
    for (int y = y_end; y >= y_start; y--) {
        int has = 0;
        for (int x = x0; x <= x1; x++) {
            if (x >= 0 && x < W) {
                if (den[(size_t)y * (size_t)W + (size_t)x] > 0) {
                    has = 1;
                    break;
                }
            }
        }
        if (has) {
            y_bot = y;
            break;
        }
    }
    if (y_top >= 0 && y_bot >= y_top) {
        y_start = y_top;
        y_end = y_bot;
    }
    for (int y = y_start; y <= y_end; y++) {
        ui_print_lborder();
        int last_pair = -1;
        for (int x = 0; x < W; x++) {
            /* Determine overlays (restricted to the centered square region) */
            int inside_sq = (x >= x0 && x <= x1 && y >= y0 && y <= y1);
            int is_haxis = inside_sq && (y == cy);
            int is_vaxis = inside_sq && (x == cx);
            int is_diag = 0;
            if (inside_sq && opts && (opts->mod_qpsk == 1)) {
                /* Adjust diagonals to preserve ~45° visually under aspect correction */
                int dx = x - cx;
                int y_d1 = cy + (int)lrint((double)dx * y_aspect);
                int y_d2 = cy - (int)lrint((double)dx * y_aspect);
                is_diag = (y == y_d1) || (y == y_d2);
            }

            unsigned short d = den[(size_t)y * (size_t)W + (size_t)x];
            char ch = ' ';
            int used_guide = 0;

            if (is_haxis || is_vaxis || is_diag) {
                /* Choose overlay char */
                if ((is_haxis && is_vaxis) || (is_vaxis && is_diag) || (is_haxis && is_diag)) {
                    ch = '+';
                } else if (is_haxis) {
                    ch = '-';
                } else if (is_vaxis) {
                    ch = '|';
                } else {
                    ch = (x >= cx) ? '\\' : '/';
                }
                if (opts && opts->eye_color && has_colors()) {
                    short gp = is_diag ? guide_x_pair : (is_haxis ? guide_h_pair : guide_v_pair);
                    if (last_pair >= 0) {
                        attroff(COLOR_PAIR(last_pair));
                        last_pair = -1;
                    }
                    attron(COLOR_PAIR(gp));
                    used_guide = gp;
                }
            } else if (inside_sq && d > 0) {
                /* Density glyph + color */
                double f = (double)d / (double)dmax;
                if (f < 0.0) {
                    f = 0.0;
                }
                if (f > 1.0) {
                    f = 1.0;
                }
                double g = gamma_map01(f); /* gamma brighten via LUT */
                if (opts && opts->eye_color && has_colors()) {
                    int ci = (int)lrint(g * (double)(color_len - 1));
                    if (ci < 0) {
                        ci = 0;
                    }
                    if (ci >= color_len) {
                        ci = color_len - 1;
                    }
                    int pid = color_base + ci;
                    if (pid != last_pair) {
                        if (last_pair >= 0) {
                            attroff(COLOR_PAIR(last_pair));
                        }
                        attron(COLOR_PAIR(pid));
                        last_pair = pid;
                    }
                }
                if (use_unicode) {
                    if (use_dots) {
                        int idx = (int)lrint(g * (double)(dot_len - 1));
                        if (idx < 0) {
                            idx = 0;
                        }
                        if (idx >= dot_len) {
                            idx = dot_len - 1;
                        }
                        ch = 0; /* mark to addstr */
                        addstr(dot_palette[idx]);
                    } else {
                        int idx = (int)lrint(g * (double)(block_len - 1));
                        if (idx < 0) {
                            idx = 0;
                        }
                        if (idx >= block_len) {
                            idx = block_len - 1;
                        }
                        ch = 0; /* mark to addstr */
                        addstr(block_palette[idx]);
                    }
                } else {
                    int idx = (int)lrint(g * (double)(ascii_len - 1));
                    if (idx < 0) {
                        idx = 0;
                    }
                    if (idx >= ascii_len) {
                        idx = ascii_len - 1;
                    }
                    ch = ascii_palette[idx];
                }
            }

            /* Reference cluster centers + quadrant labels (QPSK only) */
            if (inside_sq && opts && (opts->mod_qpsk == 1)) {
                /* Reference points near ~70% radius (independent of mode) */
                double refR = 0.70 * (double)s_maxR;
                int ref_ix[4] = {+1, -1, -1, +1};
                int ref_qx[4] = {+1, +1, -1, -1};
                for (int r = 0; r < 4; r++) {
                    double rii = ref_ix[r] * refR;
                    double rqq = ref_qx[r] * refR;
                    double rx = (rii / (double)s_maxR);
                    double ry = (rqq / (double)s_maxR);
                    int xr = cx + (int)lrint(rx * (double)scale_eq * outer_margin);
                    int yr = cy - (int)lrint(ry * (double)scale_eq * outer_margin * y_aspect);
                    if (xr == x && yr == y) {
                        ch = 'o';
                        if (opts->eye_color && has_colors()) {
                            if (last_pair >= 0) {
                                attroff(COLOR_PAIR(last_pair));
                                last_pair = -1;
                            }
                            attron(COLOR_PAIR(guide_x_pair));
                            used_guide = guide_x_pair;
                        }
                    }
                }
                /* Quadrant labels */
                int qdx = (W / 4);
                int qdy = (H / 4);
                if (y == cy - qdy && x == cx + qdx) {
                    ch = '1';
                } else if (y == cy - qdy && x == cx - qdx) {
                    ch = '2';
                } else if (y == cy + qdy && x == cx - qdx) {
                    ch = '3';
                } else if (y == cy + qdy && x == cx + qdx) {
                    ch = '4';
                }
            }

            if (ch != 0) {
                addch(ch);
            }
            if (used_guide) {
                attroff(COLOR_PAIR(used_guide));
                /* Restore density color if active */
                if (opts && opts->eye_color && has_colors()) {
                    /* Recompute density pair for this cell */
                    if (d > 0) {
                        double f = (double)d / (double)dmax;
                        if (f < 0.0) {
                            f = 0.0;
                        }
                        if (f > 1.0) {
                            f = 1.0;
                        }
                        double g = gamma_map01(f);
                        int ci = (int)lrint(g * (double)(color_len - 1));
                        if (ci < 0) {
                            ci = 0;
                        }
                        if (ci >= color_len) {
                            ci = color_len - 1;
                        }
                        int pid = color_base + ci;
                        attron(COLOR_PAIR(pid));
                        last_pair = pid;
                    }
                }
            }
        }
        if (opts && opts->eye_color && has_colors()) {
            if (last_pair >= 0) {
                attroff(COLOR_PAIR(last_pair));
            }
        }
        printw("\n");
    }

    /* Legend */
    ui_print_lborder();
    printw(" Ref: axes '+', '/'\\'\\' slicer; 'o' cluster refs\n");
    if (use_unicode) {
        if (use_dots) {
            ui_print_lborder();
            printw(" Density: · • ● ⬤  (low -> high)%s\n",
                   (opts && opts->eye_color && has_colors()) ? "; colored" : "");
        } else {
            ui_print_lborder();
            printw(" Density: ▁ ▂ ▃ ▄ ▅ ▆ ▇ █  (low -> high)%s\n",
                   (opts && opts->eye_color && has_colors()) ? "; colored" : "");
        }
    } else {
        ui_print_lborder();
        printw(" Density: . : - = + * # @  (low -> high)%s\n",
               (opts && opts->eye_color && has_colors()) ? "; colored" : "");
    }
    /* Color bar legend (consistent with Eye Diagram) */
    ui_print_lborder();
    printw(" Norm: %s (toggle with 'n')\n", (opts && opts->const_norm_mode) ? "unit-circle" : "radial (p99)");
    if (opts && opts->eye_color && has_colors()) {
        ui_print_lborder();
        addch('\n');
        ui_print_lborder();
        printw(" Color:   ");
        for (int i = 0; i < color_len; i++) {
            attron(COLOR_PAIR((short)(color_base + i)));
            if (use_unicode) {
                addstr("██");
            } else {
                addstr("##");
            }
            attroff(COLOR_PAIR((short)(color_base + i)));
        }
        printw("  low -> high\n");
        ui_print_lborder();
        printw("          ");
        int barw = color_len * 2;
        for (int x = 0; x < barw; x++) {
            if (x == 0 || x == barw / 2 || x == barw - 1) {
                addch('|');
            } else {
                addch(' ');
            }
        }
        printw("\n");
        ui_print_lborder();
        printw("          0%%");
        int pad_mid = barw / 2 - 2;
        for (int i = 0; i < pad_mid; i++) {
            addch(' ');
        }
        printw("50%%");
        int pad_end = barw - (barw / 2 + 2) - 4;
        for (int i = 0; i < pad_end; i++) {
            addch(' ');
        }
        printw("100%%\n");
    }
    attron(COLOR_PAIR(4));
    attron(COLOR_PAIR(4));
    ui_print_hr();
    attroff(COLOR_PAIR(4));
    attroff(COLOR_PAIR(4));
    /* s_den reused; no free */
#else
    ui_print_header("Constellation");
    printw("| (RTL disabled in this build)\n");
    ui_print_hr();
#endif
}

/* Forward decl for int comparator used in eye/hist quartile computation */
static int cmp_int_asc(const void* a, const void* b);

static void
print_eye_view(dsd_opts* opts, dsd_state* state) {
#ifdef USE_RTLSDR
    /* Fetch a snapshot of recent I-channel samples and SPS */
    enum { MAXS = 16384 };

    static int16_t buf[(size_t)MAXS];
    int sps = 0;
    int n = rtl_stream_eye_get(buf, MAXS, &sps);
    ui_print_header("Eye Diagram (C4FM/FSK)");
    /* Auto-fallback to ASCII if Unicode likely unsupported */
    static int s_unicode_ready = -1;
    static int s_unicode_warned = 0;
    if (s_unicode_ready < 0) {
        int ok = 0;
        if (MB_CUR_MAX > 1) {
            ok = 1; /* basic check: multibyte locale active */
        }
        s_unicode_ready = ok;
    }
    if (opts->eye_unicode && !s_unicode_ready) {
        opts->eye_unicode = 0;
        if (!s_unicode_warned) {
            printw("| (Unicode block glyphs unsupported; falling back to ASCII)\n");
            s_unicode_warned = 1;
        }
    }
    if (n <= 0 || sps <= 0) {
        ui_print_lborder();
        printw(" (no samples or SPS)\n");
        attron(COLOR_PAIR(4));
        ui_print_hr();
        attroff(COLOR_PAIR(4));
        return;
    }
    /* Grid size adaptive */
    int rows = 24, cols = 80;
    getmaxyx(stdscr, rows, cols);
    int W = cols - 4;
    if (W < 32) {
        W = 32;
    }
    int H = rows / 3;
    if (H < 12) {
        H = 12;
    }
    /* Density buffer sized to current grid (reuse across frames) */
    size_t den_sz = (size_t)H * (size_t)W;
    static unsigned short* s_den_eye = NULL;
    static size_t s_den_eye_cap = 0;
    if (s_den_eye_cap < den_sz) {
        void* nb = realloc(s_den_eye, den_sz * sizeof(unsigned short));
        if (!nb) {
            free(s_den_eye);
            s_den_eye = NULL;
            s_den_eye_cap = 0;
            printw("| (eye: out of memory)\n");
            ui_print_hr();
            return;
        }
        s_den_eye = (unsigned short*)nb;
        s_den_eye_cap = den_sz;
    }
    unsigned short* den = s_den_eye;
    if (den_sz > 0 && den != NULL) {
        memset(den, 0, den_sz * sizeof(unsigned short));
    }
    if (den == NULL) {
        return;
    }
    int mid = H / 2;
    /* Normalize peak with EMA for stability */
    static int s_peak = 256;
    int peak = 1;
    for (int i = 0; i < n; i++) {
        int v = buf[i];
        int a = v < 0 ? -v : v;
        if (a > peak) {
            peak = a;
        }
    }
    if (peak < 64) {
        peak = 64;
    }
    s_peak = (int)(0.8 * (double)s_peak + 0.2 * (double)peak);
    if (s_peak < 64) {
        s_peak = 64;
    }
    /* Build quartiles for reference levels */
    int step_ds = (n > 8192) ? (n / 8192) : 1;
    int m = (n + step_ds - 1) / step_ds;
    if (m > 8192) {
        m = 8192;
    }
    static int qvals[8192];
    int vi = 0;
    for (int i = 0; i < n && vi < m; i += step_ds) {
        qvals[vi++] = (int)buf[i];
    }
    m = vi;
    if (m < 8) {
        qvals[0] = -s_peak;
        qvals[1] = s_peak;
        m = 2;
    }
    /* Quartiles via quickselect */
    int idx1 = (int)((size_t)m / 4);
    int idx2 = (int)((size_t)m / 2);
    int idx3 = (int)((size_t)(3 * (size_t)m) / 4);
    int q2 = select_k_int_local(qvals, m, idx2);
    int q1 = select_k_int_local(qvals, idx2, idx1); /* select within lower half */
    int q3 = select_k_int_local(qvals + idx2 + 1, m - (idx2 + 1), idx3 - (idx2 + 1));
    /* Accumulate density by folding modulo 2 symbols */
    int two_sps = 2 * sps;
    if (two_sps < 8) {
        two_sps = 8;
    }
    for (int i = 0; i < n; i++) {
        double v = (double)buf[i] / (double)s_peak;
        if (v > 1.0) {
            v = 1.0;
        }
        if (v < -1.0) {
            v = -1.0;
        }
        int y = mid - (int)lrint(v * ((double)H / 2.0 - 1.0));
        if (y < 0) {
            y = 0;
        }
        if (y >= H) {
            y = H - 1;
        }
        int phase = i % two_sps;
        int x = (int)lrint(((double)phase / (double)(two_sps - 1)) * (double)(W - 1));
        if (x < 0) {
            x = 0;
        }
        if (x >= W) {
            x = W - 1;
        }
        size_t di = (size_t)y * (size_t)W + (size_t)x;
        if (den[di] < 65535) {
            den[di]++;
        }
    }
    /* Determine max density for mapping */
    unsigned short dmax = 1;
    for (int y = 0; y < H; y++) {
        for (int x = 0; x < W; x++) {
            unsigned short dv = den[(size_t)y * (size_t)W + (size_t)x];
            if (dv > dmax) {
                dmax = dv;
            }
        }
    }
    /* Map density to a higher-contrast palette (ASCII or Unicode) and overlay guides */
    /* ASCII palette (low -> high density) */
    static const char ascii_palette[] = " .:-=+*#%@"; /* 10 levels */
    const int ascii_len = (int)(sizeof(ascii_palette) - 1);
    /* Unicode block palette (UTF-8), width 1 per glyph */
    static const char* uni_palette[] = {" ", "▁", "▂", "▃", "▄", "▅", "▆", "▇", "█"}; /* 9 levels */
    const int uni_len = (int)(sizeof(uni_palette) / sizeof(uni_palette[0]));

    /* Optional color density mapping */
    static int color_inited = 0;
    static const short color_seq[] = {COLOR_BLUE,    COLOR_CYAN, COLOR_GREEN, COLOR_YELLOW,
                                      COLOR_MAGENTA, COLOR_RED,  COLOR_WHITE};
    const int color_len = (int)(sizeof(color_seq) / sizeof(color_seq[0]));
    const short color_base = 21; /* avoid clashing with existing pairs */
    /* Guide color pairs (horizontal, vertical, cross) */
    const short guide_h_pair = (short)(color_base + 8);
    const short guide_v_pair = (short)(color_base + 9);
    const short guide_x_pair = (short)(color_base + 10);
    if (opts->eye_color && has_colors() && !color_inited) {
        for (int i = 0; i < color_len; i++) {
            init_pair((short)(color_base + i), color_seq[i], COLOR_BLACK);
        }
        init_pair(guide_h_pair, COLOR_YELLOW, COLOR_BLACK);
        init_pair(guide_v_pair, COLOR_CYAN, COLOR_BLACK);
        init_pair(guide_x_pair, COLOR_MAGENTA, COLOR_BLACK);
        color_inited = 1;
    }

    /* Compute reference rows for quartiles (approximate C4FM levels) */
    int yq1 = mid - (int)lrint(((double)q1 / (double)s_peak) * ((double)H / 2.0 - 1.0));
    if (yq1 < 0) {
        yq1 = 0;
    }
    if (yq1 >= H) {
        yq1 = H - 1;
    }
    int yq2 = mid - (int)lrint(((double)q2 / (double)s_peak) * ((double)H / 2.0 - 1.0));
    if (yq2 < 0) {
        yq2 = 0;
    }
    if (yq2 >= H) {
        yq2 = H - 1;
    }
    int yq3 = mid - (int)lrint(((double)q3 / (double)s_peak) * ((double)H / 2.0 - 1.0));
    if (yq3 < 0) {
        yq3 = 0;
    }
    if (yq3 >= H) {
        yq3 = H - 1;
    }
    /* Symbol boundary columns (phase 0, 1 symbol, 2 symbols) */
    int xb0 = 0;
    int xb1 = (int)lrint(((double)sps / (double)(two_sps - 1)) * (double)(W - 1));
    if (xb1 < 0) {
        xb1 = 0;
    }
    if (xb1 >= W) {
        xb1 = W - 1;
    }
    int xb2 = W - 1;

    /* Draw with overlays */
    for (int y = 0; y < H; y++) {
        ui_print_lborder();
        int last_pair = -1;
        for (int x = 0; x < W; x++) {
            unsigned short d = den[(size_t)y * (size_t)W + (size_t)x];
            char ch = ' ';
            if (d > 0) {
                /* Gamma to brighten low densities */
                double f = (double)d / (double)dmax;
                if (f < 0.0) {
                    f = 0.0;
                }
                if (f > 1.0) {
                    f = 1.0;
                }
                double g = gamma_map01(f); /* gamma = 0.5 via LUT */
                if (opts->eye_unicode) {
                    int idx = (int)lrint(g * (double)(uni_len - 1));
                    if (idx < 0) {
                        idx = 0;
                    }
                    if (idx >= uni_len) {
                        idx = uni_len - 1;
                    }
                    (void)idx; // reserve for overlays using density index
                    /* Color mapping (based on g) */
                    if (opts->eye_color && has_colors()) {
                        int ci = (int)lrint(g * (double)(color_len - 1));
                        if (ci < 0) {
                            ci = 0;
                        }
                        if (ci >= color_len) {
                            ci = color_len - 1;
                        }
                        int pid = color_base + ci;
                        if (pid != last_pair) {
                            if (last_pair >= 0) {
                                attroff(COLOR_PAIR(last_pair));
                            }
                            attron(COLOR_PAIR(pid));
                            last_pair = pid;
                        }
                    }
                    /* Unicode draw below unless overlays apply */
                    ch = 0; /* marker to indicate we'll addstr() later */
                    /* overlays handled further below */
                    /* store density index in x-local via idx variable */
                    /* reuse idx below if not overridden */
                    /* To keep scope, repeat calculation */
                    ;
                } else {
                    int idx = (int)lrint(g * (double)(ascii_len - 1));
                    if (idx < 0) {
                        idx = 0;
                    }
                    if (idx >= ascii_len) {
                        idx = ascii_len - 1;
                    }
                    if (opts->eye_color && has_colors()) {
                        int ci = (int)lrint(g * (double)(color_len - 1));
                        if (ci < 0) {
                            ci = 0;
                        }
                        if (ci >= color_len) {
                            ci = color_len - 1;
                        }
                        int pid = color_base + ci;
                        if (pid != last_pair) {
                            if (last_pair >= 0) {
                                attroff(COLOR_PAIR(last_pair));
                            }
                            attron(COLOR_PAIR(pid));
                            last_pair = pid;
                        }
                    }
                    ch = ascii_palette[idx];
                }
            }
            /* Determine overlays */
            int is_hline = (y == yq1 || y == yq2 || y == yq3);
            int is_vline = (x == xb0 || x == xb1 || x == xb2);
            int used_guide = 0;
            if (is_hline || is_vline) {
                /* Choose overlay character */
                if (is_hline && is_vline) {
                    ch = '+';
                } else if (is_hline) {
                    ch = (ch == ' ' || ch == '.' || ch == ':') ? '-' : '=';
                } else {
                    ch = (ch == ' ' || ch == '.' || ch == ':' || ch == '-') ? '|' : '+';
                }
                /* Apply guide colors if enabled */
                if (opts->eye_color && has_colors()) {
                    short gp = is_hline && is_vline ? guide_x_pair : (is_hline ? guide_h_pair : guide_v_pair);
                    if (last_pair >= 0) {
                        attroff(COLOR_PAIR(last_pair));
                        last_pair = -1; /* force reapply after */
                    }
                    attron(COLOR_PAIR(gp));
                    used_guide = gp;
                }
            }
            if (opts->eye_unicode && ch == 0 && !used_guide) {
                /* Redetermine density index for unicode and print glyph */
                unsigned short d2 = den[(size_t)y * (size_t)W + (size_t)x];
                double f2 = (double)d2 / (double)dmax;
                if (f2 < 0.0) {
                    f2 = 0.0;
                }
                if (f2 > 1.0) {
                    f2 = 1.0;
                }
                double g2 = gamma_map01(f2);
                int uidx = (int)lrint(g2 * (double)(uni_len - 1));
                if (uidx < 0) {
                    uidx = 0;
                }
                if (uidx >= uni_len) {
                    uidx = uni_len - 1;
                }
                addstr(uni_palette[uidx]);
            } else {
                addch(ch);
            }
            /* If we used guide color, restore previous density color */
            if (used_guide) {
                attroff(COLOR_PAIR(used_guide));
                /* Re-enable density color if was active */
                if (opts->eye_color && has_colors()) {
                    /* recompute f to restore approximate density color */
                    double f = (double)d / (double)dmax;
                    if (f < 0.0) {
                        f = 0.0;
                    }
                    if (f > 1.0) {
                        f = 1.0;
                    }
                    double g = gamma_map01(f);
                    int ci = (int)lrint(g * (double)(color_len - 1));
                    if (ci < 0) {
                        ci = 0;
                    }
                    if (ci >= color_len) {
                        ci = color_len - 1;
                    }
                    int pid = color_base + ci;
                    attron(COLOR_PAIR(pid));
                    last_pair = pid;
                }
            }
        }
        if (opts->eye_color && has_colors()) {
            if (last_pair >= 0) {
                attroff(COLOR_PAIR(last_pair));
            }
        }
        addch('\n');
    }
    /* Legend + reference info */
    ui_print_lborder();
    printw(" Ref: '-' Q1/Q3, '=' median; '|' edges; '+' crossings\n");
    if (opts->eye_unicode) {
        ui_print_lborder();
        printw(" Density: ▁ ▂ ▃ ▄ ▅ ▆ ▇ █  (low -> high)%s\n", (opts->eye_color && has_colors()) ? "; colored" : "");
    } else {
        ui_print_lborder();
        printw(" Density: . : - = + * # @  (low -> high)%s\n", (opts->eye_color && has_colors()) ? "; colored" : "");
    }
    if (opts->eye_color && has_colors()) {
        ui_print_lborder();
        addch('\n');
        /* Show a color bar legend for density mapping */
        ui_print_lborder();
        printw(" Color:   ");
        for (int i = 0; i < color_len; i++) {
            attron(COLOR_PAIR((short)(color_base + i)));
            if (opts->eye_unicode) {
                addstr("██");
            } else {
                addstr("##");
            }
            attroff(COLOR_PAIR((short)(color_base + i)));
        }
        printw("  low -> high\n");
        /* Ticks under the color bar: 0%, 50%, 100% */
        ui_print_lborder();
        printw("          ");
        int barw = color_len * 2;
        for (int x = 0; x < barw; x++) {
            if (x == 0 || x == barw / 2 || x == barw - 1) {
                addch('|');
            } else {
                addch(' ');
            }
        }
        printw("\n");
        ui_print_lborder();
        printw("          0%%");
        int pad_mid = barw / 2 - 2;
        for (int i = 0; i < pad_mid; i++) {
            addch(' ');
        }
        printw("50%%");
        int pad_end = barw - (barw / 2 + 2) - 4;
        for (int i = 0; i < pad_end; i++) {
            addch(' ');
        }
        printw("100%%\n");
    }
    /* Prefer post-filter demod SNR when available (only for confirmed C4FM) */
    double snr_db = -1.0;
    int is_c4fm = (opts->mod_c4fm == 1);
    if (state) {
        is_c4fm = is_c4fm && (state->rf_mod == 0);
    }
#ifdef USE_RTLSDR
    if (is_c4fm) {
        snr_db = rtl_stream_get_snr_c4fm();
    }
#endif
    if (is_c4fm && snr_db < -20.0) {
        /* Fallback: quick estimate using current buffer */
        if (sps > 0 && n > 100) {
            int c1 = sps / 2;
            int c2 = (3 * sps) / 2;
            int win = sps / 10;
            if (win < 1) {
                win = 1;
            }
            long long cnt[4] = {0, 0, 0, 0};
            double sum[4] = {0, 0, 0, 0};
            for (int i = 0; i < n; i++) {
                int phase = i % two_sps;
                int inwin = (abs(phase - c1) <= win) || (abs(phase - c2) <= win);
                if (!inwin) {
                    continue;
                }
                int v = (int)buf[i];
                int b = (v <= q1) ? 0 : (v <= q2) ? 1 : (v <= q3) ? 2 : 3;
                cnt[b]++;
                sum[b] += (double)v;
            }
            double mu[4] = {0, 0, 0, 0};
            long long total = 0;
            for (int b = 0; b < 4; b++) {
                if (cnt[b] > 0) {
                    mu[b] = sum[b] / (double)cnt[b];
                }
                total += cnt[b];
            }
            if (total > 50 && cnt[0] && cnt[1] && cnt[2] && cnt[3]) {
                double nsum = 0.0;
                for (int i = 0; i < n; i++) {
                    int phase = i % two_sps;
                    int inwin = (abs(phase - c1) <= win) || (abs(phase - c2) <= win);
                    if (!inwin) {
                        continue;
                    }
                    int v = (int)buf[i];
                    int b = (v <= q1) ? 0 : (v <= q2) ? 1 : (v <= q3) ? 2 : 3;
                    double e = (double)v - mu[b];
                    nsum += e * e;
                }
                double noise_var = nsum / (double)total;
                double mu_all = 0.0;
                for (int b = 0; b < 4; b++) {
                    mu_all += mu[b] * (double)cnt[b] / (double)total;
                }
                double ssum = 0.0;
                for (int b = 0; b < 4; b++) {
                    double d = mu[b] - mu_all;
                    ssum += (double)cnt[b] * d * d;
                }
                double sig_var = ssum / (double)total;
                if (noise_var > 1e-9 && sig_var > 1e-9) {
                    snr_db = 10.0 * log10(sig_var / noise_var);
                }
            }
        }
    }
    if (is_c4fm && snr_db >= 0.0) {
        ui_print_lborder();
        printw(" Rows: Q1=%d  Median=%d  Q3=%d   SPS=%d  SNR=%.1f dB\n", yq1, yq2, yq3, sps, snr_db);
    } else {
        ui_print_lborder();
        printw(" Rows: Q1=%d  Median=%d  Q3=%d   SPS=%d  SNR=n/a\n", yq1, yq2, yq3, sps);
    }
    attron(COLOR_PAIR(4));
    ui_print_hr();
    attroff(COLOR_PAIR(4));
    /* den buffer reused across frames; do not free here */
#else
    ui_print_header("Eye Diagram");
    printw("| (RTL disabled in this build)\n");
    ui_print_hr();
#endif
}

/* Comparator for ascending sort of int values (used in FSK histogram quartiles) */
static int
cmp_int_asc(const void* a, const void* b) {
    int ia = *(const int*)a;
    int ib = *(const int*)b;
    return (ia > ib) - (ia < ib);
}

static void
print_fsk_hist_view(void) {
#ifdef USE_RTLSDR
    enum { MAXS = 8192 };

    static int16_t buf[(size_t)MAXS];
    int sps = 0;
    int n = rtl_stream_eye_get(buf, MAXS, &sps);
    ui_print_header("FSK 4-Level Histogram");
    if (n <= 0) {
        ui_print_lborder();
        printw(" (no samples)\n");
        attron(COLOR_PAIR(4));
        ui_print_hr();
        attroff(COLOR_PAIR(4));
        return;
    }
    /* Compute peak and mean DC offset */
    int peak = 1;
    int64_t sum = 0;
    for (int i = 0; i < n; i++) {
        int v = (int)buf[i];
        int a = v < 0 ? -v : v;
        if (a > peak) {
            peak = a;
        }
        sum += v;
    }
    if (peak < 64) {
        peak = 64;
    }
    double dc_norm = (double)sum / (double)n / (double)peak; /* ~[-1,1] */

    /* Adaptive quartile thresholds over recent I-channel samples. */
    /* Downsample set for faster sort if needed */
    int step = (n > 4096) ? (n / 4096) : 1;
    int m = (n + step - 1) / step;
    if (m < 8) {
        m = n, step = 1; /* ensure adequate sample count */
    }
    /* Copy sampled values into a temp array for sorting */
    static int vals[8192];
    if (m > 8192) {
        m = 8192;
    }
    int vi = 0;
    for (int i = 0; i < n && vi < m; i += step) {
        vals[vi++] = (int)buf[i];
    }
    m = vi;
    /* Quartiles via quickselect */
    int idx1 = (int)((size_t)m / 4);
    int idx2 = (int)((size_t)m / 2);
    int idx3 = (int)((size_t)(3 * (size_t)m) / 4);
    int q2 = select_k_int_local(vals, m, idx2);
    int q1 = select_k_int_local(vals, idx2, idx1);
    int q3 = select_k_int_local(vals + idx2 + 1, m - (idx2 + 1), idx3 - (idx2 + 1));
    /* Bin using quartile boundaries */
    int64_t bin[4] = {0, 0, 0, 0};
    for (int i = 0; i < n; i++) {
        int v = (int)buf[i];
        int b = 0;
        if (v <= q1) {
            b = 0;
        } else if (v <= q2) {
            b = 1;
        } else if (v <= q3) {
            b = 2;
        } else {
            b = 3;
        }
        bin[b]++;
    }
    /* Draw quartile ruler across value span (min..max) */
    int minv = vals[0];
    int maxv = vals[m - 1];
    if (maxv == minv) {
        maxv = minv + 1; /* avoid div-by-zero */
    }
    const int WR = 60;
    char ruler[(size_t)WR];
    for (int x = 0; x < WR; x++) {
        ruler[x] = '-';
    }
    int p1 = (int)lrint(((double)(q1 - minv) / (double)(maxv - minv)) * (double)(WR - 1));
    int p2 = (int)lrint(((double)(q2 - minv) / (double)(maxv - minv)) * (double)(WR - 1));
    int p3 = (int)lrint(((double)(q3 - minv) / (double)(maxv - minv)) * (double)(WR - 1));
    if (p1 < 0) {
        p1 = 0;
    }
    if (p1 >= WR) {
        p1 = WR - 1;
    }
    if (p2 < 0) {
        p2 = 0;
    }
    if (p2 >= WR) {
        p2 = WR - 1;
    }
    if (p3 < 0) {
        p3 = 0;
    }
    if (p3 >= WR) {
        p3 = WR - 1;
    }
    ruler[p1] = '|';
    ruler[p2] = '+'; /* median */
    ruler[p3] = '|';
    ui_print_lborder();
    printw(" Ruler:  ");
    for (int x = 0; x < WR; x++) {
        addch(ruler[x]);
    }
    printw("  (Q1='|', Median='+', Q3='|')\n");

    /* Draw bars */
    const int W = 60;
    int64_t maxc = 1;
    for (int i = 0; i < 4; i++) {
        if (bin[i] > maxc) {
            maxc = bin[i];
        }
    }
    const char* labels[4] = {"L3(-)", "L1(-)", "L1(+)", "L3(+)"};
    ui_print_lborder();
    printw(" DC Offset: %+0.2f%% of full-scale\n", dc_norm * 100.0);
    for (int i = 0; i < 4; i++) {
        int w = (int)((double)bin[i] / (double)maxc * (double)W + 0.5);
        if (w < 0) {
            w = 0;
        }
        if (w > W) {
            w = W;
        }
        ui_print_lborder();
        printw(" %-6s ", labels[i]);
        for (int x = 0; x < w; x++) {
            addch('#');
        }
        for (int x = w; x < W; x++) {
            addch(' ');
        }
        printw(" %lld\n", (long long)bin[i]);
    }
    attron(COLOR_PAIR(4));
    ui_print_hr();
    attroff(COLOR_PAIR(4));
#else
    ui_print_header("FSK 4-Level Histogram");
    printw("| (RTL disabled in this build)\n");
    ui_print_hr();
#endif
}

static void
print_spectrum_view(dsd_opts* opts) {
#ifdef USE_RTLSDR
    int nfft = rtl_stream_spectrum_get_size();
    if (nfft < 64) {
        nfft = 64;
    }
    if (nfft > 1024) {
        nfft = 1024;
    }
    static float bins_static[1024];
    float* bins = bins_static; /* nfft clamped to <= 1024 above */
    int rate = 0;
    int n = rtl_stream_spectrum_get(bins, nfft, &rate);
    ui_print_header("Spectrum Analyzer");
    if (n <= 0) {
        printw("| (no spectrum yet)\n");
        ui_print_hr();
        return;
    }
    int rows = 24, cols = 80;
    getmaxyx(stdscr, rows, cols);
    int W = cols - 4;
    if (W < 32) {
        W = 32;
    }
    int H = rows / 3;
    if (H < 10) {
        H = 10;
    }
    /* Downsample or upsample bins to match width W */
    static float col[(size_t)2048];
    if (W > (int)(sizeof col / sizeof col[0])) {
        W = (int)(sizeof col / sizeof col[0]);
    }
    if (n >= W) {
        for (int x = 0; x < W; x++) {
            int i0 = (int)((long long)x * n / W);
            int i1 = (int)((long long)(x + 1) * n / W);
            if (i1 <= i0) {
                i1 = i0 + 1;
            }
            if (i1 > n) {
                i1 = n;
            }
            /* Use max within the column to preserve narrow peaks */
            float s = -1e9f;
            for (int i = i0; i < i1; i++) {
                if (bins[i] > s) {
                    s = bins[i];
                }
            }
            col[x] = s;
        }
    } else {
        for (int x = 0; x < W; x++) {
            int src = (int)((long long)x * n / W);
            if (src < 0) {
                src = 0;
            }
            if (src >= n) {
                src = n - 1;
            }
            col[x] = bins[src];
        }
    }
    /* Auto-scale dB floor to 60 dB span around recent max */
    float vmax = -1e9f;
    for (int x = 0; x < W; x++) {
        if (col[x] > vmax) {
            vmax = col[x];
        }
    }
    float vmin = vmax - 60.0f;
    float span = (vmax - vmin);
    if (span < 1.0f) {
        span = 1.0f;
    }

    int use_unicode = (opts && opts->eye_unicode && MB_CUR_MAX > 1);
#ifdef PRETTY_COLORS
    const short C_GOOD = 11, C_MOD = 12, C_POOR = 13;
#endif
    for (int y = 0; y < H; y++) {
        for (int x = 0; x < W; x++) {
            float v = col[x];
            if (v < vmin) {
                v = vmin;
            }
            if (v > vmax) {
                v = vmax;
            }
            float t = (v - vmin) / span; /* 0..1 */
            int h = (int)lrint(t * (H - 1));
            int filled = (H - 1 - y) <= h;
#ifdef PRETTY_COLORS
            /* Color by relative height bands */
            short cp = (t < 0.33f) ? C_POOR : (t < 0.66f) ? C_MOD : C_GOOD;
            if (opts && opts->eye_color && has_colors()) {
                attron(COLOR_PAIR(cp));
            }
#endif
            if (filled) {
                if (use_unicode) {
                    addstr("█");
                } else {
                    addch('#');
                }
            } else {
                addch(' ');
            }
#ifdef PRETTY_COLORS
            if (opts && opts->eye_color && has_colors()) {
                attroff(COLOR_PAIR(cp));
            }
#endif
        }
        addch('\n');
    }
    /* Legend */
    float span_hz = (float)rate;
    int nfft2 = rtl_stream_spectrum_get_size();
    ui_print_lborder();
    printw(" Span: %.1f kHz  \u0394f(FFT): %.1f Hz  \u0394f(col): %.1f Hz  FFT: %d  Glyphs: %s%s\n", span_hz / 1000.0f,
           (rate > 0 && nfft2 > 0) ? (span_hz / (float)nfft2) : 0.0f, (rate > 0 && W > 0) ? (span_hz / (float)W) : 0.0f,
           nfft2, use_unicode ? "Unicode" : "ASCII", (opts && opts->eye_color && has_colors()) ? "; colored" : "");
    /* Frequency ticks around DC */
    ui_print_lborder();
    printw(" Freq: -%.1fk   0   +%.1fk\n", (span_hz * 0.5f) / 1000.0f, (span_hz * 0.5f) / 1000.0f);
    /* Amplitude scale relative to current peak */
    ui_print_lborder();
    printw(" Scale: top=%.1f dB  floor=%.1f dB (relative)\n", vmax, vmin);
#ifdef PRETTY_COLORS
    if (opts && opts->eye_color && has_colors()) {
        printw("| Color:   ");
        attron(COLOR_PAIR(C_POOR));
        if (use_unicode) {
            addstr("██");
        } else {
            addstr("##");
        }
        attroff(COLOR_PAIR(C_POOR));
        printw(" low  ");
        attron(COLOR_PAIR(C_MOD));
        if (use_unicode) {
            addstr("██");
        } else {
            addstr("##");
        }
        attroff(COLOR_PAIR(C_MOD));
        printw(" mid  ");
        attron(COLOR_PAIR(C_GOOD));
        if (use_unicode) {
            addstr("██");
        } else {
            addstr("##");
        }
        attroff(COLOR_PAIR(C_GOOD));
        printw(" high\n");
    }
#endif
    ui_print_hr();
#else
    ui_print_header("Spectrum Analyzer");
    printw("| (RTL disabled in this build)\n");
    ui_print_hr();
#endif
}

static int
compute_p25p1_voice_avg_err(const dsd_state* s, double* out_avg) {
    int len = s->p25_p1_voice_err_hist_len;
    if (len <= 0) {
        return 0;
    }
    double avg = (double)s->p25_p1_voice_err_hist_sum / (double)len;
    if (out_avg) {
        *out_avg = avg;
    }
    return 1;
}

static int
compute_p25p2_voice_avg_err(const dsd_state* s, int slot, double* out_avg) {
    if (slot < 0 || slot > 1) {
        return 0;
    }
    int len = s->p25_p2_voice_err_hist_len;
    if (len <= 0) {
        return 0;
    }
    double avg = (double)s->p25_p2_voice_err_hist_sum[slot] / (double)len;
    if (out_avg) {
        *out_avg = avg;
    }
    return 1;
}

/* Forward decls for helpers used below */
static long int ui_guess_active_vc_freq(const dsd_state* state);

/* Print P25 P1/P2 decoder metrics. Returns number of lines printed. */
/* Small percentile helper for u8 rings (len <= 64) */
static int
compute_percentiles_u8(const uint8_t* src, int len, double* p50, double* p95) {
    if (!src || len <= 0) {
        return 0;
    }
    if (len > 64) {
        len = 64;
    }
    int vals[64];
    for (int i = 0; i < len; i++) {
        vals[i] = (int)src[i];
    }
    qsort(vals, len, sizeof(int), cmp_int_asc);
    int i50 = (int)lrint(0.50 * (double)(len - 1));
    int i95 = (int)lrint(0.95 * (double)(len - 1));
    if (i50 < 0) {
        i50 = 0;
    }
    if (i95 < 0) {
        i95 = 0;
    }
    if (i50 >= len) {
        i50 = len - 1;
    }
    if (i95 >= len) {
        i95 = len - 1;
    }
    if (p50) {
        *p50 = (double)vals[i50];
    }
    if (p95) {
        *p95 = (double)vals[i95];
    }
    return 1;
}

static int
ui_print_p25_metrics(const dsd_opts* opts, const dsd_state* state) {
    /* opts used below for filter status */
    if (!state) {
        return 0;
    }
    int lines = 0;
    int is_p25p1 = (lls == 0 || lls == 1);
    int is_p25p2 = (lls == 35 || lls == 36);

    if (is_p25p1 || is_p25p2) {
        /* Current vs previous sync types (helps spot stuck transitions) */
        int cur = lls;
        int prev = state->lastsynctype;
        const char* cur_s = (cur >= 0 && cur < 44) ? SyncTypes[cur] : "-";
        const char* prev_s = (prev >= 0 && prev < 44) ? SyncTypes[prev] : "-";
        printw("| Sync: cur:%s(%d) prev:%s(%d)\n", cur_s, cur, prev_s, prev);
        lines++;

        /* P25p1 voice error snapshot (IMBE ECC) + moving average */
        double avgv = 0.0;
        if (compute_p25p1_voice_avg_err(state, &avgv)) {
            printw("| P1 Voice: ERR [%X][%X] Avg BER:%4.1f%%\n", state->errs & 0xF, state->errs2 & 0xF, avgv);
        } else {
            printw("| P1: ERR [%X][%X]\n", state->errs & 0xF, state->errs2 & 0xF);
        }
        lines++;

        /* P1 FEC/CRC16 health (TSBK/MDPU headers) */
        unsigned int ok = state->p25_p1_fec_ok;
        unsigned int err = state->p25_p1_fec_err;
        unsigned int tot = ok + err;
        if (tot > 0) {
            double okpct = (100.0 * (double)ok) / (double)tot;
            printw("| P1 FEC: %u/%u (ok:%4.1f%%)\n", ok, err, okpct);
            lines++;
        }

        /* P1 voice error distribution (percentiles) */
        if (state->p25_p1_voice_err_hist_len > 0) {
            double p50 = 0.0, p95 = 0.0;
            int n = state->p25_p1_voice_err_hist_len;
            /* Only the first <len> entries are used by the ring */
            if (compute_percentiles_u8(state->p25_p1_voice_err_hist, n, &p50, &p95)) {
                printw("| P1 Voice: P50/P95: %4.1f/%4.1f%%\n", p50, p95);
                lines++;
            }
        }

        /* P1 C4FM matched filter mode (when cosine filter is enabled), with auto-probe status */
        if (opts) {
            if (opts->use_cosine_filter) {
                if (opts->p25_c4fm_rrc_autoprobe) {
                    if (state->p25_rrc_auto_decided) {
                        printw("| P1 C4FM RRC (auto): %s\n",
                               opts->p25_c4fm_rrc_fixed ? "alpha=0.5 (fixed)" : "alpha≈0.2 (dynamic)");
                    } else if (state->p25_rrc_auto_state != 0) {
                        const char* stage = (state->p25_rrc_auto_state == 1) ? "dynamic" : "fixed";
                        printw("| P1 C4FM RRC (auto): probing %s...\n", stage);
                    } else {
                        printw("| P1 C4FM RRC (auto): waiting for P25p1\n");
                    }
                } else {
                    printw("| P1 C4FM RRC: %s\n",
                           opts->p25_c4fm_rrc_fixed ? "alpha=0.5 (fixed)" : "alpha≈0.2 (dynamic)");
                }
            } else {
                printw("| P1 C4FM RRC: Off\n");
            }
            lines++;
        }
    }

    if (is_p25p2 || (is_p25p1 && opts && opts->p25_trunk == 1)) {
        /* P25p2 voice average BER (per slot) */
        double avgl = 0.0, avgr = 0.0;
        int hasl = compute_p25p2_voice_avg_err(state, 0, &avgl);
        int hasr = compute_p25p2_voice_avg_err(state, 1, &avgr);
        if (hasl || hasr) {
            if (hasl && hasr) {
                printw("| P2 Voice: Avg BER - S1:%4.1f%%, S2:%4.1f%%\n", avgl, avgr);
            } else if (hasl) {
                printw("| P2 Voice: Avg BER - S1:%4.1f%%\n", avgl);
            } else {
                printw("| P2 Voice: Avg BER - S2:%4.1f%%\n", avgr);
            }
            lines++;
        }

        /* P2 voice percentiles (per slot) */
        if (state->p25_p2_voice_err_hist_len > 0) {
            double l50 = 0.0, l95 = 0.0, r50 = 0.0, r95 = 0.0;
            int n = state->p25_p2_voice_err_hist_len;
            int have_any = 0;
            if (compute_percentiles_u8(state->p25_p2_voice_err_hist[0], n, &l50, &l95)) {
                have_any = 1;
            }
            if (compute_percentiles_u8(state->p25_p2_voice_err_hist[1], n, &r50, &r95)) {
                have_any = 1;
            }
            if (have_any) {
                printw("| P2 Voice: P50/P95 - S1:%4.1f/%4.1f%% S2:%4.1f/%4.1f%%\n", l50, l95, r50, r95);
                lines++;
            }
        }

        /* Condensed P25p2 RS summary line (only if any counters are non-zero) */
        if ((state->p25_p2_rs_facch_ok | state->p25_p2_rs_facch_err | state->p25_p2_rs_sacch_ok
             | state->p25_p2_rs_sacch_err | state->p25_p2_rs_ess_ok | state->p25_p2_rs_ess_err)
            != 0) {
            printw("| P2 RS: FACCH %u/%u SACCH %u/%u ESS %u/%u\n", state->p25_p2_rs_facch_ok,
                   state->p25_p2_rs_facch_err, state->p25_p2_rs_sacch_ok, state->p25_p2_rs_sacch_err,
                   state->p25_p2_rs_ess_ok, state->p25_p2_rs_ess_err);
            lines++;

            /* Average corrections per accepted block (gives quality beyond pass/fail) */
            if (state->p25_p2_rs_facch_ok || state->p25_p2_rs_sacch_ok || state->p25_p2_rs_ess_ok) {
                double fac = 0.0, sac = 0.0, ess = 0.0;
                if (state->p25_p2_rs_facch_ok) {
                    fac = (double)state->p25_p2_rs_facch_corr / (double)state->p25_p2_rs_facch_ok;
                }
                if (state->p25_p2_rs_sacch_ok) {
                    sac = (double)state->p25_p2_rs_sacch_corr / (double)state->p25_p2_rs_sacch_ok;
                }
                if (state->p25_p2_rs_ess_ok) {
                    ess = (double)state->p25_p2_rs_ess_corr / (double)state->p25_p2_rs_ess_ok;
                }
                printw("| P2 RS avg corr: FACCH %4.1f SACCH %4.1f ESS %4.1f\n", fac, sac, ess);
                lines++;
            }
        }
    }

    /* Trunking state-machine counters and IDEN trust summary (trunking only) */
    if (opts && opts->p25_trunk == 1) {
        /* SM counters */
        printw("| SM: tunes %u rel %u/%u; CC cands add:%u used:%u count:%d\n", state->p25_sm_tune_count,
               state->p25_sm_release_count, state->p25_sm_cc_return_count, state->p25_cc_cand_added,
               state->p25_cc_cand_used, state->p25_cc_cand_count);
        lines++;

        /* CC/VC frequency snapshot (best-effort) */
        long cc = (state->trunk_cc_freq != 0) ? state->trunk_cc_freq : state->p25_cc_freq;
        long vc = ui_guess_active_vc_freq(state);
        char cc_buf[48];
        char vc_buf[48];
        if (cc != 0) {
            snprintf(cc_buf, sizeof cc_buf, "%.6lf MHz", (double)cc / 1000000.0);
        } else {
            snprintf(cc_buf, sizeof cc_buf, "-");
        }
        if (vc != 0) {
            snprintf(vc_buf, sizeof vc_buf, "%.6lf MHz", (double)vc / 1000000.0);
        } else {
            snprintf(vc_buf, sizeof vc_buf, "-");
        }
        printw("| CC/VC: CC:%s VC:%s\n", cc_buf, vc_buf);
        lines++;

        /* Time since last SM release (if any) */
        if (state->p25_sm_last_release_time != 0) {
            time_t now = time(NULL);
            double dt_rel = (double)(now - state->p25_sm_last_release_time);
            printw("| SM Last: release d=%4.1fs\n", dt_rel);
            lines++;
        }

        /* Last SM reason/tag (from SM internal status logs) */
        if (state->p25_sm_last_reason[0] != '\0' && state->p25_sm_last_reason_time != 0) {
            time_t now = time(NULL);
            double dt_tag = (double)(now - state->p25_sm_last_reason_time);
            printw("| SM Last: %s d=%4.1fs\n", state->p25_sm_last_reason, dt_tag);
            lines++;
        }

        /* Recent SM tags (up to 3 most recent) */
        if (state->p25_sm_tag_count > 0) {
            time_t now = time(NULL);
            ui_print_lborder_green();
            addstr(" SM Tags: ");
            int shown = 0;
            for (int k = 0; k < state->p25_sm_tag_count && k < 3; k++) {
                int idx = (state->p25_sm_tag_head - 1 - k) % 8;
                if (idx < 0) {
                    idx += 8;
                }
                const char* t = state->p25_sm_tags[idx];
                double dt = (double)(now - state->p25_sm_tag_time[idx]);
                if (shown > 0) {
                    addstr(" | ");
                }
                printw("%s(%0.1fs)", t[0] ? t : "-", dt);
                shown++;
            }
            addch('\n');
            lines++;
        }

        /* SM Path: compress recent tags into coarse transitions (oldest→newest) */
        if (state->p25_sm_tag_count > 0) {
            char path[64] = {0};
            int n = state->p25_sm_tag_count;
            if (n > 6) {
                n = 6;
            }
            int wrote = 0;
            for (int k = n - 1; k >= 0; k--) {
                int idx = (state->p25_sm_tag_head - 1 - k) % 8;
                if (idx < 0) {
                    idx += 8;
                }
                const char* t = state->p25_sm_tags[idx];
                char sym = 0;
                if (strstr(t, "after-tune") != NULL) {
                    sym = 'V';
                } else if (strstr(t, "after-release") != NULL) {
                    sym = 'R';
                } else if (strstr(t, "release-") != NULL) {
                    sym = 'H'; /* hold/delayed/gated */
                } else if (strstr(t, "after-neigh") != NULL) {
                    sym = 'N';
                } else if (strstr(t, "tick") != NULL) {
                    sym = 'T';
                } else {
                    sym = '?';
                }
                int m = (int)strlen(path);
                if (m + 3 < (int)sizeof(path)) {
                    if (wrote > 0) {
                        path[m++] = '\xE2'; /* UTF-8 right arrow '→' */
                        path[m++] = '\x86';
                        path[m++] = '\x92';
                    }
                    path[m++] = sym;
                    path[m] = '\0';
                    wrote++;
                }
            }
            ui_print_lborder_green();
            addstr(" SM Path: ");
            addstr(path[0] ? path : "-");
            addch('\n');
            lines++;
        }

        /* IDEN trust summary */
        int iden_total = 0, iden_conf = 0;
        for (int i = 0; i < 16; i++) {
            uint8_t t = state->p25_iden_trust[i];
            if (t > 0) {
                iden_total++;
                if (t >= 2) {
                    iden_conf++;
                }
            }
        }
        if (iden_total > 0) {
            printw("| IDENs: %d total (%d confirmed)\n", iden_total, iden_conf);
            lines++;
        }

        /* CC mode hint (TDMA vs FDMA) */
        if (state->p25_cc_freq != 0 || state->trunk_cc_freq != 0) {
            printw("| CC: %s\n", state->p25_cc_is_tdma ? "TDMA" : "FDMA");
            lines++;
        }
    }

    /* P2 slot and jitter ring status (when on a P2 channel) */
    if (is_p25p2) {
        int act = state->p25_p2_active_slot;
        int lfill = state->p25_p2_audio_ring_count[0];
        int rfill = state->p25_p2_audio_ring_count[1];
        if (lfill < 0) {
            lfill = 0;
        }
        if (lfill > 3) {
            lfill = 3;
        }
        if (rfill < 0) {
            rfill = 0;
        }
        if (rfill > 3) {
            rfill = 3;
        }
        printw("| P2 slot: %s; jitter S1:%d/3 S2:%d/3\n", (act == 0) ? "1" : (act == 1) ? "2" : "-", lfill, rfill);
        lines++;

        // SM Gate introspection: show the conditions that can hold release
        // Left/right: audio_allowed, ring_count, delta since last MAC_ACTIVE,
        // and the computed active flags used by the trunk SM tick logic.
        time_t now = time(NULL);
        double l_dmac =
            (state->p25_p2_last_mac_active[0] != 0) ? (double)(now - state->p25_p2_last_mac_active[0]) : -1.0;
        double r_dmac =
            (state->p25_p2_last_mac_active[1] != 0) ? (double)(now - state->p25_p2_last_mac_active[1]) : -1.0;
        double dt = (state->last_vc_sync_time != 0) ? (double)(now - state->last_vc_sync_time) : -1.0;
        double dt_tune = (state->p25_last_vc_tune_time != 0) ? (double)(now - state->p25_last_vc_tune_time) : -1.0;
        // Compute the same per-slot activity booleans as in the SM tick
        double ring_hold = 0.75; // seconds; DSD_NEO_P25_RING_HOLD
        {
            const char* s = getenv("DSD_NEO_P25_RING_HOLD");
            if (s && s[0] != '\0') {
                double v = atof(s);
                if (v >= 0.0 && v <= 5.0) {
                    ring_hold = v;
                }
            }
        }
        double mac_hold = 3.0; // seconds; DSD_NEO_P25_MAC_HOLD
        {
            const char* s = getenv("DSD_NEO_P25_MAC_HOLD");
            if (s && s[0] != '\0') {
                double v = atof(s);
                if (v >= 0.0 && v < 10.0) {
                    mac_hold = v;
                }
            }
        }
        // After hangtime, ignore stale audio_allowed alone; require ring gated by MAC recency
        int l_ring = (state->p25_p2_audio_ring_count[0] > 0) && (l_dmac >= 0.0) && (l_dmac <= ring_hold);
        int r_ring = (state->p25_p2_audio_ring_count[1] > 0) && (r_dmac >= 0.0) && (r_dmac <= ring_hold);
        int l_has = state->p25_p2_audio_allowed[0] || l_ring;
        int r_has = state->p25_p2_audio_allowed[1] || r_ring;
        if (opts && dt >= opts->trunk_hangtime) {
            l_has = l_ring;
            r_has = r_ring;
        }
        int l_act = l_has;
        int r_act = r_has;
        if (l_dmac >= 0.0 && l_dmac <= mac_hold) {
            l_act = 1;
        }
        if (r_dmac >= 0.0 && r_dmac <= mac_hold) {
            r_act = 1;
        }
        printw("| SM Gate: L[a=%d rc=%d dMAC=%4.1fs act=%d]  R[a=%d rc=%d dMAC=%4.1fs act=%d]  dt=%4.1fs tune=%4.1fs\n",
               state->p25_p2_audio_allowed[0] ? 1 : 0, state->p25_p2_audio_ring_count[0], l_dmac, l_act,
               state->p25_p2_audio_allowed[1] ? 1 : 0, state->p25_p2_audio_ring_count[1], r_dmac, r_act, dt, dt_tune);
        lines++;

        // Minimal SM configuration (hang/grace/dwell/voice-wait/backoff) to aid tuning
        {
            dsd_p25p2_min_sm* msm = dsd_p25p2_min_get();
            if (msm) {
                printw("| minSM: hang:%.1fs grace:%.1fs dwell:%.1fs vwait:%.1fs backoff:%.1fs\n", msm->hangtime_s,
                       msm->vc_grace_s, msm->min_follow_dwell_s, msm->grant_voice_timeout_s, msm->retune_backoff_s);
                lines++;
            }
        }
    }

    /* Additional Phase 1 state-machine diagnostics (timers/flags) */
    if (is_p25p1 && opts && opts->p25_trunk == 1) {
        time_t now = time(NULL);
        double dt_cc = (state->last_cc_sync_time != 0) ? (double)(now - state->last_cc_sync_time) : -1.0;
        double dt_vc = (state->last_vc_sync_time != 0) ? (double)(now - state->last_vc_sync_time) : -1.0;
        double dt_tune = (state->p25_last_vc_tune_time != 0) ? (double)(now - state->p25_last_vc_tune_time) : -1.0;
        double tdu_age = (state->p25_p1_last_tdu != 0) ? (double)(now - state->p25_p1_last_tdu) : -1.0;
        printw("| SM Timers: dCC=%4.1fs dVC=%4.1fs dTune=%4.1fs TDU_age=%4.1fs\n", dt_cc, dt_vc, dt_tune, tdu_age);
        lines++;

        // Show lightweight flags/policy that affect tune/release behavior
        int tuned = (opts->p25_is_tuned == 1 || opts->trunk_is_tuned == 1) ? 1 : 0;
        int tick = p25_sm_in_tick();
        unsigned int hold = state->tg_hold;
        printw("| SM Flags: tuned:%d force_rel:%d tick:%d hold:%s\n", tuned, state->p25_sm_force_release ? 1 : 0, tick,
               (hold != 0) ? "on" : "-");
        lines++;

        // Compact policy summary for quick sanity checks
        const char* pol_data = (opts->trunk_tune_data_calls == 1) ? "on" : "off";
        const char* pol_priv = (opts->trunk_tune_private_calls == 1) ? "on" : "off";
        const char* pol_enc = (opts->trunk_tune_enc_calls == 1) ? "follow" : "lockout";
        printw("| Policy: data:%s priv:%s enc:%s hang:%.1fs\n", pol_data, pol_priv, pol_enc, opts->trunk_hangtime);
        lines++;
    }

    /* P1 DUID histogram (since last reset/tune) */
    unsigned int du_sum = state->p25_p1_duid_hdu + state->p25_p1_duid_ldu1 + state->p25_p1_duid_ldu2
                          + state->p25_p1_duid_tdu + state->p25_p1_duid_tdulc + state->p25_p1_duid_tsbk
                          + state->p25_p1_duid_mpdu;
    if (du_sum > 0) {
        printw("| P1 DUID: HDU %u LDU1 %u LDU2 %u TDU %u TDULC %u TSBK %u MPDU %u\n", state->p25_p1_duid_hdu,
               state->p25_p1_duid_ldu1, state->p25_p1_duid_ldu2, state->p25_p1_duid_tdu, state->p25_p1_duid_tdulc,
               state->p25_p1_duid_tsbk, state->p25_p1_duid_mpdu);
        lines++;
    }

    return lines;
}

// Print P25 CC candidate list (simple wrapped columns)
static void
ui_print_p25_cc_candidates(const dsd_opts* opts, const dsd_state* state) {
    if (!opts || !state) {
        return;
    }
    if (opts->p25_trunk != 1) {
        return;
    }
    if (state->p25_cc_cand_count <= 0) {
        ui_print_lborder_green();
        addstr(" (none)\n");
        return;
    }
    int rows = 0, cols = 80;
    getmaxyx(stdscr, rows, cols);
    if (cols < 1 || rows < 1) {
        cols = 80;
    }
    int shown = 0;
    int line_used = 0;
    for (int i = 0; i < state->p25_cc_cand_count; i++) {
        long f = state->p25_cc_candidates[i];
        if (f == 0) {
            continue;
        }
        char buf[64];
        int is_next = (state->p25_cc_cand_count > 0) ? (i == (state->p25_cc_cand_idx % state->p25_cc_cand_count)) : 0;
        int m = snprintf(buf, sizeof buf, "%c%.6lf MHz", is_next ? '>' : ' ', (double)f / 1000000.0);
        if (m < 0) {
            m = 0;
        }
        int sep = (line_used == 0) ? 0 : 4;
        int left_border = (line_used == 0) ? 2 : 0;
        if ((left_border + line_used + sep + m) > cols) {
            if (line_used > 0) {
                addch('\n');
            }
            line_used = 0;
        }
        if (line_used == 0) {
            ui_print_lborder_green();
            addch(' ');
        } else {
            addstr("    ");
        }
        addnstr(buf, m);
        line_used += ((line_used == 0) ? 0 : sep) + m;
        shown++;
    }
    if (shown > 0 && line_used > 0) {
        addch('\n');
    }
}

// Print recently seen neighbor/control frequencies (age descending)
static void
ui_print_p25_neighbors(const dsd_opts* opts, const dsd_state* state) {
    if (!opts || !state) {
        return;
    }
    if (state->p25_nb_count <= 0) {
        ui_print_lborder_green();
        addstr(" (none)\n");
        return;
    }
    // Build index list and sort by last_seen desc (selection sort; small n)
    int idxs[32];
    int n = 0;
    for (int i = 0; i < state->p25_nb_count && i < 32; i++) {
        if (state->p25_nb_freq[i] != 0) {
            idxs[n++] = i;
        }
    }
    for (int i = 0; i < n; i++) {
        int best = i;
        for (int j = i + 1; j < n; j++) {
            if (state->p25_nb_last_seen[idxs[j]] > state->p25_nb_last_seen[idxs[best]]) {
                best = j;
            }
        }
        if (best != i) {
            int tmp = idxs[i];
            idxs[i] = idxs[best];
            idxs[best] = tmp;
        }
    }
    int rows = 0, cols = 80;
    getmaxyx(stdscr, rows, cols);
    if (cols < 1 || rows < 1) {
        cols = 80;
    }
    int shown = 0;
    int line_used = 0;
    time_t now = time(NULL);
    for (int i = 0; i < n && shown < 20; i++) {
        int k = idxs[i];
        long f = state->p25_nb_freq[k];
        long age = (long)((state->p25_nb_last_seen[k] != 0) ? (now - state->p25_nb_last_seen[k]) : 0);
        if (age < 0) {
            age = 0;
        }
        int is_cc = (f == state->p25_cc_freq);
        int in_cands = 0;
        for (int c = 0; c < state->p25_cc_cand_count; c++) {
            if (state->p25_cc_candidates[c] == f) {
                in_cands = 1;
                break;
            }
        }
        char buf[80];
        int m = snprintf(buf, sizeof buf, "%.6lf MHz%s%s age:%lds", (double)f / 1000000.0, is_cc ? " [CC]" : "",
                         in_cands ? " [C]" : "", age);
        if (m < 0) {
            m = 0;
        }
        int sep = (line_used == 0) ? 0 : 4;
        int left_border = (line_used == 0) ? 2 : 0;
        if ((left_border + line_used + sep + m) > cols) {
            if (line_used > 0) {
                addch('\n');
            }
            line_used = 0;
        }
        if (line_used == 0) {
            ui_print_lborder_green();
            addch(' ');
        } else {
            addstr("    ");
        }
        addnstr(buf, m);
        line_used += ((line_used == 0) ? 0 : sep) + m;
        shown++;
    }
    if (shown > 0 && line_used > 0) {
        addch('\n');
    }
}

// Print discovered IDEN plan entries
static void
ui_print_p25_iden_plan(const dsd_opts* opts, const dsd_state* state) {
    UNUSED(opts);
    if (!state) {
        return;
    }
    int any = 0;
    for (int id = 0; id < 16; id++) {
        if (state->p25_base_freq[id] || state->p25_chan_spac[id] || state->p25_iden_trust[id]) {
            any = 1;
            break;
        }
    }
    if (!any) {
        ui_print_lborder_green();
        addstr(" (none)\n");
        return;
    }
    for (int id = 0; id < 16; id++) {
        long base = state->p25_base_freq[id];
        long spac = state->p25_chan_spac[id];
        int type = state->p25_chan_type[id] & 0xF;
        int tdma = (state->p25_chan_tdma[id] & 0x1) ? 1 : 0;
        int trust = state->p25_iden_trust[id];
        if (base == 0 && spac == 0 && trust == 0) {
            continue;
        }
        double base_mhz = (double)(base * 5) / 1000000.0;   // base*5 Hz
        double spac_mhz = (double)(spac * 125) / 1000000.0; // spac*125 Hz
        attr_t saved_attrs = 0;
        short saved_pair = 0;
        attr_get(&saved_attrs, &saved_pair, NULL);
        attron(COLOR_PAIR(ui_iden_color_pair(id)));
        ui_print_lborder_green();
        addch(' ');
        printw("IDEN %d: %s type:%d base:%.6lfMHz spac:%.6lfMHz off:%d trust:%s", id, tdma ? "TDMA" : "FDMA", type,
               base_mhz, spac_mhz, state->p25_trans_off[id],
               (trust >= 2)   ? "ok"
               : (trust == 1) ? "prov"
                              : "-");
        if (state->p25_iden_wacn[id] || state->p25_iden_sysid[id]) {
            printw(" W:%05llX S:%03llX", state->p25_iden_wacn[id], state->p25_iden_sysid[id]);
        }
        if (state->p25_iden_rfss[id] || state->p25_iden_site[id]) {
            printw(" R:%lld I:%lld", state->p25_iden_rfss[id], state->p25_iden_site[id]);
        }
        addch('\n');
        attron(COLOR_PAIR(saved_pair));
    }
}

// Compose a short string describing any active patch/system mode for trunking
// Example outputs: "P25p2 trunk", "P25p1 trunk", "EDACS trunk", "DMR TIII trunk", "DMR Con+ trunk", "Trunking"
/* (removed) ui_compose_active_patch_label: replaced with p25_patch_compose_summary */

// Try to resolve an active VC frequency from current state when p25_vc_freq is unset
static long int
ui_guess_active_vc_freq(const dsd_state* state) {
    if (!state) {
        return 0;
    }
    // Prefer protocol-agnostic trunk alias when available
    if (state->trunk_vc_freq[0] != 0) {
        return state->trunk_vc_freq[0];
    }
    // Fallback to P25-specific field
    if (state->p25_vc_freq[0] != 0) {
        return state->p25_vc_freq[0];
    }
    // Parse any active channel strings for a channel/LCN and map via trunk_chan_map
    for (int i = 0; i < 31; i++) {
        const char* s = state->active_channel[i];
        if (!s || s[0] == '\0') {
            continue;
        }
        const char* p = strstr(s, "Ch:");
        if (!p) {
            continue;
        }
        p += 3; // skip "Ch:"
        while (*p == ' ') {
            p++;
        }
        // Capture up to 6 hex/dec digits
        char tok[8] = {0};
        int t = 0;
        while (*p && t < 6) {
            char c = *p;
            int is_hex = (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f');
            if (!is_hex) {
                break;
            }
            tok[t++] = c;
            p++;
        }
        if (t == 0) {
            continue;
        }
        // Try hex channel index first (P25), then decimal (DMR/NXDN)
        char* endp = NULL;
        long ch_hex = strtol(tok, &endp, 16);
        if (endp && *endp == '\0' && ch_hex > 0 && ch_hex < 65535) {
            long int f = state->trunk_chan_map[ch_hex];
            if (f != 0) {
                return f;
            }
        }
        long ch_dec = strtol(tok, &endp, 10);
        if (endp && *endp == '\0' && ch_dec > 0 && ch_dec < 65535) {
            long int f = state->trunk_chan_map[ch_dec];
            if (f != 0) {
                return f;
            }
        }
    }
    return 0;
}

// Print learned trunking LCNs and their mapped frequencies
static void
ui_print_learned_lcns(const dsd_opts* opts, const dsd_state* state) {
    if (!opts || !state) {
        return;
    }
    if (opts->p25_trunk != 1) {
        return;
    }

    int have_lcn_freq = 0;
    for (int i = 0; i < 26; i++) {
        if (state->trunk_lcn_freq[i] != 0) {
            have_lcn_freq = 1;
            break;
        }
    }

    int have_chan_map = 0;
    // Presence check across the full range; needed because many systems use high channel indices
    for (int i = 1; i < 65535; i++) {
        if (state->trunk_chan_map[i] != 0) {
            have_chan_map = 1;
            break;
        }
    }

    if (!have_lcn_freq && !have_chan_map) {
        return;
    }

    ui_print_header("Channels");

    // Prefer a calm cyan unless a call is active
    if (state->carrier == 1) {
        attron(COLOR_PAIR(3));
    } else {
        attron(COLOR_PAIR(4));
    }

    // Track which freqs we've already shown to avoid duplicates across LCNs and CH map
    long int seen_freqs[256];
    int seen_count = 0;
    int cols_per_line = 3;
    int col_in_row = 0;

    // First: render known channel->frequency pairs as CH <hex>
    if (have_chan_map) {
        int printed = 0;
        int extra = 0;
        for (int i = 1; i < 65535; i++) {
            long int f = state->trunk_chan_map[i];
            if (f == 0) {
                continue;
            }
            int dup = 0;
            for (int k = 0; k < seen_count; k++) {
                if (seen_freqs[k] == f) {
                    dup = 1;
                    break;
                }
            }
            if (dup) {
                continue;
            }
            if (printed < 32) { // cap to avoid flooding (rows of 3)
                if (col_in_row == 0) {
                    ui_print_lborder_green();
                    addch(' ');
                }
                // Temporarily tint IDEN-derived channels
                attr_t saved_attrs = 0;
                short saved_pair = 0;
                attr_get(&saved_attrs, &saved_pair, NULL);
                int iden = -1;
                int is_iden = ui_match_iden_channel(state, i, f, &iden);
                if (is_iden) {
                    attron(COLOR_PAIR(ui_iden_color_pair(iden)));
                    printw("CH %04X[I%d]: %010.06lf MHz", i & 0xFFFF, iden & 0xF, (double)f / 1000000.0);
                    attron(COLOR_PAIR(saved_pair));
                } else {
                    printw("CH %04X: %010.06lf MHz", i & 0xFFFF, (double)f / 1000000.0);
                }
                col_in_row++;
                printed++;
                if (col_in_row >= cols_per_line) {
                    addch('\n');
                    col_in_row = 0;
                } else {
                    addstr("   "); // spacing between columns
                }
            } else {
                extra++;
            }
            if (seen_count < (int)(sizeof(seen_freqs) / sizeof(seen_freqs[0]))) {
                seen_freqs[seen_count++] = f;
            }
        }
        if (col_in_row > 0) { // flush partial row before switching to LCN list
            addch('\n');
            col_in_row = 0; // reset so the next section starts with a fresh border
        }
        if (extra > 0) {
            ui_print_lborder_green();
            printw(" ... and %d more learned channels\n", extra);
        }
    }

    // Then: include any additional freqs learned via LCN list, labeling as CH as well.
    if (have_lcn_freq) {
        for (int i = 0; i < 26; i++) {
            long int f = state->trunk_lcn_freq[i];
            if (f == 0) {
                continue;
            }
            int dup = 0;
            for (int k = 0; k < seen_count; k++) {
                if (seen_freqs[k] == f) {
                    dup = 1;
                    break;
                }
            }
            if (dup) {
                continue;
            }
            // Try to find a matching channel id for this freq
            int found_ch = -1;
            for (int j = 1; j < 65535; j++) {
                if (state->trunk_chan_map[j] == f) {
                    found_ch = j;
                    break;
                }
            }
            if (found_ch >= 0) {
                if (col_in_row == 0) {
                    ui_print_lborder_green();
                    addch(' ');
                }
                // Tint if this CH aligns with IDEN params
                attr_t saved_attrs = 0;
                short saved_pair = 0;
                attr_get(&saved_attrs, &saved_pair, NULL);
                int iden = -1;
                int is_iden = ui_match_iden_channel(state, found_ch, f, &iden);
                if (is_iden) {
                    attron(COLOR_PAIR(ui_iden_color_pair(iden)));
                    printw("CH %04X[I%d]: %010.06lf MHz", found_ch & 0xFFFF, iden & 0xF, (double)f / 1000000.0);
                    attron(COLOR_PAIR(saved_pair));
                } else {
                    printw("CH %04X: %010.06lf MHz", found_ch & 0xFFFF, (double)f / 1000000.0);
                }
            } else {
                if (col_in_row == 0) {
                    ui_print_lborder_green();
                    addch(' ');
                }
                printw("CH ----: %010.06lf MHz", (double)f / 1000000.0);
            }
            col_in_row++;
            if (col_in_row >= cols_per_line) {
                addch('\n');
                col_in_row = 0;
            } else {
                addstr("   ");
            }
            if (seen_count < (int)(sizeof(seen_freqs) / sizeof(seen_freqs[0]))) {
                seen_freqs[seen_count++] = f;
            }
        }
        if (col_in_row > 0) {
            addch('\n');
        }
    }

    // Legend for IDEN color/suffix (P25 systems only)
    {
        int lls = state ? state->synctype : -1;
        int is_p25p1 = (lls == 0 || lls == 1);
        int is_p25p2 = (lls == 35 || lls == 36);
        if (is_p25p1 || is_p25p2) {
            ui_print_lborder_green();
            printw(" Legend: IDEN colors ");
            for (int c = 0; c < 8; c++) {
                attron(COLOR_PAIR(ui_iden_color_pair(c)));
                printw("I%d", c);
                attroff(COLOR_PAIR(ui_iden_color_pair(c)));
                addch(' ');
            }
            addch('\n');
        }
    }

    // Restore to green if in-call, otherwise keep cyan; callers around will adjust as needed
    if (state->carrier == 1) {
        attron(COLOR_PAIR(3));
    } else {
        attron(COLOR_PAIR(4));
    }
}

void
ncursesPrinter(dsd_opts* opts, dsd_state* state) {
    uint8_t idas = 0;
    int level = 0;
    int c = 0;
    int i = 0;

    if (opts->audio_in_type != 1) //can't run getch/menu when using STDIN -
    {
        timeout(0);  //
        c = getch(); //
    }

    //Variable reset/set section

    //set lls sync types
    if (state->synctype >= 0) {
        lls = state->synctype;
    }

    //EDACS Channel Tree
    if ((lls == 14 || lls == 15 || lls == 37 || lls == 38) && state->carrier == 1) {

        if (state->edacs_vc_lcn != -1) {
            edacs_channel_tree[state->edacs_vc_lcn][0] = lls;
            edacs_channel_tree[state->edacs_vc_lcn][1] = state->edacs_vc_lcn;
            edacs_channel_tree[state->edacs_vc_lcn][2] = state->lasttg;
            //EDACS standard does not provide source LIDs on channel update messages; instead, for the sake of display, let's
            //assume the prior source for a given LCN is still accurate, unless we have an updated one provided (or the call
            //type has changed under us).
            //
            //If you MUST have perfectly-accurate source LIDs, look at the logged CC messages yourself - incorrect source LIDs
            //may be displayed if we miss an initial call channel assignment.
            if (state->ea_mode == 1
                || (state->lastsrc != 0
                    || edacs_channel_tree[state->edacs_vc_lcn][4] != (unsigned long long)state->edacs_vc_call_type)) {
                edacs_channel_tree[state->edacs_vc_lcn][3] = state->lastsrc;
            }
            if (state->ea_mode == 0 && state->lastsrc == 0x800) { //this was from a grant update, so set this to 0
                edacs_channel_tree[state->edacs_vc_lcn][3] = 0;
            }
            edacs_channel_tree[state->edacs_vc_lcn][4] = state->edacs_vc_call_type;
            edacs_channel_tree[state->edacs_vc_lcn][5] = time(NULL);
        }
    }

    //Start Printing Section
    erase();
    if (opts->ncurses_compact == 1) {
        ui_print_hr();
        printw("| Digital Speech Decoder: DSD-neo %s (%s)  | Enter=Menu  q=Quit\n", GIT_TAG, GIT_HASH);
        ui_print_hr();
    }
    if (opts->ncurses_compact == 0) {
        attron(COLOR_PAIR(6));
        ui_print_hr();
        printw("| Digital Speech Decoder: DSD-neo %s (%s)  | Enter=Menu  q=Quit\n", GIT_TAG, GIT_HASH);
        ui_print_hr();
        attroff(COLOR_PAIR(6));
        attron(COLOR_PAIR(4));
    }

    //fix color/pair issue when compact and trunking enabled
    if (opts->ncurses_compact == 1 && opts->p25_trunk == 1) {
        attron(COLOR_PAIR(4));
    }

    // Transient toast message (e.g., mute toggled)
    if (state) {
        time_t now = time(NULL);
        if (state->ui_msg[0] != '\0' && state->ui_msg_expire > now) {
#ifdef PRETTY_COLORS
            // Preserve current color pair to avoid forcing default/white after toast
            attr_t saved_attrs = 0;
            short saved_pair = 0;
            attr_get(&saved_attrs, &saved_pair, NULL);
#endif
            attron(COLOR_PAIR(2));
            printw("| %s\n", state->ui_msg);
            attroff(COLOR_PAIR(2));
            ui_print_hr();
#ifdef PRETTY_COLORS
            // Restore whichever color was active before the toast (e.g., cyan UI)
            if (saved_pair >= 0) {
                attron(COLOR_PAIR(saved_pair));
            } else {
                attron(COLOR_PAIR(4));
            }
#endif
        } else if (state->ui_msg_expire <= now && state->ui_msg[0] != '\0') {
            // clear stale message
            state->ui_msg[0] = '\0';
        }
    }

    ui_print_header("Input Output");
    if (opts->audio_in_type == 0) {
        printw("| Pulse Signal Input:  %i kHz; %i Ch; ", opts->pulse_digi_rate_in / 1000, opts->pulse_digi_in_channels);
        if (opts->pa_input_idx[0] != 0) {
            printw(" D: %s;", opts->pa_input_idx);
        }
        if (opts->use_rigctl == 1) {
            printw("RIG: %s:%d; ", opts->tcp_hostname, opts->rigctlportno);
        }
        printw(" IV: %iX;", opts->input_volume_multiplier);
        printw("\n");
    }

    if (opts->audio_in_type == 5) {
        printw("| OSS Signal Input: %i kHz; 1 Ch;", SAMPLE_RATE_IN / 1000);
        if (opts->use_rigctl == 1) {
            printw("RIG: %s:%d; ", opts->tcp_hostname, opts->rigctlportno);
        }
        printw(" IV: %iX;", opts->input_volume_multiplier);
        printw("\n");
    }

    if (opts->audio_in_type == 4) {
        printw("| Dibit Bin Input: %s \n", opts->audio_in_dev);
    }

    if (opts->audio_in_type == 44) {
        printw("| Symbol Float Input: %s \n", opts->audio_in_dev);
    }

    if (opts->m17decoderip == 1 && opts->udp_sockfd) {
        printw("| M17 UDP IP Frame Input: %s:%d \n", opts->m17_hostname, opts->m17_portno);
    }

    if (opts->audio_in_type == 8) {
        printw("| TCP Signal Input: %s:%d; %d kHz; 1 Ch; ", opts->tcp_hostname, opts->tcp_portno,
               opts->wav_sample_rate / 1000);
        if (opts->use_rigctl == 1) {
            printw("RIG: %s:%d; ", opts->tcp_hostname, opts->rigctlportno);
        }
        printw(" IV: %iX;", opts->input_volume_multiplier);
        printw("\n");
    }

    if (opts->audio_in_type == 6) {
        const char* host = (opts->udp_in_bindaddr[0] ? opts->udp_in_bindaddr : "127.0.0.1");
        printw("| UDP Signal Input: %s:%d; %d kHz; 1 Ch; ", host, opts->udp_in_portno, opts->wav_sample_rate / 1000);
        if (opts->udp_in_packets == 0ULL) {
            printw("[Waiting]");
        } else {
            printw("Pkts:%llu Drops:%llu", (unsigned long long)opts->udp_in_packets,
                   (unsigned long long)opts->udp_in_drops);
        }
        printw(" IV: %iX;", opts->input_volume_multiplier);
        printw("\n");
    }

    if (opts->audio_in_type == 2) {
        printw("| WAV Audio Input: %s; %d kHz; ", opts->audio_in_dev, opts->wav_sample_rate);
        printw(" IV: %iX;\n", opts->input_volume_multiplier);
    }

    if (opts->audio_in_type == 1) {
        printw("| STDIN Standard Input: - Menu Disabled when using STDIN!\n");
        // printw ("| NCURSES Menu Disabled when using STDIN! - Use CTRL + C to Close. \n");
    }

    if (opts->audio_in_type == 3) {
        printw("| RTL: %d;", opts->rtl_dev_index);
        /* Show applied tuner gain when available (actual driver value),
           otherwise fall back to requested value. */
        {
            int g10 = 0, is_auto = 1;
            int have = 0;
#ifdef USE_RTLSDR
            /* Header is already included indirectly via other UI modules. */
            extern int rtl_stream_get_gain(int* out_tenth_db, int* out_is_auto);
            if (rtl_stream_get_gain(&g10, &is_auto) == 0) {
                have = 1;
            }
#endif
            if (have) {
                if (is_auto) {
                    printw(" G: AGC;");
                } else {
                    int gdB = (g10 >= 0) ? (g10 + 5) / 10 : (g10 - 5) / 10;
                    printw(" G: %idB;", gdB);
                }
            } else {
                if (opts->rtl_gain_value == 0) {
                    printw(" G: AGC;");
                } else {
                    printw(" G: %idB;", opts->rtl_gain_value);
                }
            }
        }
        printw(" V: %iX;", opts->rtl_volume_multiplier);
        printw(" PPM: %i;", opts->rtlsdr_ppm_error); //Adjust manually now with { and }
        printw(" SQL: %.1f dB;", pwr_to_dB(opts->rtl_squelch_level));
        printw(" PWR: %.1f dB;", pwr_to_dB(opts->rtl_pwr));
        printw(" BW: %i;", opts->rtl_bandwidth);
        printw(" FRQ: %i;", opts->rtlsdr_center_freq);
        /* Show spectrum-based auto PPM status snapshot */
        {
            int ap_en = 0, ap_dir = 0, ap_cd = 0, ap_locked = 0;
            double ap_snr = -100.0, ap_df = 0.0, ap_estppm = 0.0;
#ifdef USE_RTLSDR
            extern int rtl_stream_auto_ppm_get_status(int*, double*, double*, double*, int*, int*, int*);
            (void)rtl_stream_auto_ppm_get_status(&ap_en, &ap_snr, &ap_df, &ap_estppm, &ap_dir, &ap_cd, &ap_locked);
#endif
            const char* ap_state = ap_en ? (ap_locked ? "Locked" : "On") : "Off";
            printw("\n| Auto PPM: %s", ap_state);
            if (ap_en) {
                if (ap_locked) {
                    int lppm = 0;
                    double lsnr = -100.0, ldf = 0.0;
#ifdef USE_RTLSDR
                    extern int rtl_stream_auto_ppm_get_lock(int*, double*, double*);
                    (void)rtl_stream_auto_ppm_get_lock(&lppm, &lsnr, &ldf);
#endif
                    printw(" (PPM: %d)", lppm);
                } else {
                    printw("; SNR: %.1f dB; df: %.1f Hz; step: %s;", ap_snr, ap_df,
                           (ap_dir > 0)   ? "+1"
                           : (ap_dir < 0) ? "-1"
                                          : "hold");
                }
            }
        }
        if (opts->rtl_udp_port != 0) {
            printw("\n| External RTL Tuning on UDP Port: %i", opts->rtl_udp_port);
        }
        printw("\n");
        /* Show compact DSP status directly above audio sections (optional) */
        if (opts->show_dsp_panel) {
            print_dsp_status();
        }
        /* Signal quality is shown inline above; no duplicate line here. */
    }

    if (opts->audio_out_type == 0 && opts->analog_only == 0) {
        printw("| Pulse Digital Output: %i kHz; %i Ch; G: %02.0f%%", opts->pulse_digi_rate_out / 1000,
               opts->pulse_digi_out_channels, state->aout_gain * 2);
        if (opts->pulse_digi_out_channels == 2) {
            printw(" G: %02.0f%%", state->aout_gainR * 2);
        }
        if (opts->floating_point == 1) {
            printw(" FLOAT: %02.0f%%;", opts->audio_gain * 2);
        }
        if (opts->audio_gain == 0) {
            printw(" (+|-) Auto  ");
        }
        if (opts->audio_gain > 0) {
            printw(" (+|-) Manual");
        }
        if (opts->use_hpf_d == 1) {
            printw(" HPF");
        }
        if (opts->call_alert == 1) {
            printw(" *CA!"); //Call Alert
        }
        if (opts->pa_output_idx[0] != 0) {
            printw(" D: %s;", opts->pa_output_idx);
        }

        printw(" \n");
    }

    if (opts->audio_out_type == 0 && (opts->frame_provoice == 1 || opts->monitor_input_audio == 1)) {
        printw("| Pulse Analog Output: %i kHz; %i Ch; G: %02.0f%% (/|*) ", opts->pulse_raw_rate_out / 1000,
               opts->pulse_raw_out_channels, opts->audio_gainA);
        if (opts->audio_gainA == 0.0f) {
            printw("Auto   ");
        } else {
            printw("Manual ");
        }
        if (opts->audio_in_type != 3) {
            printw("PWR: %.1f dB; ", pwr_to_dB(opts->rtl_pwr));
        }
        if (opts->use_lpf == 1) {
            printw("F: |LP|");
        } else {
            printw("F: |  |");
        }
        if (opts->use_hpf == 1) {
            printw("HP|");
        } else {
            printw("  |");
        }
        if (opts->use_pbf == 1) {
            printw("PB|");
        } else {
            printw("  |");
        }
        if (opts->pa_output_idx[0] != 0) {
            printw(" D: %s;", opts->pa_output_idx);
        }
        printw(" \n");
    }

    if (opts->audio_out_type == 5 || opts->audio_out_type == 2) {
        printw("| OSS Audio Output: %i kHz; %i Ch; G: %02.0f%%", opts->pulse_digi_rate_out / 1000,
               opts->pulse_digi_out_channels, state->aout_gain * 2);
        if (opts->pulse_digi_out_channels == 2) {
            printw(" G: %02.0f%%", state->aout_gainR * 2);
        }
        if (opts->audio_gain == 0) {
            printw(" (+/-) Auto  ");
        }
        if (opts->audio_gain > 0) {
            printw(" (+/-) Manual");
        }
        if (opts->use_hpf_d == 1) {
            printw(" HPF");
        }
        if (opts->call_alert == 1) {
            printw(" *CA!"); //Call Alert
        }

        if ((opts->audio_out_type == 5 && opts->pulse_digi_rate_out == 48000 && opts->pulse_digi_out_channels == 1)
            && (opts->frame_provoice == 1 || opts->monitor_input_audio == 1)) {
            printw("\n| Analog Monitor PWR: %.1f dB; G: %02.0f%% (/|*) ", pwr_to_dB(opts->rtl_pwr), opts->audio_gainA);
            if (opts->audio_gainA == 0.0f) {
                printw("Auto   ");
            } else {
                printw("Manual ");
            }
            if (opts->use_lpf == 1) {
                printw("F: |LP|");
            } else {
                printw("F: |  |");
            }
            if (opts->use_hpf == 1) {
                printw("HP|");
            } else {
                printw("  |");
            }
            if (opts->use_pbf == 1) {
                printw("PB|");
            } else {
                printw("  |");
            }
        }
        printw(" \n");
    }

    if (opts->audio_out_type == 8) {
        printw("| UDP Digital Output: %s:%d; %d kHz %d Ch; %02.0f%%", opts->udp_hostname, opts->udp_portno,
               opts->pulse_digi_rate_out / 1000, opts->pulse_digi_out_channels, state->aout_gain * 2);
        if (opts->pulse_digi_out_channels == 2) {
            printw(" G: %02.0f%%", state->aout_gainR * 2);
        }
        if (opts->audio_gain == 0) {
            printw(" (+/-) Auto  ");
        }
        if (opts->audio_gain > 0) {
            printw(" (+/-) Manual");
        }
        if (opts->use_hpf_d == 1) {
            printw(" HPF");
        }
        if (opts->call_alert == 1) {
            printw(" *CA!"); //Call Alert
        }
        if ((opts->audio_out_type == 5 && opts->pulse_digi_rate_out == 48000 && opts->pulse_digi_out_channels == 1)
            && (opts->frame_provoice == 1 || opts->monitor_input_audio == 1)) {
            printw(" - Monitor PWR: %.1f dB ", pwr_to_dB(opts->rtl_pwr));
        }
        printw(" \n");
        if (opts->udp_sockfdA != 0) //Analog Output on udp port +2
        {
            printw("| UDP Analog Output: %s:%d; 48 kHz 1 Ch; G: %02.0f%% (/|*) ", opts->udp_hostname,
                   opts->udp_portno + 2, opts->audio_gainA);
            if (opts->audio_gainA == 0.0f) {
                printw("A ");
            } else {
                printw("M ");
            }
            if (opts->audio_in_type != 3) {
                printw("PWR: %.1f dB; ", pwr_to_dB(opts->rtl_pwr));
            }
            if (opts->use_lpf == 1) {
                printw("F: |LP|");
            } else {
                printw("F: |  |");
            }
            if (opts->use_hpf == 1) {
                printw("HP|");
            } else {
                printw("  |");
            }
            if (opts->use_pbf == 1) {
                printw("PB|");
            } else {
                printw("  |");
            }
            printw(" \n");
        }
    }

    if (opts->m17encoder == 1) {
        printw("| M17 Encoder:");
        if (state->m17encoder_tx == 1 && state->m17_vox == 0) {
            printw(" Toggle TX (\\) On ;");
        }
        if (state->m17encoder_tx == 0 && state->m17_vox == 0) {
            printw(" Toggle TX (\\) Off;");
        }
        if (state->m17_vox == 1) {
            printw(" Vox Mode;");
        }
        printw(" Input Gain (/|*): %02.0f%% ", opts->audio_gainA);

        if (opts->use_lpf == 1) {
            printw("F: |LP|");
        } else {
            printw("F: |  |");
        }
        if (opts->use_hpf == 1) {
            printw("HP|");
        } else {
            printw("  |");
        }
        if (opts->use_pbf == 1) {
            printw("PB|");
        } else {
            printw("  |");
        }
        if (opts->audio_in_type != 3 && state->m17_vox == 1) {
            printw(" SQL: %.1f : %.1f dB;", pwr_to_dB(opts->rtl_pwr), pwr_to_dB(opts->rtl_squelch_level));
        }
        printw("\n");
    }

    if (opts->m17_use_ip == 1) {
        printw("| M17 UDP IP Frame Output: %s:%d \n", opts->m17_hostname, opts->m17_portno);
    }

    if (opts->mbe_out_dir[0] != 0 && opts->dmr_stereo == 0) {
        printw("| Writing MBE data files to directory %s\n", opts->mbe_out_dir);
    }

    if (opts->wav_out_raw) {
        printw("| Raw Audio Output: %s\n", opts->wav_out_file_raw);
    }

    if (opts->symbol_out_f) //don't display when not actively capturing
    {
        printw("| Symbol Bin Output: %s\n", opts->symbol_out_file);
    }

    if (opts->dmr_stereo_wav == 0 && opts->wav_out_file[0] != 0) {
        printw("| Decoded WAV Output: %s\n", opts->wav_out_file);
    }

    //new Per Call setup would just be random names until closed,
    //so no need to show, and will be in the event history anyways
    if (opts->dmr_stereo_wav == 1) {
        printw("| Per Call Wav File Enabled to Directory: %s \n", opts->wav_out_dir);
    }

#ifdef PRETTY_COLORS
    if (opts->p25_trunk == 1 && (opts->use_rigctl == 1 || opts->audio_in_type == 3)) {
        printw("| Trunking -");
        if (opts->trunk_tune_group_calls == 0) {
            attron(COLOR_PAIR(2));
        }
        printw(" Group(g)");
        attron(COLOR_PAIR(4));
        if (opts->trunk_tune_private_calls == 0) {
            attron(COLOR_PAIR(2));
        }
        printw(" Private(u)");
        attron(COLOR_PAIR(4));
        if (opts->trunk_tune_data_calls == 0) {
            attron(COLOR_PAIR(2));
        }
        printw(" Data(d)");
        attron(COLOR_PAIR(4));
        if (opts->trunk_tune_enc_calls == 0) {
            attron(COLOR_PAIR(2));
        }
        printw(" Encrypted(e)");
        attron(COLOR_PAIR(4));
        printw(" Calls");
        if (opts->trunk_use_allow_list == 1) {
            printw(" - White List Mode\n");
        } else {
            printw(" - Black List Mode\n");
        }
        // P25 metrics moved to dedicated 'P25 Metrics' section below.
    }
#else //set on to UPPER CASE, off to lower case
    if (opts->p25_trunk == 1 && (opts->use_rigctl == 1 || opts->audio_in_type == 3)) {
        printw("| Trunking -");
        if (opts->trunk_tune_group_calls == 0) {
            printw(" group(g)");
        } else {
            printw(" GROUP(g)");
        }
        if (opts->trunk_tune_private_calls == 0) {
            printw(" private(u)");
        } else {
            printw(" PRIVATE(u)");
        }
        if (opts->trunk_tune_data_calls == 0) {
            printw(" data(d)");
        } else {
            printw(" DATA(d)");
        }
        if (opts->trunk_tune_enc_calls == 0) {
            printw(" encrypted(e)");
        } else {
            printw(" ENCRYPTED(e)");
        }
        printw(" Calls");
        if (opts->trunk_use_allow_list == 1) {
            printw(" - White List Mode\n");
        } else {
            printw(" - Black List Mode\n");
        }
        // P25 metrics moved to dedicated 'P25 Metrics' section below.
    }
#endif
//print additional information for EDACS modes and toggles
#ifdef PRETTY_COLORS
    if (opts->p25_trunk == 1 && opts->frame_provoice == 1) {
        printw("| \\--EDACS -");
        if (state->ea_mode == -1) {
            attron(COLOR_PAIR(2));
            printw(" Standard/Network");
            printw(" Extended Address");
            attron(COLOR_PAIR(4));
        } else if (state->ea_mode == 0) {
            printw(" Standard/Network");
            attron(COLOR_PAIR(2));
            printw(" Extended Address");
            attron(COLOR_PAIR(4));
        } else if (state->ea_mode == 1) {
            attron(COLOR_PAIR(2));
            printw(" Standard/Network");
            attron(COLOR_PAIR(4));
            printw(" Extended Address");
        }
        printw(" Mode (S);");

        printw(" ESK: %02X", state->esk_mask);
        printw(" (A);");

        if (state->ea_mode == 0) {
            printw(" AFS: %d:%d:%d;", state->edacs_a_bits, state->edacs_f_bits, state->edacs_s_bits);
        }

        //TG Hold on EDACS, if specified by user
        if (state->tg_hold != 0) {
            // Compute AFS for display purposes only
            int a = (state->tg_hold >> state->edacs_a_shift) & state->edacs_a_mask;
            int f = (state->tg_hold >> state->edacs_f_shift) & state->edacs_f_mask;
            int s = state->tg_hold & state->edacs_s_mask;
            if (state->ea_mode == 1) {
                printw("\n|  \\TG HOLD: %d; ", state->tg_hold);
            } else {
                char afs_str[8];
                getAfsString(state, afs_str, a, f, s);
                printw("\n|  \\TG HOLD: %d [%s]; ", state->tg_hold, afs_str);
            }
        }

        attron(COLOR_PAIR(4));
        printw("\n");
    }
#else //set on to UPPER CASE, off to lower case
    if (opts->p25_trunk == 1 && opts->frame_provoice == 1) {
        printw("| \\--EDACS -");
        if (state->ea_mode == -1) {
            printw(" standard/network");
            printw(" extended address");
        } else if (state->ea_mode == 0) {
            printw(" STANDARD/NETWORK");
            printw(" extended address");
        } else if (state->ea_mode == 1) {
            printw(" standard/network");
            printw(" EXTENDED ADDRESS");
        }
        printw(" Mode (S);");

        printw(" ESK: %02X", state->esk_mask);
        printw(" (A) Toggle; ");

        if (state->ea_mode == 0) {
            printw(" AFS: %d:%d:%d;", state->edacs_a_bits, state->edacs_f_bits, state->edacs_s_bits);
        }

        //TG Hold on EDACS, if specified by user
        if (state->tg_hold != 0) {
            // Compute AFS for display purposes only
            int a = (state->tg_hold >> state->edacs_a_shift) & state->edacs_a_mask;
            int f = (state->tg_hold >> state->edacs_f_shift) & state->edacs_f_mask;
            int s = state->tg_hold & state->edacs_s_mask;
            if (state->ea_mode == 1) {
                printw("\n|  \\TG HOLD: %d; ", state->tg_hold);
            } else {
                char afs_str[8];
                getAfsString(state, afs_str, a, f, s);
                printw("\n|  \\TG HOLD: %d [%s]; ", state->tg_hold, afs_str);
            }
        }

        printw("\n");
    }
#endif
    // if (opts->aggressive_framesync == 0) printw ("| Selective CRC ERR Bypass Enabled (RAS) \n");
    if (state->M == 1) {
        if (state->R != 0) {
            printw("| Forcing Key Priority -- NXDN Sc Key: %05lld \n", state->R);
        }
        if (state->K != 0) {
            printw("| Forcing Key Priority -- Moto BP Key: %03lld \n", state->K);
        }
        if (state->K1 != 0) {
            printw("| Forcing Key Priority -- Hytera BP Key: %016llX \n", state->K1);
        }
        if (state->K != 0 && state->K1 != 0) {
            printw("| Warning! Multiple DMR Key Types Loaded! \n"); //warning may not be required
        }
    }
    if (state->M == 0x21) {
        if (state->R != 0) {
            printw("| Forcing Key Priority -- RC4 Key: %010llX \n", state->R);
        }
    }
    if (state->M == 0x16) {
        printw("| Forcing Key Priority -- TYT 16-bit Key: %04llX \n", state->H);
    }

    if (opts->scanner_mode == 1) {
        printw("| Scan Mode: ");
        if (state->lcn_freq_roll != 0) {
            printw(" Frequency: %.06lf Mhz", (double)state->trunk_lcn_freq[state->lcn_freq_roll - 1] / 1000000);
        }
        printw(
            " Speed: %.02lf sec \n",
            opts->trunk_hangtime); //not sure values less than 1 make a difference, may be system/environment dependent
    }

    if (opts->reverse_mute == 1) {
        printw("| Reverse Mute - Muting Unencrypted Voice\n");
    }
    // if (opts->call_alert == 1)   printw ("| Call Alert Tone Enabled\n");

    ui_print_hr();
#ifdef USE_RTLSDR
    /* Only show RTL-SDR section and render visualizers when RTL input is active */
    if (opts->audio_in_type == 3) {
        ui_print_header("RTL-SDR Visual Aids");
        int nfft = rtl_stream_spectrum_get_size();
        /* Controls/status line: only show controls relevant to active views */
        printw("| Const View:  %s (%c)", opts->constellation ? "On" : "Off", DSD_KEY_CONST_VIEW_UPPER);
        if (opts->constellation == 1) {
            printw("  Gate: %.02f (</>)  Norm: %s (%c)",
                   (opts->mod_qpsk == 1) ? opts->const_gate_qpsk : opts->const_gate_other,
                   opts->const_norm_mode ? "unit" : "radial", DSD_KEY_CONST_NORM);
        }
        printw("  Eye: %s (%c)", opts->eye_view ? "On" : "Off", DSD_KEY_EYE_VIEW);
        if (opts->eye_view == 1) {
            printw("  Uni: %s (%c) Col: %s (%c)", opts->eye_unicode ? "On" : "off", DSD_KEY_EYE_UNICODE,
                   opts->eye_color ? "On" : "Off", DSD_KEY_EYE_COLOR);
        }
        printw("  Hist: %s (%c)", opts->fsk_hist_view ? "On" : "Off", DSD_KEY_FSK_HIST);
        printw("  Spec: %s (%c)", opts->spectrum_view ? "On" : "Off", DSD_KEY_SPECTRUM);
        if (opts->spectrum_view == 1) {
            printw("  FFT:%d (%c/%c)", nfft, DSD_KEY_SPEC_DEC, DSD_KEY_SPEC_INC);
        }
        addch('\n');
        ui_print_hr();

        if (opts->constellation == 1) {
            print_constellation_view(opts, state);
        }
        if (opts->eye_view == 1) {
            print_eye_view(opts, state);
        }
        if (opts->fsk_hist_view == 1) {
            print_fsk_hist_view();
        }
        if (opts->spectrum_view == 1) {
            print_spectrum_view(opts);
        }
    }
#endif
    /* Ensure our primary UI color remains active after visual aids */
    attron(COLOR_PAIR(4));

    if (state->carrier == 1) {
        attron(COLOR_PAIR(3));
        level = (int)state->max / 164; //only update on carrier present
        if (opts->mod_qpsk == 1) {
            level = (int)state->max / 328; //test values here
        }
        if (opts->audio_in_type == 4) {
            level = 50; //hard set when reading symbol bin files, otherwise, it will just be near zero
        }
        if (level > 100) {
            level = 100; //cap max at 100 to prevent it going over
        }
    } else {
        level = 0;
    }

    ui_print_header("Audio Decode");
    if (opts->p25_trunk == 1 && (opts->trunk_is_tuned == 1 || opts->p25_is_tuned == 1)) {
        ui_print_kv_line("Tuner state", "Busy");
    }
    if (opts->p25_trunk == 1 && (opts->trunk_is_tuned == 0 && opts->p25_is_tuned == 0)) {
        ui_print_kv_line("Tuner state", "Free");
    }
    ui_print_label_pad("Demod/Rate");
    if (opts->mod_qpsk == 1) {
        printw("[QPSK]");
    }
    if (opts->mod_c4fm == 1) {
        printw("[C4FM]");
    }
    if (opts->mod_gfsk == 1) {
        printw("[GFSK]");
    }
    printw("[%d] \n", (48000 * opts->wav_interpolator) / state->samplesPerSymbol);
    /* (RTL-SDR controls moved to dedicated section above) */
    if (opts->m17encoder == 1) {
        printw("| Encoding:    [%s] \n", opts->output_name);
    }
    ui_print_label_pad("Decoding");
    printw("[%s] ", opts->output_name);
    if (opts->aggressive_framesync == 0) {
        printw("CRC/(RAS) ");
    }
    /* Demod SNR (per modulation) */
#ifdef USE_RTLSDR
    {
        double snr = -100.0;
        const char* m = "";
        /* Simple stale detection for cases where SNR stops updating */
        static double last_c4_snr = -999.0; /* C4FM */
        static int last_c4_stable = 0;
        if (state->rf_mod == 0) {
            snr = rtl_stream_get_snr_c4fm();
            m = "C4FM";
            /* If missing or appears stale, compute a quick fallback from the eye buffer */
            if (snr <= -50.0) {
                double fb = rtl_stream_estimate_snr_c4fm_eye();
                if (fb > -50.0) {
                    snr = fb;
                    last_c4_stable = 0;
                }
            } else {
                double delta = fabs(snr - last_c4_snr);
                if (delta < 0.05) {
                    if (++last_c4_stable >= 40) { /* ~couple seconds of no change */
                        double fb = rtl_stream_estimate_snr_c4fm_eye();
                        if (fb > -50.0) {
                            snr = fb;
                        }
                        last_c4_stable = 0;
                    }
                } else {
                    last_c4_stable = 0;
                }
                last_c4_snr = snr;
            }
        } else if (state->rf_mod == 1) {
            snr = rtl_stream_get_snr_cqpsk();
            m = "QPSK";
            /* Fallback: prefer constellation-based QPSK estimator; else use best of C4FM/GFSK */
            static double last_qp_snr = -999.0;
            static int last_qp_stable = 0;
            if (snr <= -50.0) {
                double fb = rtl_stream_estimate_snr_qpsk_const();
                if (fb > -50.0) {
                    snr = fb;
                    last_qp_stable = 0;
                } else {
                    double snr_c = rtl_stream_get_snr_c4fm();
                    double snr_g = rtl_stream_get_snr_gfsk();
                    double snr_fb = (snr_c > snr_g) ? snr_c : snr_g;
                    if (snr_fb > -50.0) {
                        snr = snr_fb;
                    }
                }
            } else {
                double delta = fabs(snr - last_qp_snr);
                if (delta < 0.05) {
                    if (++last_qp_stable >= 40) {
                        double fb = rtl_stream_estimate_snr_qpsk_const();
                        if (fb > -50.0) {
                            snr = fb;
                        }
                        last_qp_stable = 0;
                    }
                } else {
                    last_qp_stable = 0;
                }
                last_qp_snr = snr;
            }
        } else if (state->rf_mod == 2) {
            snr = rtl_stream_get_snr_gfsk();
            m = "GFSK";
            /* Stale/NA fallback: estimate from eye buffer (2-level) */
            static double last_gf_snr = -999.0;
            static int last_gf_stable = 0;
            if (snr <= -50.0) {
                double fb = rtl_stream_estimate_snr_gfsk_eye();
                if (fb > -50.0) {
                    snr = fb;
                    last_gf_stable = 0;
                }
            } else {
                double delta = fabs(snr - last_gf_snr);
                if (delta < 0.05) {
                    if (++last_gf_stable >= 40) {
                        double fb = rtl_stream_estimate_snr_gfsk_eye();
                        if (fb > -50.0) {
                            snr = fb;
                        }
                        last_gf_stable = 0;
                    }
                } else {
                    last_gf_stable = 0;
                }
                last_gf_snr = snr;
            }
        }
        if (snr > -50.0) {
            /* Show current SNR as a compact, colorized meter */
            printw(" SNR: %.1f dB ", snr);
            printw("[");
            print_snr_meter(opts, snr);
            printw("]");
            printw(" (%s)", m);
        } else {
            /* Show placeholder so users can see the field even when no estimate */
            printw(" SNR: n/a (%s) []", m[0] ? m : "-");
        }
    }
#endif
#ifndef USE_RTLSDR
    /* If built without RTL support, still show a placeholder */
    printw(" SNR: n/a []");
#endif
    printw("\n");
    ui_print_kv_line("In Level", "[%02d%%]", level);
    /* Quick hint for output mute toggle */
    ui_print_kv_line("Output (x)", "[%s]", (opts->audio_out == 0) ? "Muted" : "On");

    /* Hide generic Voice Error line when P25 is active, but keep slot toggles */
    int is_p25p1_active = (lls == 0 || lls == 1);
    int is_p25p2_active = (lls == 35 || lls == 36);
    int is_p25_active = is_p25p1_active || is_p25p2_active;

    if (opts->dmr_stereo == 0) {
        if (!is_p25_active) {
            printw("| Voice Error: [%X][%X]", state->errs & 0xF, state->errs2 & 0xF);
            double avgv = 0.0;
            if (compute_p25p1_voice_avg_err(state, &avgv)) {
                printw(" Avg:%4.1f%%", avgv);
            }
            /* Keep slot toggle state at the end, as before */
            if (opts->slot1_on == 0) {
                printw(" Off");
            }
            if (opts->slot1_on == 1) {
                printw(" On");
            }
            printw("\n");
        } else {
            /* P25 active: show only slot toggle state, no error counters */
            printw("| Slot 1 (1):  [%s]\n", (opts->slot1_on == 1) ? "On" : "Off");
        }
    }

    if (opts->dmr_stereo == 1) {
        if (!is_p25_active) {
            printw("| Voice Error: [%X][%X] Slot 1 (1)", state->errs & 0xF, state->errs2 & 0xF);
        } else {
            ui_print_label_pad("Slot 1 (1)");
            addch('[');
        }
        if (opts->slot1_on == 0) {
            printw(is_p25_active ? "Off" : " Off");
        }
        if (opts->slot1_on == 1) {
            printw(is_p25_active ? "On" : " On");
        }
        if (is_p25_active) {
            printw("]");
        }
        if (opts->slot_preference == 0) {
            printw(" *Preferred (3)");
        }
        printw("\n");

        if (!is_p25_active) {
            printw("| Voice Error: [%X][%X] Slot 2 (2)", state->errsR & 0xF, state->errs2R & 0xF);
        } else {
            ui_print_label_pad("Slot 2 (2)");
            addch('[');
        }
        if (opts->slot2_on == 0) {
            printw(is_p25_active ? "Off" : " Off");
        }
        if (opts->slot2_on == 1) {
            printw(is_p25_active ? "On" : " On");
        }
        if (is_p25_active) {
            printw("]");
        }
        if (opts->slot_preference == 1) {
            printw(" *Preferred (3)");
        }
        printw("\n");
    }
    ui_print_hr();

    /* Dedicated P25 metrics section (toggle in menu) */
    {
        int is_p25p1 = (lls == 0 || lls == 1);
        int is_p25p2 = (lls == 35 || lls == 36);
        if (opts->show_p25_metrics == 1 && (is_p25p1 || is_p25p2)) {
            ui_print_header("P25 Metrics");
            (void)ui_print_p25_metrics(opts, state);
            ui_print_hr();
        }
        /* CC Candidates (toggle) */
        if (opts->show_p25_cc_candidates == 1 && (is_p25p1 || is_p25p2)) {
            if (opts->p25_trunk == 1) {
                ui_print_header("P25 CC Candidates");
                ui_print_p25_cc_candidates(opts, state);
                ui_print_hr();
            }
        }
        /* Neighbors (toggle) */
        if (opts->show_p25_neighbors == 1 && (is_p25p1 || is_p25p2)) {
            ui_print_header("P25 Neighbors");
            ui_print_p25_neighbors(opts, state);
            ui_print_hr();
        }
        /* IDEN Plan (toggle) */
        if (opts->show_p25_iden_plan == 1 && (is_p25p1 || is_p25p2)) {
            ui_print_header("P25 IDEN Plan");
            ui_print_p25_iden_plan(opts, state);
            ui_print_hr();
        }
    }

    /* P25 affiliations (RIDs registered on the system) */
    {
        int is_p25p1 = (lls == 0 || lls == 1);
        int is_p25p2 = (lls == 35 || lls == 36);
        if (opts->show_p25_affiliations == 1 && (is_p25p1 || is_p25p2)) {
            ui_print_header("P25 Affiliations");
            // Compose a recent-first list of up to 20 RIDs
            int idxs[256];
            int n = 0;
            time_t now = time(NULL);
            for (int i = 0; i < 256; i++) {
                if (state->p25_aff_rid[i] != 0) {
                    idxs[n++] = i;
                }
            }
            // Selection sort by last_seen desc (n is typically small)
            for (int i = 0; i < n; i++) {
                int best = i;
                for (int j = i + 1; j < n; j++) {
                    if (state->p25_aff_last_seen[idxs[j]] > state->p25_aff_last_seen[idxs[best]]) {
                        best = j;
                    }
                }
                if (best != i) {
                    int tmp = idxs[i];
                    idxs[i] = idxs[best];
                    idxs[best] = tmp;
                }
            }
            int shown = 0;
            int rows = 0, cols = 80;
            getmaxyx(stdscr, rows, cols);
            (void)rows;
            if (cols < 1) {
                cols = 80;
            }
            // Track the current line width after the left border
            int line_used = 0;
            for (int i = 0; i < n && shown < 20; i++) {
                int k = idxs[i];
                uint32_t rid = state->p25_aff_rid[k];
                long age = (long)((state->p25_aff_last_seen[k] != 0) ? (now - state->p25_aff_last_seen[k]) : 0);
                if (age < 0) {
                    age = 0;
                }
                char buf[64];
                int m = snprintf(buf, sizeof buf, "RID:%u age:%lds", (unsigned)rid, age);
                if (m < 0) {
                    m = 0;
                }
                int sep = (line_used == 0) ? 0 : 4; // spacing between columns
                // If this is the first item on the line, account for "| " at line start
                int left_border = (line_used == 0) ? 2 : 0;
                if ((left_border + line_used + sep + m) > cols) {
                    // New line and reset tracking
                    if (line_used > 0) {
                        addch('\n');
                    }
                    line_used = 0;
                }
                if (line_used == 0) {
                    ui_print_lborder_green();
                    addch(' ');
                } else {
                    addstr("    ");
                }
                addnstr(buf, m);
                line_used += ((line_used == 0) ? 0 : sep) + m;
                shown++;
            }
            if (shown > 0 && line_used > 0) {
                addch('\n');
            }
            if (shown == 0) {
                ui_print_lborder_green();
                addstr(" (none)\n");
            }
            ui_print_hr();
        }
    }

    /* P25 Group Affiliation (RID ↔ TG) */
    {
        int is_p25p1 = (lls == 0 || lls == 1);
        int is_p25p2 = (lls == 35 || lls == 36);
        if (opts->show_p25_group_affiliations == 1 && (is_p25p1 || is_p25p2)) {
            ui_print_header("P25 Group Affiliation");
            int idxs[512];
            int n = 0;
            time_t now = time(NULL);
            for (int i = 0; i < 512; i++) {
                if (state->p25_ga_rid[i] != 0 && state->p25_ga_tg[i] != 0) {
                    idxs[n++] = i;
                }
            }
            for (int i = 0; i < n; i++) {
                int best = i;
                for (int j = i + 1; j < n; j++) {
                    if (state->p25_ga_last_seen[idxs[j]] > state->p25_ga_last_seen[idxs[best]]) {
                        best = j;
                    }
                }
                if (best != i) {
                    int tmp = idxs[i];
                    idxs[i] = idxs[best];
                    idxs[best] = tmp;
                }
            }
            int shown = 0;
            int rows = 0, cols = 80;
            getmaxyx(stdscr, rows, cols);
            (void)rows;
            if (cols < 1) {
                cols = 80;
            }
            int line_used = 0;
            for (int i = 0; i < n && shown < 20; i++) {
                int k = idxs[i];
                uint32_t rid = state->p25_ga_rid[k];
                uint16_t tg = state->p25_ga_tg[k];
                long age = (long)((state->p25_ga_last_seen[k] != 0) ? (now - state->p25_ga_last_seen[k]) : 0);
                if (age < 0) {
                    age = 0;
                }
                char buf[80];
                int m = snprintf(buf, sizeof buf, "RID:%u TG:%u age:%lds", (unsigned)rid, (unsigned)tg, age);
                if (m < 0) {
                    m = 0;
                }
                int sep = (line_used == 0) ? 0 : 4;
                int left_border = (line_used == 0) ? 2 : 0;
                if ((left_border + line_used + sep + m) > cols) {
                    if (line_used > 0) {
                        addch('\n');
                    }
                    line_used = 0;
                }
                if (line_used == 0) {
                    ui_print_lborder_green();
                    addch(' ');
                } else {
                    addstr("    ");
                }
                addnstr(buf, m);
                line_used += ((line_used == 0) ? 0 : sep) + m;
                shown++;
            }
            if (shown > 0 && line_used > 0) {
                addch('\n');
            }
            if (shown == 0) {
                ui_print_lborder_green();
                addstr(" (none)\n");
            }
            ui_print_hr();
        }
    }

    ui_print_header("Call Info");

    //DSTAR
    if (lls == 6 || lls == 7 || lls == 18 || lls == 19) {
        printw("| %s ", SyncTypes[lls]);
        printw("\n");
        printw("| RPT2: %s", state->dstar_rpt2);
        printw(" RPT1: %s", state->dstar_rpt1);
        printw("\n");
        printw("| DEST: %s", state->dstar_dst);
        printw("  SRC: %s", state->dstar_src);
        printw("\n");
        printw("| TEXT: %s", state->dstar_txt);
        printw("\n");
        printw("| DATA: %s", state->dstar_gps);
        printw("\n");
    }

    //M17
    if (lls == 8 || lls == 9 || lls == 16 || lls == 17) {

        printw("| ");
        printw("M17: ");

        //insert data type and frame information
        if (state->m17_str_dt == 0) {
            printw("Reserved");
        }
        if (state->m17_str_dt == 1) {
            printw("Data ");
        }
        if (state->m17_str_dt == 2) {
            printw("Voice (3200) ");
        }
        if (state->m17_str_dt == 3) {
            printw("Voice (1600) + Data");
        }

        printw("\n");
        printw("| ");

        printw("DST: ");
        if (state->m17_dst == 0xFFFFFFFFFFFF) {
            printw("BROADCAST ");
        } else if (state->m17_dst != 0 && state->m17_dst >= 0xEE6B28000000) {
            printw("RESERVED (%012llx) ", state->m17_dst);
        } else {
            printw("%s", state->m17_dst_str);
        }

        printw("\n");
        printw("| ");

        printw("SRC: ");
        if (state->m17_src != 0 && state->m17_src >= 0xEE6B28000000) {
            printw("RESERVED (%012llx)", state->m17_src);
        } else {
            printw("%s", state->m17_src_str);
        }

        printw("\n");
        printw("| ");

        printw("CAN: %02d ", state->m17_can);

        printw("\n");
        printw("| ");

        //fill in any extra info, like Meta (IV, etc)
        if (state->m17_enc == 1) {
            printw(" Scrambler - Type: %d", state->m17_enc_st);
        }

        if (state->m17_enc == 2) {
            attron(COLOR_PAIR(1));
            printw("AES-CTR - IV: ");
            //display packed meta as IV
            for (i = 0; i < 16; i++) {
                printw("%02X", state->m17_meta[i]);
            }
        }

        if (state->m17_enc == 3) {
            printw(" Reserved Enc - Type: %d", state->m17_enc_st);
        }

        printw("\n");
    }

    //YSF
    if (lls == 30 || lls == 31) {
        // printw ("\n");
        printw("| ");
        printw("Fusion - ");
        //insert data type and frame information
        if (state->ysf_dt == 0) {
            printw("V/D1 ");
        }
        if (state->ysf_dt == 1) {
            printw("DATA ");
        }
        if (state->ysf_dt == 2) {
            printw("V/D2 ");
        }
        if (state->ysf_dt == 3) {
            printw("VWFR ");
        }
        printw(" ");
        if (state->ysf_cm == 0) {
            printw("Group/CQ ");
        }
        if (state->ysf_cm == 3) {
            printw("Private  ");
        }
        if (state->ysf_cm == 1) {
            printw("Radio ID ");
        }
        if (state->ysf_cm == 2) {
            printw("Reserved ");
        }

        if (state->ysf_fi == 0) {
            printw("HC ");
        }
        if (state->ysf_fi == 1) {
            printw("CC ");
        }
        if (state->ysf_fi == 2) {
            printw("TC ");
        }
        if (state->ysf_fi == 3) {
            printw("XX ");
        }

        printw("\n");
        printw("| ");
        //NOTE: In Radio ID Mode, the DST will be split on Destination and Source Radio ID values
        printw("DST: %s ", state->ysf_tgt);
        printw("SRC: %s ", state->ysf_src);
        printw("\n");
        printw("| ");
        printw("UPL: %s ", state->ysf_upl);
        printw("DNL: %s ", state->ysf_dnl);
        printw("\n");
        printw("| ");
        printw("RM1: %s ", state->ysf_rm1);
        printw("RM2: %s ", state->ysf_rm2);
        printw("\n");
        printw("| ");
        printw("RM3: %s ", state->ysf_rm3);
        printw("RM4: %s ", state->ysf_rm4);

        //these texts can get pretty long and out of sorts, and lots of 0x20 spaces
        //just going to leave these to only be in the console output

        // printw ("\n");
        // printw ("| ");
        // printw ("TXT: ");
        // for (i = 4; i < 8; i++)
        // {
        //   for (int j = 0; j < 20; j++)
        //   {
        //     //no spaces and no asterisks
        //     if (state->ysf_txt[i][j] != 0x2A)
        //       printw ("%c", state->ysf_txt[i][j]);
        //   }
        //   // printw (" "); //just a single space between each 'block'
        // }

        printw("\n");
    }

    //NXDN
    if (lls == 28 || lls == 29) {
        if (strcmp(state->nxdn_location_category, "Type-D") == 0) {
            idas = 1;
        }

        if (opts->p25_trunk == 1) {

            printw("| ");
            if (opts->p25_is_tuned == 0) {
                if (idas == 0) {
                    printw("Monitoring RCCH Channel"); //Control Channel
                }
                if (idas == 1) {
                    printw("Monitoring RTCH2 Channel"); //Idas RTCH2 Channel
                }
                if (state->trunk_cc_freq != 0 || state->p25_cc_freq != 0) {
                    long f = (state->trunk_cc_freq != 0) ? state->trunk_cc_freq : state->p25_cc_freq;
                    printw(" - Frequency: %.06lf Mhz ", (double)f / 1000000);
                }
            } else if (opts->p25_is_tuned == 1) {
                if (idas == 0) {
                    printw("Monitoring RTCH Channel"); //Traffic Channel
                }
                if (idas == 1) {
                    printw("Monitoring RTCH2 Channel"); //Idas RTCH2
                }
                if (state->trunk_vc_freq[0] != 0 || state->p25_vc_freq[0] != 0) {
                    long f = (state->trunk_vc_freq[0] != 0) ? state->trunk_vc_freq[0] : state->p25_vc_freq[0];
                    printw(" - Frequency: %.06lf Mhz ", (double)f / 1000000);
                }
            }

            printw("\n");
        }

        printw("| ");
        // #ifdef LIMAZULUTWEAKS
        if (idas == 0) {
            printw("NXDN - RAN: %02d; ", state->nxdn_last_ran);
        }
        if (idas == 1) {
            printw("IDAS - Area: %02d; ", state->nxdn_last_ran);
        }
        // #else
        // if (idas == 0) printw ("NXDN - RAN: [%02d] ", rn);
        // if (idas == 1) printw ("IDAS - Area: [%02d] ", rn);
        // #endif
        if (state->nxdn_location_site_code != 0) {
            printw("Cat: %s; ", state->nxdn_location_category);
            printw("Sys Code: %d; ", state->nxdn_location_sys_code);
            printw("Site Code: %d; ", state->nxdn_location_site_code);
        }

        //if system supports Direct Frequency Assignment
        if (state->nxdn_rcn == 1) {
            printw("DFA ");
        }

        printw("\n");
        printw("| ");
        printw("TGT: [%5d] ", state->nxdn_last_tg);
        printw("SRC: [%5d] ", state->nxdn_last_rid);
        printw("Alias: [%s]", state->generic_talker_alias[0]);

        //Group Name Labels from CSV import
        for (unsigned int k = 0; k < state->group_tally; k++) {
            if (state->group_array[k].groupNumber == (unsigned long)state->nxdn_last_tg) {
                printw("TG: ");
                attron(COLOR_PAIR(4));
                printw(" [%s]", state->group_array[k].groupName);
                printw("[%s] ", state->group_array[k].groupMode);
            } else if (state->group_array[k].groupNumber == (unsigned long)state->nxdn_last_rid) {
                attron(COLOR_PAIR(4));
                printw(" [%s]", state->group_array[k].groupName);
            }
            if (state->carrier == 1) {
                attron(COLOR_PAIR(3));
            }
        }

        if (state->carrier == 1) {
            printw(" %s ", state->nxdn_call_type);
        }
        printw("\n|");
        if (state->nxdn_cipher_type > 0) {
            // printw (" ALG: %d Key ID: %02X ", state->nxdn_cipher_type, state->nxdn_key);
            printw(" ALG: %d Key ID: %02d ", state->nxdn_cipher_type, state->nxdn_key);
        }
        if (state->nxdn_cipher_type == 0x1 && state->carrier == 1) {
            if (state->R == 0) {
                attron(COLOR_PAIR(2));
            }
            printw("Scrambler ");
            if (state->R == 0) {
                attroff(COLOR_PAIR(2));
            }
            attron(COLOR_PAIR(3));
            if (state->R != 0) {
                attron(COLOR_PAIR(1));
                printw("Seed: %04llX ", state->payload_miN);
                printw("Key: %05lld ", state->R);
                attron(COLOR_PAIR(3));
            }
        }
        if (state->nxdn_cipher_type == 0x2 && state->carrier == 1) {
            attron(COLOR_PAIR(1));
            printw("IV: %016llX ", state->payload_miN);
            attron(COLOR_PAIR(2));
            printw("DES1 ");
            if (state->R != 0) {
                printw("Key: %016llX ", state->R);
            }
            attroff(COLOR_PAIR(2));
            attron(COLOR_PAIR(3));
        }
        if (state->nxdn_cipher_type == 0x3 && state->carrier == 1) {
            attron(COLOR_PAIR(1));
            printw("IV: %016llX ", state->payload_miN);
            attron(COLOR_PAIR(2));
            printw("AES-256 ");
            if (state->aes_key_loaded[0] == 1) {
                printw("KS: %016llX", state->A4[0]);
            }
            attroff(COLOR_PAIR(2));
            attron(COLOR_PAIR(3));
        }
        if (state->nxdn_cipher_type > 0x3 && state->carrier == 1) {
            attron(COLOR_PAIR(2));
            printw("Unknown Encryption ");
            attroff(COLOR_PAIR(2));
            attron(COLOR_PAIR(3));
        }

        //Active Trunking Channels (NXDN and IDAS)
        if (1 == 1) //opts->p25_trunk
        {
            printw("\n");
            printw("| ");

            //active channel display
            attron(COLOR_PAIR(4));
            for (int i = 0; i < 16; i++) {
                if (state->active_channel[i][0] != '\0') {
                    const char* s = state->active_channel[i];
                    int locked = ui_is_locked_from_label(state, s);
                    /* Also show disabled classes (global toggles) in red */
                    if (!locked && opts) {
                        if (opts->trunk_tune_data_calls == 0 && strstr(s, "Active Data Ch:") != NULL) {
                            locked = 1;
                        }
                        if (!locked && opts->trunk_tune_group_calls == 0 && strstr(s, "TG:") != NULL) {
                            locked = 1;
                        }
                        if (!locked && opts->trunk_tune_private_calls == 0 && strstr(s, "TGT:") != NULL) {
                            locked = 1;
                        }
                    }
                    if (locked) {
                        // Highlight locked-out TGs in red
                        attron(COLOR_PAIR(2));
                        printw("%s", s);
                        attron(COLOR_PAIR(4)); // restore cyan for subsequent items
                    } else {
                        printw("%s", s);
                    }
                }
            }

            if (state->carrier == 1) {
                attron(COLOR_PAIR(3));
            } else {
                /* When no active call, keep UI in idle cyan instead of default white */
                attron(COLOR_PAIR(4));
            }
        }

        //TG Hold, if specified by user
        if (state->tg_hold != 0) {
            printw("TG HOLD: %d", state->tg_hold);
        }

        printw("\n");
    }

    //P25 and DMR BS/MS
    if (lls == 0 || lls == 1 || lls == 12 || lls == 13 || lls == 10 || lls == 11 || lls == 32 || lls == 33 || lls == 34
        || lls == 35 || lls == 36) {
        printw("| ");
        if (lls > 1 && lls < 30) {
            printw("DMR BS - DCC: %02i; ", state->dmr_color_code);
            // printw ("%s %s", state->dmr_branding, state->dmr_branding_sub);
            printw("%s ", state->dmr_branding);
            printw("%s", state->dmr_branding_sub);
            printw("%s", state->dmr_site_parms); //site id, net id, etc
            if (state->dmr_rest_channel > 0) {
                printw("Rest LSN: %02d; ", state->dmr_rest_channel);
                if (state->trunk_chan_map[state->dmr_rest_channel] != 0) {
                    printw("Freq: %.06lf Mhz", (double)state->trunk_chan_map[state->dmr_rest_channel] / 1000000);
                }
            } else if (state->trunk_cc_freq != 0 || state->p25_cc_freq != 0) {
                long f = (state->trunk_cc_freq != 0) ? state->trunk_cc_freq : state->p25_cc_freq;
                printw("Freq: %.06lf MHz", (double)f / 1000000);
            }

        } else if (lls == 32 || lls == 33 || lls == 34) {
            printw("DMR MS - DCC: %02i; ", state->dmr_color_code);
        } else if (lls == 0 || lls == 1) //P1
        {
            // Clarify identifiers to avoid confusion when SYSID and NAC
            // happen to have the same numeric value on some systems.
            printw("P25p1  - WACN: %05llX SYS: %03llX NAC: %03llX; RFSS: %lld SITE: %lld ", state->p2_wacn,
                   state->p2_sysid, state->p2_cc, state->p2_rfssid, state->p2_siteid);
            if (state->trunk_cc_freq != 0 || state->p25_cc_freq != 0) {
                long f = (state->trunk_cc_freq != 0) ? state->trunk_cc_freq : state->p25_cc_freq;
                printw("FREQ: %.06lf MHz", (double)f / 1000000);
            }

            //load talker aliases here (Moto, Tait, Harris)
            for (unsigned int i = 0; i < state->group_tally; i++) {
                if (state->group_array[i].groupNumber == (unsigned long)state->lastsrc) //or state->lastsrc
                {
                    snprintf(state->generic_talker_alias[0], sizeof state->generic_talker_alias[0], "%s",
                             state->group_array[i].groupName);
                    break;
                }
            }

        } else if (lls == 35 || lls == 36) //P2
        {
            // Clarify identifiers to avoid confusion when SYSID and NAC
            // happen to have the same numeric value on some systems.
            printw("P25p2  - WACN: %05llX SYS: %03llX NAC: %03llX; RFSS: %lld SITE: %lld ", state->p2_wacn,
                   state->p2_sysid, state->p2_cc, state->p2_rfssid, state->p2_siteid);
            if (state->p2_wacn == 0 || state->p2_sysid == 0 || state->p2_cc == 0) {
                attron(COLOR_PAIR(2));
                printw(" Phase 2 Missing Parameters ");
                attron(COLOR_PAIR(3));
            } else if (state->p2_wacn == 0xFFFFF || state->p2_sysid == 0xFFF || state->p2_cc == 0xFFF) {
                attron(COLOR_PAIR(2));
                printw(" Phase 2 Invalid Parameters ");
                attron(COLOR_PAIR(3));
            } else {
                if (state->trunk_cc_freq != 0 || state->p25_cc_freq != 0) {
                    long f = (state->trunk_cc_freq != 0) ? state->trunk_cc_freq : state->p25_cc_freq;
                    printw("FREQ: %.06lf MHz", (double)f / 1000000);
                }
            }

            //load talker aliases here (Moto, Tait, Harris)
            for (unsigned int i = 0; i < state->group_tally; i++) {
                if (state->group_array[i].groupNumber == (unsigned long)state->lastsrc) {
                    snprintf(state->generic_talker_alias[0], sizeof state->generic_talker_alias[0], "%s",
                             state->group_array[i].groupName);
                    break;
                }
            }

            //load talker aliases here (Moto, Tait, Harris)
            for (unsigned int i = 0; i < state->group_tally; i++) {
                if (state->group_array[i].groupNumber == (unsigned long)state->lastsrcR) {
                    snprintf(state->generic_talker_alias[1], sizeof state->generic_talker_alias[1], "%s",
                             state->group_array[i].groupName);
                    break;
                }
            }
        }

        printw("\n");
        //Slot 1 [0]
        printw("| SLOT 1 - ");
        if (state->dmrburstL < 16 && state->carrier == 1 && state->lasttg > 0 && state->lastsrc > 0) {
            attron(COLOR_PAIR(2));
        }
        // Only show IDs when the left slot is actively in a call; otherwise avoid stale values
        // Active when:
        //  - DMR voice (16)
        //  - P25p2: PTT/VOICE/HANGTIME (20/21/22)
        //  - P25p1 voice frames (26/27)
        int show_l_ids = (state->dmrburstL == 16) || (state->dmrburstL >= 20 && state->dmrburstL <= 22)
                         || (state->dmrburstL == 26) || (state->dmrburstL == 27);
        if (show_l_ids) {
            printw("TGT: [%8i] SRC: [%8i] ", state->lasttg, state->lastsrc);
            // P25 call flags: show [EM] and [PR:n] when active
            if (state->p25_call_emergency[0]) {
                printw("[EM] ");
            }
            if (state->p25_call_priority[0] > 0) {
                printw("[PR:%d] ", (int)state->p25_call_priority[0]);
            }
        } else {
            // Blank out IDs cleanly when slot 1 is not in an active call
            printw("TGT: [        ] SRC: [        ] ");
        }
        if (state->dmrburstL != 16 && state->carrier == 1 && state->lasttg > 0 && state->lastsrc > 0) {
            attroff(COLOR_PAIR(2));
            attron(COLOR_PAIR(3));
        }

        // Show banner only when actively in a call; otherwise blank to avoid stale labels
        if (show_l_ids) {
            printw("%s | ", state->call_string[0]);
        } else {
            printw("%s | ", "                     "); // 21 spaces
        }
        printw("%s ", DMRBusrtTypes[state->dmrburstL]);

        if (opts->slot_preference == 1 && opts->audio_out_type == 5 && opts->audio_out == 1
            && (state->dmrburstL == 16 || state->dmrburstL == 21)
            && (state->dmrburstR == 16 || state->dmrburstR == 21)) {
            printw("*M*");
        }

        printw("\n");

        printw("| V XTRA | "); //10 spaces

        if (state->dmrburstL == 16 && state->payload_algid == 0
            && state->dmr_so & 0x40) //4F or CF mask? & 0xCF currently //&& (state->dmr_so & 0xCF) == 0x40
        {
            attron(COLOR_PAIR(5));
            printw(" **BP** ");
            attroff(COLOR_PAIR(5));
            attron(COLOR_PAIR(3));
        }

        if (state->dmrburstL == 16 && state->payload_algid == 0 && state->K > 0 && state->dmr_fid == 0x10
            && state->dmr_so & 0x40) {
            attron(COLOR_PAIR(1));
            printw("BP Key: %3lld ", state->K);
            attroff(COLOR_PAIR(1));
            attron(COLOR_PAIR(3));
        }

        if (state->dmrburstL == 16 && state->payload_algid == 0 && state->H > 0 && state->dmr_fid == 0x68
            && state->dmr_so & 0x40) {
            attron(COLOR_PAIR(1));
            printw("Hytera BP Key: %010llX ", state->H);
            attroff(COLOR_PAIR(1));
            attron(COLOR_PAIR(3));
        }

        //ALG, KeyID, MI                            //was key_id
        if (state->dmrburstL == 16 && state->payload_algid > 0 && state->dmr_so & 0x40) {
            attron(COLOR_PAIR(1));
            printw("ALG: 0x%02X KEY: 0x%02X MI: 0x%08llX ", state->payload_algid, state->payload_keyid,
                   state->payload_mi);
            attroff(COLOR_PAIR(1));
            attron(COLOR_PAIR(3));
        }

        //P25 FDMA/TDMA
        if (state->dmrburstL > 19 && state->payload_algid > 0 && state->payload_algid != 0x80) {
            attron(COLOR_PAIR(1));
            printw("ALG: 0x%02X KEY: 0x%04X MI: 0x%016llX ", state->payload_algid, state->payload_keyid,
                   state->payload_miP);
            attroff(COLOR_PAIR(1));
            attron(COLOR_PAIR(3));
        }

        //Anytone 0x01 will never show here since its converted to 0x21 for handling
        if (state->payload_algid == 0xAA || state->payload_algid == 0x21 || state->payload_algid == 0x01) {
            attron(COLOR_PAIR(1));
            printw("RC4 ");
            if (state->R != 0) {
                printw("Key: %010llX ", state->R);
            }
            attron(COLOR_PAIR(3));
        }
        if (state->payload_algid == 0x81 || state->payload_algid == 0x22) {
            attron(COLOR_PAIR(1));
            printw("DES1 ");
            if (state->R != 0) {
                printw("Key: %010llX ", state->R);
            }
            attron(COLOR_PAIR(3));
        }
        if (state->payload_algid == 0x9F) {
            attron(COLOR_PAIR(1));
            printw("DES-XL ");
            if (state->R != 0) {
                printw("Key: %010llX ", state->R);
            }
            attron(COLOR_PAIR(3));
        }
        if (state->payload_algid == 0x82) {
            attron(COLOR_PAIR(1));
            printw("DES2 ");
            attron(COLOR_PAIR(3));
        }
        if (state->payload_algid == 0x83) {
            attron(COLOR_PAIR(1));
            printw("DES3 ");
            attron(COLOR_PAIR(3));
        }
        if (state->payload_algid == 0x89 || state->payload_algid == 0x24) {
            attron(COLOR_PAIR(1));
            printw("AES-128 ");
            if (state->aes_key_loaded[0] != 0) {
                printw("KS: %016llX ", state->A2[0]);
            }
            attron(COLOR_PAIR(3));
        }
        if (state->payload_algid == 0x84 || state->payload_algid == 0x25 || state->payload_algid == 0x05) {
            attron(COLOR_PAIR(1));
            printw("AES-256 ");
            if (state->aes_key_loaded[0] != 0) {
                printw("KS: %016llX ", state->A4[0]);
            }
            attron(COLOR_PAIR(3));
        }
        if (state->payload_algid == 0x02) {
            attron(COLOR_PAIR(1));
            printw("Hytera Enhanced");
            if (state->R != 0) {
                printw(" Key: %010llX", state->R);
            }
            attron(COLOR_PAIR(3));
        }

        printw("\n");

        //printw ("|        | "); //10 spaces
        printw("| D XTRA | ");

        attron(COLOR_PAIR(4));

        if (state->dmrburstL == 16 || state->dmrburstL == 21 || state->dmrburstL == 26 || state->dmrburstL == 27
            || state->dmrburstL == 32) //only during call
        {

            attron(COLOR_PAIR(4));

            //Embedded GPS (not LRRP)
            printw("%s ", state->dmr_embedded_gps[0]);

            //Embedded Talker Alias String (show when present during active call)
            if (state->generic_talker_alias[0][0] != '\0') {
                printw("%s ", state->generic_talker_alias[0]);
            }

            attroff(COLOR_PAIR(5));
            if (state->carrier == 1) {
                attron(COLOR_PAIR(3));
            }
        }

        //LRRP
        if (state->dmrburstL != 16) //only during data and no trunking
        {
            attron(COLOR_PAIR(4));
            printw("%s", state->dmr_lrrp_gps[0]);
        }

        //Group Name Labels from CSV import
        if (state->dmrburstL == 16 || state->dmrburstL > 19) {
            for (unsigned int k = 0; k < state->group_tally; k++) {
                if (state->group_array[k].groupNumber == (unsigned long)state->lasttg) {
                    attron(COLOR_PAIR(4));
                    printw(" [%s]", state->group_array[k].groupName);
                    printw("[%s] ", state->group_array[k].groupMode);
                    if (state->carrier == 1) {
                        attron(COLOR_PAIR(3));
                    }
                }
            }
        }

        if (state->carrier == 1) {
            attron(COLOR_PAIR(3));
        } else {
            /* Restore idle cyan after extras when carrier drops */
            attron(COLOR_PAIR(4));
        }

        printw("\n");

        //Slot 2 [1] -- Also Including DMR MS now to keep the display more 'uniform' in nature
        // if (lls < 30 || lls == 35 || lls == 36)
        {
            printw("| SLOT 2 - ");
            if (state->dmrburstR < 16 && state->carrier == 1 && state->lasttgR > 0 && state->lastsrcR > 0) {
                attron(COLOR_PAIR(2));
            }
            // Only show IDs when the right slot is actively in a call; otherwise avoid stale values
            // Active when:
            //  - DMR voice (16)
            //  - P25p2: PTT/VOICE/HANGTIME (20/21/22)
            //  - P25p1 voice frames (26/27) [right slot used for MS/dual displays]
            int show_r_ids = (state->dmrburstR == 16) || (state->dmrburstR >= 20 && state->dmrburstR <= 22)
                             || (state->dmrburstR == 26) || (state->dmrburstR == 27);
            if (show_r_ids) {
                printw("TGT: [%8i] SRC: [%8i] ", state->lasttgR, state->lastsrcR);
                // P25 call flags for right slot
                if (state->p25_call_emergency[1]) {
                    printw("[EM] ");
                }
                if (state->p25_call_priority[1] > 0) {
                    printw("[PR:%d] ", (int)state->p25_call_priority[1]);
                }
            } else {
                // Blank out IDs cleanly when slot 2 is not in an active call
                printw("TGT: [        ] SRC: [        ] ");
            }
            if (state->dmrburstR != 16 && state->carrier == 1 && state->lasttgR > 0 && state->lastsrcR > 0) {
                attroff(COLOR_PAIR(2));
                attron(COLOR_PAIR(3));
            }

            // Show banner only during active call states on slot 2
            if (show_r_ids) {
                printw("%s | ", state->call_string[1]);
            } else {
                printw("%s | ", "                     "); // 21 spaces
            }
            printw("%s ", DMRBusrtTypes[state->dmrburstR]);

            if (opts->slot_preference == 0 && opts->audio_out_type == 5 && opts->audio_out == 1
                && (state->dmrburstL == 16 || state->dmrburstL == 21)
                && (state->dmrburstR == 16 || state->dmrburstR == 21)) {
                printw("*M*");
            }

            printw("\n");

            printw("| V XTRA | "); //10 spaces

            if (state->dmrburstR == 16 && state->payload_algidR == 0 && state->dmr_soR & 0x40) //4F or CF mask?
            {
                attron(COLOR_PAIR(5));
                printw(" **BP** ");
                attroff(COLOR_PAIR(5));
                attron(COLOR_PAIR(3));
            }

            if (state->dmrburstR == 16 && state->payload_algidR == 0 && state->K > 0 && state->dmr_soR & 0x40
                && state->dmr_fidR == 0x10) {
                attron(COLOR_PAIR(1));
                printw("BP Key: %3lld ", state->K);
                attroff(COLOR_PAIR(1));
                attron(COLOR_PAIR(3));
            }
            if (state->dmrburstR == 16 && state->payload_algidR == 0 && state->H > 0 && state->dmr_soR & 0x40
                && state->dmr_fidR == 0x68) {
                attron(COLOR_PAIR(1));
                printw("Hytera BP Key: %010llX ", state->H);
                attroff(COLOR_PAIR(1));
                attron(COLOR_PAIR(3));
            }
            //ALG, KeyID, MI 2                          //was keyidR
            if (state->dmrburstR == 16 && state->payload_algidR > 0 && state->dmr_soR & 0x40) {
                attron(COLOR_PAIR(1));
                printw("ALG: 0x%02X KEY: 0x%02X MI: 0x%08llX ", state->payload_algidR, state->payload_keyidR,
                       state->payload_miR);
                attroff(COLOR_PAIR(1));
                attron(COLOR_PAIR(3));
            }
            //P25-P1 and P2
            if (state->dmrburstR > 19 && state->payload_algidR > 0 && state->payload_algidR != 0x80) {
                attron(COLOR_PAIR(1));
                printw("ALG: 0x%02X KEY: 0x%04X MI: 0x%016llX ", state->payload_algidR, state->payload_keyidR,
                       state->payload_miN);
                attroff(COLOR_PAIR(1));
                attron(COLOR_PAIR(3));
            }

            //Anytone 0x01 will never show here since its converted to 0x21 for handling
            if (state->payload_algidR == 0xAA || state->payload_algidR == 0x21 || state->payload_algidR == 0x01) {
                attron(COLOR_PAIR(1));
                printw("RC4 ");
                if (state->RR != 0) {
                    printw("Key: %010llX ", state->RR);
                }
                attron(COLOR_PAIR(3));
            }
            if (state->payload_algidR == 0x81 || state->payload_algidR == 0x22) {
                attron(COLOR_PAIR(1));
                printw("DES1 ");
                if (state->RR != 0) {
                    printw("Key: %010llX ", state->RR);
                }
                attron(COLOR_PAIR(3));
            }
            if (state->payload_algidR == 0x9F) {
                attron(COLOR_PAIR(1));
                printw("DES-XL ");
                if (state->RR != 0) {
                    printw("Key: %010llX ", state->RR);
                }
                attron(COLOR_PAIR(3));
            }
            if (state->payload_algidR == 0x82) {
                attron(COLOR_PAIR(1));
                printw("DES2 ");
                attron(COLOR_PAIR(3));
            }
            if (state->payload_algidR == 0x83) {
                attron(COLOR_PAIR(1));
                printw("DES3 ");
                attron(COLOR_PAIR(3));
            }
            if (state->payload_algidR == 0x89 || state->payload_algidR == 0x24) {
                attron(COLOR_PAIR(1));
                printw("AES-128 ");
                if (state->aes_key_loaded[1] != 0) {
                    printw("KS: %016llX ", state->A2[1]);
                }
                attron(COLOR_PAIR(3));
            }
            if (state->payload_algidR == 0x84 || state->payload_algidR == 0x25 || state->payload_algidR == 0x05) {
                attron(COLOR_PAIR(1));
                printw("AES-256 ");
                if (state->aes_key_loaded[1] != 0) {
                    printw("KS: %016llX ", state->A4[1]);
                }
                attron(COLOR_PAIR(3));
            }
            if (state->payload_algidR == 0x02) {
                attron(COLOR_PAIR(1));
                printw("Hytera Enhanced");
                if (state->RR != 0) {
                    printw(" Key: %010llX", state->RR);
                }
                attron(COLOR_PAIR(3));
            }

            printw("\n");

            //printw ("|        | ");
            printw("| D XTRA | ");

            attron(COLOR_PAIR(4));

            if (state->dmrburstR == 16 || state->dmrburstR == 21) //only during call
            {

                //Embedded GPS (not LRRP)
                attron(COLOR_PAIR(4));
                printw("%s ", state->dmr_embedded_gps[1]);

                //Embedded Talker Alias String (show when present during active call)
                if (state->generic_talker_alias[1][0] != '\0') {
                    printw("%s ", state->generic_talker_alias[1]);
                }

                attroff(COLOR_PAIR(5));
                if (state->carrier == 1) {
                    attron(COLOR_PAIR(3));
                }
            }

            //LRRP
            if (state->dmrburstR != 16) //only during data and no trunking
            {
                attron(COLOR_PAIR(4));
                printw("%s", state->dmr_lrrp_gps[1]);
            }

            //Group Name Labels from CSV import
            if (state->dmrburstR == 16 || state->dmrburstR > 19) {
                for (unsigned int k = 0; k < state->group_tally; k++) {
                    if (state->group_array[k].groupNumber == (unsigned long)state->lasttgR) {
                        attron(COLOR_PAIR(4));
                        printw(" [%s]", state->group_array[k].groupName);
                        printw("[%s] ", state->group_array[k].groupMode);
                    }
                    if (state->carrier == 1) {
                        attron(COLOR_PAIR(3));
                    }
                }
            }

            if (state->carrier == 1) {
                attron(COLOR_PAIR(3));
            } else {
                /* Keep cyan when idle to avoid white fallback */
                attron(COLOR_PAIR(4));
            }

            printw("\n");

            if (1 == 1) //opts->p25_trunk == 1
            {
                printw("|        | "); //Active Trunking Channels

                //active channel display
                attron(COLOR_PAIR(4));
                for (unsigned int i = 0; i < 31; i++) //up to 31 idas channels
                {
                    if (state->active_channel[i][0] != '\0') {
                        const char* s = state->active_channel[i];
                        int locked = ui_is_locked_from_label(state, s);
                        /* Also show disabled classes (global toggles) in red */
                        if (!locked && opts) {
                            if (opts->trunk_tune_data_calls == 0 && strstr(s, "Active Data Ch:") != NULL) {
                                locked = 1;
                            }
                            if (!locked && opts->trunk_tune_group_calls == 0 && strstr(s, "TG:") != NULL) {
                                locked = 1;
                            }
                            if (!locked && opts->trunk_tune_private_calls == 0 && strstr(s, "TGT:") != NULL) {
                                locked = 1;
                            }
                        }
                        if (locked) {
                            attron(COLOR_PAIR(2));
                            printw("%s", s);
                            attron(COLOR_PAIR(4));
                        } else {
                            printw("%s", s);
                        }
                    }
                }

                if (state->carrier == 1) {
                    attron(COLOR_PAIR(3));
                } else {
                    /* Keep cyan when idle to avoid white fallback */
                    attron(COLOR_PAIR(4));
                }
                printw("\n");
            }

            if (opts->p25_trunk == 1) {
                printw("|        | "); //Currently Tuned Frequency

                // Only render VC frequency when tuned off CC (on a voice/data channel)
                if (opts->p25_is_tuned == 1) {
                    // Tuned/Active Frequency Display: prefer tuned VC; else derive from active channel text/map
                    long int vc = (state->trunk_vc_freq[0] != 0) ? state->trunk_vc_freq[0] : state->p25_vc_freq[0];
                    if (vc == 0) {
                        vc = ui_guess_active_vc_freq(state);
                    }
                    if (vc != 0) {
                        attron(COLOR_PAIR(4));
                        printw("Frequency: %.06lf MHz  ", (double)vc / 1000000);
                    }
                }

                //TG Hold, if specified by user
                if (state->tg_hold != 0) {
                    printw("TG HOLD: %d", state->tg_hold);
                }

                if (state->carrier == 1) {
                    attron(COLOR_PAIR(3));
                } else {
                    /* Keep cyan when idle to avoid white fallback */
                    attron(COLOR_PAIR(4));
                }
                printw("\n");
            }

        } // end if not MS
    } //end DMR BS Types

    //dPMR
    if (lls == 20 || lls == 21 || lls == 22 || lls == 23 || lls == 24 || lls == 25 || lls == 26 || lls == 27) {
        printw("| DCC: [%i] ", state->dpmr_color_code);
        printw("TGT: [%s] SRC: [%s] ", state->dpmr_target_id, state->dpmr_caller_id);
        printw("\n| ");
        if (state->dPMRVoiceFS2Frame.Version[0] == 3) {
            attron(COLOR_PAIR(2));
            printw("Scrambler ");
            attroff(COLOR_PAIR(2));
            attron(COLOR_PAIR(3));
            if (state->R != 0) {
                attron(COLOR_PAIR(1));
                printw("KEY VALUE: [%05lld] ", state->R);
                //printw ("SEED: [%04llX]", state->payload_miN);
                attron(COLOR_PAIR(3));
            }
        }
        printw("\n");
    }

    //EDACS and ProVoice
    if (lls == 14 || lls == 15 || lls == 37 || lls == 38) {
        attroff(COLOR_PAIR(3)); //colors off for EDACS
        if (state->edacs_site_id != 0) {
            if (opts->trunk_is_tuned == 0 && opts->p25_is_tuned == 0) {
                printw("| Monitoring CC - LCN [%02d]\n", state->edacs_cc_lcn);
            } else {
                printw("| Monitoring VC - LCN [%02d]\n", state->edacs_tuned_lcn);
                //since we are tuned, keep updating the time so it doesn't disappear during call
                edacs_channel_tree[state->edacs_tuned_lcn][5] = time(NULL);
            }
            printw("| SITE [%03lld][%02llX]", state->edacs_site_id, state->edacs_site_id);

            if (state->ea_mode == 1) {
                printw(" Extended Addressing");
            } else {
                printw(" Standard/Networked");
            }
            if (state->esk_mask == 0xA0) {
                printw(" w/  ESK");
            } else {
                printw(" w/o ESK");
            }
            printw("\n");
        }
        for (i = 1; i <= state->edacs_lcn_count; i++) {
            // Compute AFS for display purposes only
            int a = (edacs_channel_tree[i][2] >> state->edacs_a_shift) & state->edacs_a_mask;
            int f = (edacs_channel_tree[i][2] >> state->edacs_f_shift) & state->edacs_f_mask;
            int s = edacs_channel_tree[i][2] & state->edacs_s_mask;
            printw("| - LCN [%02d][%010.06lf] MHz", i, (double)state->trunk_lcn_freq[i - 1] / 1000000);

            //print Control Channel on LCN line with the current Control Channel
            if ((i) == state->edacs_cc_lcn) {
                attron(COLOR_PAIR(1)); //yellow
                printw(" Control Channel");
                attroff(COLOR_PAIR(1));
            }

            int print_call = 0;
            //print active calls on corresponding LCN line
            if ((i != state->edacs_cc_lcn) && time(NULL) - edacs_channel_tree[i][5] < 2) {
                print_call = 3;
                attron(COLOR_PAIR(3));
            }
            //print dying or dead calls in red for x seconds longer
            else if ((i != state->edacs_cc_lcn) && (time(NULL) - edacs_channel_tree[i][5] >= 2)
                     && (time(NULL) - edacs_channel_tree[i][5] < 5)) {
                print_call = 2;
                attron(COLOR_PAIR(2));
            }

            if (print_call != 0) {
                if (state->ea_mode == 1) {
                    // Voice call
                    if ((edacs_channel_tree[i][4] & EDACS_IS_VOICE) != 0) {
                        // Group call
                        if ((edacs_channel_tree[i][4] & EDACS_IS_GROUP) != 0) {
                            printw(" TGT [%8lld] SRC [%8lld]", edacs_channel_tree[i][2], edacs_channel_tree[i][3]);
                        }
                        // I-Call
                        else if ((edacs_channel_tree[i][4] & EDACS_IS_INDIVIDUAL) != 0) {
                            printw(" TGT [%8lld] SRC [%8lld] I-Call", edacs_channel_tree[i][2],
                                   edacs_channel_tree[i][3]);
                        }
                        // System all-call
                        else if ((edacs_channel_tree[i][4] & EDACS_IS_ALL_CALL) != 0) {
                            printw(" TGT [ SYSTEM ] SRC [%8lld] All-Call", edacs_channel_tree[i][3]);
                        }
                        // Interconnect call
                        else if ((edacs_channel_tree[i][4] & EDACS_IS_INTERCONNECT) != 0) {
                            printw(" TGT [ SYSTEM ] SRC [%8lld] Interconnect", edacs_channel_tree[i][3]);
                        }
                        // Test call
                        else if ((edacs_channel_tree[i][4] & EDACS_IS_TEST_CALL) != 0) {
                            printw(" TGT [ SYSTEM ] SRC [ SYSTEM ] Test Call");
                        }
                        // Unknown call
                        else {
                            printw(" Unknown call type");
                        }

                        // Call flags
                        if ((edacs_channel_tree[i][4] & EDACS_IS_TEST_CALL) != 0) {
                        } else if ((edacs_channel_tree[i][4] & EDACS_IS_DIGITAL) == 0) {
                            printw(" [Ana]");
                        } else {
                            printw(" [Dig]");
                        }
                        if ((edacs_channel_tree[i][4] & EDACS_IS_EMERGENCY) != 0) {
                            printw("[EM]");
                        }
                    } else {
                        // Data call
                        printw(" TGT [  DATA  ] SRC [%8lld] Data", edacs_channel_tree[i][3]);
                    }
                } else {
                    // Voice call
                    if ((edacs_channel_tree[i][4] & EDACS_IS_VOICE) != 0) {
                        // Group call
                        if ((edacs_channel_tree[i][4] & EDACS_IS_GROUP) != 0) {
                            char afs_str[8];
                            getAfsString(state, afs_str, a, f, s);
                            printw(" TGT [%6lld][%s] SRC [%5lld]", edacs_channel_tree[i][2], afs_str,
                                   edacs_channel_tree[i][3]);
                        }
                        // I-Call
                        else if ((edacs_channel_tree[i][4] & EDACS_IS_INDIVIDUAL) != 0) {
                            if (getAfsStringLength(state) == 6) {
                                printw(" TGT [%6lld][ UNIT ] SRC [%5lld] I-Call", edacs_channel_tree[i][2],
                                       edacs_channel_tree[i][3]);
                            } else {
                                printw(" TGT [%6lld][  UNIT ] SRC [%5lld] I-Call", edacs_channel_tree[i][2],
                                       edacs_channel_tree[i][3]);
                            }
                        }
                        // System all-call
                        else if ((edacs_channel_tree[i][4] & EDACS_IS_ALL_CALL) != 0) {
                            if (getAfsStringLength(state) == 6) {
                                printw(" TGT [    SYSTEM    ] SRC [%5lld] All-Call", edacs_channel_tree[i][3]);
                            } else {
                                printw(" TGT [     SYSTEM    ] SRC [%5lld] All-Call", edacs_channel_tree[i][3]);
                            }
                        }
                        // Interconnect call
                        else if ((edacs_channel_tree[i][4] & EDACS_IS_INTERCONNECT) != 0) {
                            if (getAfsStringLength(state) == 6) {
                                printw(" TGT [    SYSTEM    ] SRC [%5lld] Interconnect", edacs_channel_tree[i][3]);
                            } else {
                                printw(" TGT [     SYSTEM    ] SRC [%5lld] Interconnect", edacs_channel_tree[i][3]);
                            }
                        }
                        // Test call
                        else if ((edacs_channel_tree[i][4] & EDACS_IS_TEST_CALL) != 0) {
                            if (getAfsStringLength(state) == 6) {
                                printw(" TGT [    SYSTEM    ] SRC [ SYS ] Test Call");
                            } else {
                                printw(" TGT [     SYSTEM    ] SRC [ SYS ] Test Call");
                            }
                        }
                        // Unknown call
                        else {
                            printw(" Unknown call type");
                        }

                        // Call flags
                        if ((edacs_channel_tree[i][4] & EDACS_IS_TEST_CALL) != 0) {
                        } else if ((edacs_channel_tree[i][4] & EDACS_IS_DIGITAL) == 0) {
                            printw(" [Ana]");
                        } else {
                            printw(" [Dig]");
                        }
                        if ((edacs_channel_tree[i][4] & EDACS_IS_AGENCY_CALL) != 0) {
                            printw("[A]");
                        }
                        if ((edacs_channel_tree[i][4] & EDACS_IS_FLEET_CALL) != 0) {
                            printw("[F]");
                        }
                        if ((edacs_channel_tree[i][4] & EDACS_IS_EMERGENCY) != 0) {
                            printw("[EM]");
                        }
                    }
                    // Data call
                    else if (getAfsStringLength(state) == 6) {
                        printw(" TGT [     DATA     ] SRC [%5lld] Data", edacs_channel_tree[i][3]);
                    } else {
                        printw(" TGT [      DATA     ] SRC [%5lld] Data", edacs_channel_tree[i][3]);
                    }
                }
                for (unsigned int k = 0; k < state->group_tally; k++) {
                    if ((state->group_array[k].groupNumber == (unsigned long)edacs_channel_tree[i][2]
                         && edacs_channel_tree[i][2] != 0)
                        || (state->group_array[k].groupNumber == (unsigned long)edacs_channel_tree[i][3]
                            && edacs_channel_tree[i][3] != 0)) {
                        printw(" [%s]", state->group_array[k].groupName);
                        printw("[%s]", state->group_array[k].groupMode);
                        break;
                    }
                }

                if (print_call == 3) {
                    attroff(COLOR_PAIR(3));
                } else if (print_call == 2) {
                    attroff(COLOR_PAIR(2));
                }
            }

            if (i == state->edacs_tuned_lcn && (opts->trunk_is_tuned == 1 || opts->p25_is_tuned == 1)) {
                printw(" **T**"); //asterisk which lcn is tuned
            }
            printw("\n");
        }
        if (state->carrier == 1) {
            attron(COLOR_PAIR(3));
        }
    }

    // If any P25 patches are active, show them in wrapped columns (3 per line)
    // to avoid overflowing the Call Info width (similar to Channels layout).
    {
        char patch_line[192] = {0};
        int n = p25_patch_compose_details(state, patch_line, sizeof patch_line);
        if (n > 0) {
            // Parse tokens separated by ';' and compute uniform column width
            char tokens[48][64];
            int count = 0;
            const char* s = patch_line;
            while (*s && count < 48) {
                while (*s == ';' || *s == ' ') {
                    s++;
                }
                if (!*s) {
                    break;
                }
                int t = 0;
                while (*s && *s != ';' && t < 63) {
                    tokens[count][t++] = *s++;
                }
                while (t > 0 && tokens[count][t - 1] == ' ') {
                    t--; // rtrim
                }
                tokens[count][t] = '\0';
                if (t > 0) {
                    count++;
                }
                if (*s == ';') {
                    s++;
                }
            }
            if (count > 0) {
                int colw = 0;
                for (int i = 0; i < count; i++) {
                    int len = (int)strlen(tokens[i]);
                    if (len > colw) {
                        colw = len;
                    }
                }
                if (colw > 28) {
                    colw = 28; // clamp
                }
                const int cols_per_line = 3;
                const char* label = "Patches: ";
                int idx = 0;
                while (idx < count) {
                    printw("|        | ");
                    if (idx == 0) {
                        attron(COLOR_PAIR(4));
                        printw("%s", label);
                    } else {
                        for (size_t sp = 0; sp < strlen(label); sp++) {
                            addch(' ');
                        }
                    }
                    for (int c = 0; c < cols_per_line && idx < count; c++, idx++) {
                        attron(COLOR_PAIR(4));
                        printw("%-*s", colw, tokens[idx]);
                        if (state->carrier == 1) {
                            attron(COLOR_PAIR(3));
                        } else {
                            attron(COLOR_PAIR(4));
                        }
                        if (c < cols_per_line - 1 && idx < count) {
                            addstr("   ");
                        }
                    }
                    printw("\n");
                }
            }
        }
    }

    // Bottom border for Call Info section
    ui_print_hr();

    // Render learned LCNs just under the Call Info section when trunking (toggle in menu)
    if (opts->show_channels == 1) {
        ui_print_learned_lcns(opts, state);
        // fence bottom only when Channels are shown
        ui_print_hr();
    }
    //colors off
    if (state->carrier == 1) { //same as above
        attroff(COLOR_PAIR(3));
    }
    //only print event history if enabled
    attron(COLOR_PAIR(4)); //cyan for history
    {
        char hdr[160];
        snprintf(hdr, sizeof(hdr), "Latest Event History ([|])  Slot %d (\\)  Cycle (h): Short/Long/Off",
                 state->eh_slot + 1);
        ui_print_header(hdr);
    }
    if (opts->ncurses_history != 0) {
        for (uint16_t i = (state->eh_index + 1); i < (state->eh_index + 11); i++) {
            uint16_t string_size = 71; //short uniform size that doesn't exceed the fence
            if (opts->ncurses_history == 2) {
                string_size = 1999; //full string size
            }
            uint8_t slot = state->eh_slot;
            uint8_t color_pair = state->event_history_s[slot]
                                     .Event_History_Items[i % 255]
                                     .color_pair; //this is the color pair assignment for this line
            attron(COLOR_PAIR(4));

            char text_string[2000];
            memset(text_string, 0, sizeof(text_string));
            snprintf(text_string, sizeof text_string, "%s", "BUMBLEBEETUNA");
            if (strncmp(text_string, state->event_history_s[slot].Event_History_Items[i % 255].event_string, 13) != 0) {
                memcpy(text_string, state->event_history_s[slot].Event_History_Items[i % 255].event_string,
                       string_size * sizeof(char));
                text_string[string_size] = 0; //terminate string
                printw("| #%03d ", i % 255);
                attron(COLOR_PAIR(color_pair)); //this is where the custom color switch occurs for the event_string
                printw("%s\n", text_string);
                attron(COLOR_PAIR(4));
            } else {
                printw("| #%03d \n", i % 255); //empty event, but since we can freely scroll now, keeps things uniform
            }

            snprintf(text_string, sizeof text_string, "%s", "BUMBLEBEETUNA");
            if (strncmp(text_string, state->event_history_s[slot].Event_History_Items[i % 255].text_message, 13) != 0) {
                printw("|");
                attron(COLOR_PAIR(4)); //feel free to change this to any value you want
                printw("      %s\n", state->event_history_s[slot].Event_History_Items[i % 255].text_message);
                attron(COLOR_PAIR(4));
            }

            if (strncmp(text_string, state->event_history_s[slot].Event_History_Items[i % 255].alias, 13) != 0) {
                printw("|");
                attron(COLOR_PAIR(4)); //feel free to change this to any value you want
                printw("      Alias: %s \n", state->event_history_s[slot].Event_History_Items[i % 255].alias);
                attron(COLOR_PAIR(4));
            }

            if (strncmp(text_string, state->event_history_s[slot].Event_History_Items[i % 255].gps_s, 13) != 0) {
                printw("|");
                attron(COLOR_PAIR(4)); //feel free to change this to any value you want
                printw("      GPS: %s \n", state->event_history_s[slot].Event_History_Items[i % 255].gps_s);
                attron(COLOR_PAIR(4));
            }

            if (strncmp(text_string, state->event_history_s[slot].Event_History_Items[i % 255].internal_str, 13) != 0) {
                printw("|");
                attron(COLOR_PAIR(4)); //feel free to change this to any value you want
                printw("      DSD-neo: %s \n", state->event_history_s[slot].Event_History_Items[i % 255].internal_str);
                attron(COLOR_PAIR(4));
            }
        }
    }

    ui_print_hr();
    attroff(COLOR_PAIR(4)); //cyan for history

    refresh();

    //handle input
    ncurses_input_handler(opts, state, c);
}

void
ncursesClose() {
#ifdef __unix__
    // Restore stderr so exit-time logs (e.g., ring stats) are visible.
    if (s_stderr_suppressed) {
        fflush(stderr);
        if (s_saved_stderr_fd >= 0) {
            dup2(s_saved_stderr_fd, fileno(stderr));
            close(s_saved_stderr_fd);
            s_saved_stderr_fd = -1;
        }
        s_stderr_suppressed = 0;
    }
#endif
    endwin();
}
