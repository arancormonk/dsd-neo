// SPDX-License-Identifier: ISC
/*
 * Copyright (C) 2025 by arancormonk <180709949+arancormonk@users.noreply.github.com>
 */
/*-------------------------------------------------------------------------------
 * dsd_ncurses_printer.c
 * DSD-FME ncurses open, printer, and close
 *
 * ASCII art generated by:
 * https://fsymbols.com/generators/carty/
 *
 * LWVMOBILE
 * 2025-05 DSD-FME Florida Man Edition
 *
 * ilyacodes
 * 2024-03 EDACS-FME display improvements
 *-----------------------------------------------------------------------------*/

#include <dsd-neo/core/dsd.h>
#include <dsd-neo/core/dsd_time.h>
#include <dsd-neo/core/synctype.h>
#include <dsd-neo/platform/curses_compat.h>
#include <dsd-neo/protocol/p25/p25_callsign.h>
#include <dsd-neo/protocol/p25/p25_sm_watchdog.h>
#include <dsd-neo/protocol/p25/p25_trunk_sm.h>
#include <dsd-neo/runtime/config.h>
#include <dsd-neo/runtime/git_ver.h>
#include <dsd-neo/ui/keymap.h>
#include <dsd-neo/ui/menu_core.h>
#include <dsd-neo/ui/ncurses_dsp_display.h>
#include <dsd-neo/ui/ncurses_internal.h>
#include <dsd-neo/ui/ncurses_p25_display.h>
#include <dsd-neo/ui/ncurses_snr.h>
#include <dsd-neo/ui/ncurses_trunk_display.h>
#include <dsd-neo/ui/ncurses_visualizers.h>
#include <dsd-neo/ui/panels.h>
#include <dsd-neo/ui/ui_async.h>
#include <dsd-neo/ui/ui_cmd.h>
#include <dsd-neo/ui/ui_opts_snapshot.h>
#include <dsd-neo/ui/ui_prims.h>
#include <dsd-neo/ui/ui_snapshot.h>
#include <math.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#ifdef USE_RTLSDR
#include <dsd-neo/io/rtl_stream_c.h>
#endif

/* file_compat.h provides portable file descriptor operations */
#include <dsd-neo/platform/file_compat.h>

// s_stderr_suppressed, s_saved_stderr_fd moved to ncurses_init.c

// gamma mapping now provided by ui_prims
// swap_int_local, select_k_int_local, cmp_int_asc provided by ncurses_internal.h

// ui_is_locked_from_label provided by ncurses_internal.h

// select_k_int_local provided by ncurses_internal.h
// mbeversionstr, edacs_channel_tree defined in ncurses_init.c
extern char mbeversionstr[25];
extern unsigned long long int edacs_channel_tree[33][6];

// SNR history buffers and functions provided by ncurses_snr.h
// drawing helpers now provided by ui_prims

// ui_is_iden_channel, ui_match_iden_channel provided by ncurses_p25_display.h

/* Map IDEN nibble (0..15) to a color pair in 21..28 (wrap by 8) */
// iden color helper now provided by ui_prims

/* Small helpers to align key/value fields to a consistent value column. */
static inline void
ui_print_label_pad(const char* label) {
    const int value_col = 14; /* column (from label start) where values begin */
    int lab_len = (int)strlen(label);
    if (lab_len < 0) {
        lab_len = 0;
    }
    /* Draw the left border in the primary UI color (teal/cyan) for consistency */
    ui_print_lborder();
    addch(' ');
    addstr(label);
    addch(':');
    int need = value_col - (lab_len + 1); /* +1 for ':' */
    if (need < 1) {
        need = 1; /* at least one space after ':' */
    }
    for (int i = 0; i < need; i++) {
        addch(' ');
    }
}

static void
ui_print_kv_line(const char* label, const char* fmt, ...) {
    ui_print_label_pad(label);
    va_list ap;
    va_start(ap, fmt);
    vw_printw(stdscr, fmt, ap);
    va_end(ap);
    addch('\n');
}

// SNR functions (snr_hist_push, print_snr_sparkline, print_snr_meter) provided by ncurses_snr.h
// cmp_int_asc provided by ncurses_internal.h

char* DMRBusrtTypes[32] = {
    "PI       ", "VLC      ", "TLC      ", "CSBK     ", "MBCH     ", "MBCC     ", "DATA     ",
    "R12D     ", "R34D     ", "IDLE     ", "R1_D     ", "ERR      ", "DUID ERR ", "R-S ERR  ",
    "CRC ERR  ", "NULL     ", "VOICE",     "         ", "INIT     ", "INIT     ",
    "PTT",      //20 MAC
    "VOICE",    //21 MAC_ACTIVE
    "HANGTIME", //22 MAC
    "PTT END",  //23 MAC
    "IDLE",     //24 MAC
    "HDU",
    "VOICE", //26 LDU1
    "VOICE", //27 LDU2
    "TDU/LC",    "TSBK",
    "SIGNAL", //MAC_SIGNAL
    "SIGNAL"  //MAC_SIGNAL

};

// ncursesOpen provided by ncurses_init.c

/* Alias for shared last synctype tracking (defined in ncurses_utils.c) */
#define lls ncurses_last_synctype

// DSP and visualizer functions (print_dsp_status, print_constellation_view,
// print_eye_view, print_fsk_hist_view, print_spectrum_view, cmp_int_asc)
// provided by ncurses_dsp_display.h and ncurses_visualizers.h

// compute_p25p1_voice_avg_err, compute_p25p2_voice_avg_err provided by ncurses_p25_display.h

/* Forward decls now provided by headers */
// ui_guess_active_vc_freq provided by ncurses_p25_display.h
// compute_percentiles_u8 provided by ncurses_internal.h

// ui_print_p25_metrics provided by ncurses_p25_display.h

// ui_print_p25_cc_candidates provided by ncurses_p25_display.h

// ui_print_p25_neighbors provided by ncurses_p25_display.h

// ui_print_p25_iden_plan provided by ncurses_p25_display.h

// ui_guess_active_vc_freq provided by ncurses_p25_display.h

// ui_print_learned_lcns provided by ncurses_trunk_display.h

/* Factor render function. For now this function simply wraps
 * the legacy drawing path; the body will be migrated here later
 * without changing behavior. */
static void
ui_draw_frame(dsd_opts* opts, dsd_state* state) {
    (void)opts;
    (void)state;
    /* Drawing implementation lives in the legacy block below and will be
       moved here in a follow-up to keep behavior identical. */
}

void
ncursesPrinter(dsd_opts* opts, dsd_state* state) {
    /* Guard against null opts. Without opts we cannot render safely. */
    if (!opts) {
        return;
    }
    /* Demod path must not touch ncurses. Allow calls only from the UI thread
       context; otherwise publish snapshots and request a redraw. */
    if (!ui_is_thread_context()) {
        // Publish snapshots for the UI thread to consume and request a redraw
        ui_publish_both_and_redraw(opts, state);
        return;
    }
    uint8_t idas = 0;
    int level = 0;
    int c = 0;
    int i = 0;

    if (opts->audio_in_type != 1) //can't run getch/menu when using STDIN -
    {
        c = getch(); // non-blocking (set once in ncursesOpen)
        if (c == KEY_RESIZE) {
            // Force a full redraw on next refresh to avoid artifacts
            clearok(stdscr, TRUE);
            c = -1; // ignore as input
        }
    }

    // Defer overlay drawing to the end so it stays on top.

    //Variable reset/set section

    //set lls sync types
    if (state->synctype >= 0) {
        lls = state->synctype;
    }

    //EDACS Channel Tree
    if ((lls == 14 || lls == 15 || lls == 37 || lls == 38) && state->carrier == 1) {

        if (state->edacs_vc_lcn != -1) {
            edacs_channel_tree[state->edacs_vc_lcn][0] = lls;
            edacs_channel_tree[state->edacs_vc_lcn][1] = state->edacs_vc_lcn;
            edacs_channel_tree[state->edacs_vc_lcn][2] = state->lasttg;
            //EDACS standard does not provide source LIDs on channel update messages; instead, for the sake of display, let's
            //assume the prior source for a given LCN is still accurate, unless we have an updated one provided (or the call
            //type has changed under us).
            //
            //If you MUST have perfectly-accurate source LIDs, look at the logged CC messages yourself - incorrect source LIDs
            //may be displayed if we miss an initial call channel assignment.
            if (state->ea_mode == 1
                || (state->lastsrc != 0
                    || edacs_channel_tree[state->edacs_vc_lcn][4] != (unsigned long long)state->edacs_vc_call_type)) {
                edacs_channel_tree[state->edacs_vc_lcn][3] = state->lastsrc;
            }
            if (state->ea_mode == 0 && state->lastsrc == 0x800) { //this was from a grant update, so set this to 0
                edacs_channel_tree[state->edacs_vc_lcn][3] = 0;
            }
            edacs_channel_tree[state->edacs_vc_lcn][4] = state->edacs_vc_call_type;
            edacs_channel_tree[state->edacs_vc_lcn][5] = time(NULL);
        }
    }

    //Start Printing Section (render factored function placeholder)
    ui_draw_frame(opts, state);
    erase();
    ui_panel_header_render(opts, state);
    if (state) {
        ui_panel_footer_status_render(opts, state);
    }

    ui_print_header("Input Output");
    if (opts->audio_in_type == 0) {
        printw("| Pulse Signal Input:  %i kHz; %i Ch; ", opts->pulse_digi_rate_in / 1000, opts->pulse_digi_in_channels);
        if (opts->pa_input_idx[0] != 0) {
            printw(" D: %s;", opts->pa_input_idx);
        }
        if (opts->use_rigctl == 1) {
            printw("RIG: %s:%d; ", opts->tcp_hostname, opts->rigctlportno);
        }
        printw(" IV: %iX;", opts->input_volume_multiplier);
        printw("\n");
    }

    if (opts->audio_in_type == 4) {
        printw("| Dibit Bin Input: %s \n", opts->audio_in_dev);
    }

    if (opts->audio_in_type == 44) {
        printw("| Symbol Float Input: %s \n", opts->audio_in_dev);
    }

    if (opts->m17decoderip == 1 && opts->udp_sockfd) {
        printw("| M17 UDP IP Frame Input: %s:%d \n", opts->m17_hostname, opts->m17_portno);
    }

    if (opts->audio_in_type == 8) {
        printw("| TCP Signal Input: %s:%d; %d kHz; 1 Ch; ", opts->tcp_hostname, opts->tcp_portno,
               opts->wav_sample_rate / 1000);
        if (opts->use_rigctl == 1) {
            printw("RIG: %s:%d; ", opts->tcp_hostname, opts->rigctlportno);
        }
        printw(" IV: %iX;", opts->input_volume_multiplier);
        printw("\n");
    }

    if (opts->audio_in_type == 6) {
        const char* host = (opts->udp_in_bindaddr[0] ? opts->udp_in_bindaddr : "127.0.0.1");
        printw("| UDP Signal Input: %s:%d; %d kHz; 1 Ch; ", host, opts->udp_in_portno, opts->wav_sample_rate / 1000);
        if (opts->udp_in_packets == 0ULL) {
            printw("[Waiting]");
        } else {
            printw("Pkts:%llu Drops:%llu", (unsigned long long)opts->udp_in_packets,
                   (unsigned long long)opts->udp_in_drops);
        }
        printw(" IV: %iX;", opts->input_volume_multiplier);
        printw("\n");
    }

    if (opts->audio_in_type == 2) {
        printw("| WAV Audio Input: %s; %d kHz; ", opts->audio_in_dev, opts->wav_sample_rate);
        printw(" IV: %iX;\n", opts->input_volume_multiplier);
    }

    if (opts->audio_in_type == 1) {
        printw("| STDIN Standard Input: - Menu Disabled when using STDIN!\n");
        // printw ("| NCURSES Menu Disabled when using STDIN! - Use CTRL + C to Close. \n");
    }

    if (opts->audio_in_type == 3) {
        printw("| RTL: %d;", opts->rtl_dev_index);
        /* Show applied tuner gain when available (actual driver value),
           otherwise fall back to requested value. */
        {
            int g10 = 0, is_auto = 1;
            int have = 0;
#ifdef USE_RTLSDR
            /* Header is already included indirectly via other UI modules. */
            extern int rtl_stream_get_gain(int* out_tenth_db, int* out_is_auto);
            if (rtl_stream_get_gain(&g10, &is_auto) == 0) {
                have = 1;
            }
#endif
            if (have) {
                if (is_auto) {
                    printw(" G: AGC;");
                } else {
                    int gdB = (g10 >= 0) ? (g10 + 5) / 10 : (g10 - 5) / 10;
                    printw(" G: %idB;", gdB);
                }
            } else {
                if (opts->rtl_gain_value == 0) {
                    printw(" G: AGC;");
                } else {
                    printw(" G: %idB;", opts->rtl_gain_value);
                }
            }
        }
        printw(" V: %iX;", opts->rtl_volume_multiplier);
        printw(" PPM: %i;", opts->rtlsdr_ppm_error); //Adjust manually now with { and }
        printw(" SQL: %.1f dB;", pwr_to_dB(opts->rtl_squelch_level));
        printw(" PWR: %.1f dB;", pwr_to_dB(opts->rtl_pwr));
        printw(" DSP-BW: %i kHz;", opts->rtl_dsp_bw_khz);
        printw(" FRQ: %i;", opts->rtlsdr_center_freq);
        /* Show spectrum-based auto PPM status snapshot */
        {
            int ap_en = 0, ap_dir = 0, ap_cd = 0, ap_locked = 0;
            double ap_snr = -100.0, ap_df = 0.0, ap_estppm = 0.0;
#ifdef USE_RTLSDR
            extern int rtl_stream_auto_ppm_get_status(int*, double*, double*, double*, int*, int*, int*);
            (void)rtl_stream_auto_ppm_get_status(&ap_en, &ap_snr, &ap_df, &ap_estppm, &ap_dir, &ap_cd, &ap_locked);
#endif
            if (!ap_en) {
                printw("\n| Auto PPM: Off");
            } else if (ap_locked) {
                int lppm = 0;
                double lsnr = -100.0, ldf = 0.0;
#ifdef USE_RTLSDR
                extern int rtl_stream_auto_ppm_get_lock(int*, double*, double*);
                (void)rtl_stream_auto_ppm_get_lock(&lppm, &lsnr, &ldf);
#endif
                (void)lsnr;
                (void)ldf;
                printw("\n| Auto PPM: Locked (PPM: %d)", lppm);
            } else {
                printw("\n| Auto PPM: On; SNR: %.1f dB; df: %.1f Hz; step: %s;", ap_snr, ap_df,
                       (ap_dir > 0)   ? "+1"
                       : (ap_dir < 0) ? "-1"
                                      : "hold");
            }
        }
        if (opts->rtl_udp_port != 0) {
            printw("\n| External RTL Tuning on UDP Port: %i", opts->rtl_udp_port);
        }
        printw("\n");
        /* Show compact DSP status directly above audio sections (optional) */
        if (opts->show_dsp_panel) {
            print_dsp_status(opts, state);
        }
        /* Signal quality is shown inline above; no duplicate line here. */
    }

    if (opts->audio_out_type == 0 && opts->analog_only == 0) {
        printw("| Pulse Digital Output: %i kHz; %i Ch; G: %02.0f%%", opts->pulse_digi_rate_out / 1000,
               opts->pulse_digi_out_channels, state->aout_gain * 2);
        if (opts->pulse_digi_out_channels == 2) {
            printw(" G: %02.0f%%", state->aout_gainR * 2);
        }
        if (opts->floating_point == 1) {
            printw(" FLOAT: %02.0f%%;", opts->audio_gain * 2);
        }
        if (opts->audio_gain == 0) {
            printw(" (+|-) Auto  ");
        }
        if (opts->audio_gain > 0) {
            printw(" (+|-) Manual");
        }
        if (opts->use_hpf_d == 1) {
            printw(" HPF");
        }
        if (opts->call_alert == 1) {
            printw(" *CA!"); //Call Alert
        }
        if (opts->pa_output_idx[0] != 0) {
            printw(" D: %s;", opts->pa_output_idx);
        }

        printw(" \n");
    }

    if (opts->audio_out_type == 0 && (opts->frame_provoice == 1 || opts->monitor_input_audio == 1)) {
        printw("| Pulse Analog Output: %i kHz; %i Ch; G: %02.0f%% (/|*) ", opts->pulse_raw_rate_out / 1000,
               opts->pulse_raw_out_channels, opts->audio_gainA);
        if (opts->audio_gainA == 0.0f) {
            printw("Auto   ");
        } else {
            printw("Manual ");
        }
        if (opts->audio_in_type != 3) {
            printw("PWR: %.1f dB; ", pwr_to_dB(opts->rtl_pwr));
        }
        if (opts->use_lpf == 1) {
            printw("F: |LP|");
        } else {
            printw("F: |  |");
        }
        if (opts->use_hpf == 1) {
            printw("HP|");
        } else {
            printw("  |");
        }
        if (opts->use_pbf == 1) {
            printw("PB|");
        } else {
            printw("  |");
        }
        if (opts->pa_output_idx[0] != 0) {
            printw(" D: %s;", opts->pa_output_idx);
        }
        printw(" \n");
    }

    if (opts->audio_out_type == 8) {
        printw("| UDP Digital Output: %s:%d; %d kHz %d Ch; %02.0f%%", opts->udp_hostname, opts->udp_portno,
               opts->pulse_digi_rate_out / 1000, opts->pulse_digi_out_channels, state->aout_gain * 2);
        if (opts->pulse_digi_out_channels == 2) {
            printw(" G: %02.0f%%", state->aout_gainR * 2);
        }
        if (opts->audio_gain == 0) {
            printw(" (+/-) Auto  ");
        }
        if (opts->audio_gain > 0) {
            printw(" (+/-) Manual");
        }
        if (opts->use_hpf_d == 1) {
            printw(" HPF");
        }
        if (opts->call_alert == 1) {
            printw(" *CA!"); //Call Alert
        }
        printw(" \n");
        if (opts->udp_sockfdA != 0) //Analog Output on udp port +2
        {
            printw("| UDP Analog Output: %s:%d; 48 kHz 1 Ch; G: %02.0f%% (/|*) ", opts->udp_hostname,
                   opts->udp_portno + 2, opts->audio_gainA);
            if (opts->audio_gainA == 0.0f) {
                printw("A ");
            } else {
                printw("M ");
            }
            if (opts->audio_in_type != 3) {
                printw("PWR: %.1f dB; ", pwr_to_dB(opts->rtl_pwr));
            }
            if (opts->use_lpf == 1) {
                printw("F: |LP|");
            } else {
                printw("F: |  |");
            }
            if (opts->use_hpf == 1) {
                printw("HP|");
            } else {
                printw("  |");
            }
            if (opts->use_pbf == 1) {
                printw("PB|");
            } else {
                printw("  |");
            }
            printw(" \n");
        }
    }

    if (opts->m17encoder == 1) {
        printw("| M17 Encoder:");
        if (state->m17encoder_tx == 1 && state->m17_vox == 0) {
            printw(" Toggle TX (\\) On ;");
        }
        if (state->m17encoder_tx == 0 && state->m17_vox == 0) {
            printw(" Toggle TX (\\) Off;");
        }
        if (state->m17_vox == 1) {
            printw(" Vox Mode;");
        }
        printw(" Input Gain (/|*): %02.0f%% ", opts->audio_gainA);

        if (opts->use_lpf == 1) {
            printw("F: |LP|");
        } else {
            printw("F: |  |");
        }
        if (opts->use_hpf == 1) {
            printw("HP|");
        } else {
            printw("  |");
        }
        if (opts->use_pbf == 1) {
            printw("PB|");
        } else {
            printw("  |");
        }
        if (opts->audio_in_type != 3 && state->m17_vox == 1) {
            printw(" SQL: %.1f : %.1f dB;", pwr_to_dB(opts->rtl_pwr), pwr_to_dB(opts->rtl_squelch_level));
        }
        printw("\n");
    }

    if (opts->m17_use_ip == 1) {
        printw("| M17 UDP IP Frame Output: %s:%d \n", opts->m17_hostname, opts->m17_portno);
    }

    if (opts->mbe_out_dir[0] != 0 && opts->dmr_stereo == 0) {
        printw("| Writing MBE data files to directory %s\n", opts->mbe_out_dir);
    }

    if (opts->wav_out_raw) {
        printw("| Raw Audio Output: %s\n", opts->wav_out_file_raw);
    }

    if (opts->symbol_out_f) //don't display when not actively capturing
    {
        printw("| Symbol Bin Output: %s\n", opts->symbol_out_file);
    }

    if (opts->dmr_stereo_wav == 0 && opts->wav_out_file[0] != 0) {
        printw("| Decoded WAV Output: %s\n", opts->wav_out_file);
    }

    //new Per Call setup would just be random names until closed,
    //so no need to show, and will be in the event history anyways
    if (opts->dmr_stereo_wav == 1) {
        printw("| Per Call Wav File Enabled to Directory: %s \n", opts->wav_out_dir);
    }

#ifdef PRETTY_COLORS
    if (opts->p25_trunk == 1 && (opts->use_rigctl == 1 || opts->audio_in_type == 3)) {
        printw("| Trunking -");
        if (opts->trunk_tune_group_calls == 0) {
            attron(COLOR_PAIR(2));
        }
        printw(" Group(g)");
        attron(COLOR_PAIR(4));
        if (opts->trunk_tune_private_calls == 0) {
            attron(COLOR_PAIR(2));
        }
        printw(" Private(u)");
        attron(COLOR_PAIR(4));
        if (opts->trunk_tune_data_calls == 0) {
            attron(COLOR_PAIR(2));
        }
        printw(" Data(d)");
        attron(COLOR_PAIR(4));
        if (opts->trunk_tune_enc_calls == 0) {
            attron(COLOR_PAIR(2));
        }
        printw(" Encrypted(e)");
        attron(COLOR_PAIR(4));
        printw(" Calls");
        if (opts->trunk_use_allow_list == 1) {
            printw(" - White List Mode\n");
        } else {
            printw(" - Black List Mode\n");
        }
        // P25 metrics moved to dedicated 'P25 Metrics' section below.
    }
#else //set on to UPPER CASE, off to lower case
    if (opts->p25_trunk == 1 && (opts->use_rigctl == 1 || opts->audio_in_type == 3)) {
        printw("| Trunking -");
        if (opts->trunk_tune_group_calls == 0) {
            printw(" group(g)");
        } else {
            printw(" GROUP(g)");
        }
        if (opts->trunk_tune_private_calls == 0) {
            printw(" private(u)");
        } else {
            printw(" PRIVATE(u)");
        }
        if (opts->trunk_tune_data_calls == 0) {
            printw(" data(d)");
        } else {
            printw(" DATA(d)");
        }
        if (opts->trunk_tune_enc_calls == 0) {
            printw(" encrypted(e)");
        } else {
            printw(" ENCRYPTED(e)");
        }
        printw(" Calls");
        if (opts->trunk_use_allow_list == 1) {
            printw(" - White List Mode\n");
        } else {
            printw(" - Black List Mode\n");
        }
        // P25 metrics moved to dedicated 'P25 Metrics' section below.
    }
#endif
//print additional information for EDACS modes and toggles
#ifdef PRETTY_COLORS
    if (opts->p25_trunk == 1 && opts->frame_provoice == 1) {
        printw("| \\--EDACS -");
        if (state->ea_mode == -1) {
            attron(COLOR_PAIR(2));
            printw(" Standard/Network");
            printw(" Extended Address");
            attron(COLOR_PAIR(4));
        } else if (state->ea_mode == 0) {
            printw(" Standard/Network");
            attron(COLOR_PAIR(2));
            printw(" Extended Address");
            attron(COLOR_PAIR(4));
        } else if (state->ea_mode == 1) {
            attron(COLOR_PAIR(2));
            printw(" Standard/Network");
            attron(COLOR_PAIR(4));
            printw(" Extended Address");
        }
        printw(" Mode (S);");

        printw(" ESK: %02X", state->esk_mask);
        printw(" (A);");

        if (state->ea_mode == 0) {
            printw(" AFS: %d:%d:%d;", state->edacs_a_bits, state->edacs_f_bits, state->edacs_s_bits);
        }

        //TG Hold on EDACS, if specified by user
        if (state->tg_hold != 0) {
            // Compute AFS for display purposes only
            int a = (state->tg_hold >> state->edacs_a_shift) & state->edacs_a_mask;
            int f = (state->tg_hold >> state->edacs_f_shift) & state->edacs_f_mask;
            int s = state->tg_hold & state->edacs_s_mask;
            if (state->ea_mode == 1) {
                printw("\n|  \\TG HOLD: %d; ", state->tg_hold);
            } else {
                char afs_str[8];
                getAfsString(state, afs_str, a, f, s);
                printw("\n|  \\TG HOLD: %d [%s]; ", state->tg_hold, afs_str);
            }
        }

        attron(COLOR_PAIR(4));
        printw("\n");
    }
#else //set on to UPPER CASE, off to lower case
    if (opts->p25_trunk == 1 && opts->frame_provoice == 1) {
        printw("| \\--EDACS -");
        if (state->ea_mode == -1) {
            printw(" standard/network");
            printw(" extended address");
        } else if (state->ea_mode == 0) {
            printw(" STANDARD/NETWORK");
            printw(" extended address");
        } else if (state->ea_mode == 1) {
            printw(" standard/network");
            printw(" EXTENDED ADDRESS");
        }
        printw(" Mode (S);");

        printw(" ESK: %02X", state->esk_mask);
        printw(" (A) Toggle; ");

        if (state->ea_mode == 0) {
            printw(" AFS: %d:%d:%d;", state->edacs_a_bits, state->edacs_f_bits, state->edacs_s_bits);
        }

        //TG Hold on EDACS, if specified by user
        if (state->tg_hold != 0) {
            // Compute AFS for display purposes only
            int a = (state->tg_hold >> state->edacs_a_shift) & state->edacs_a_mask;
            int f = (state->tg_hold >> state->edacs_f_shift) & state->edacs_f_mask;
            int s = state->tg_hold & state->edacs_s_mask;
            if (state->ea_mode == 1) {
                printw("\n|  \\TG HOLD: %d; ", state->tg_hold);
            } else {
                char afs_str[8];
                getAfsString(state, afs_str, a, f, s);
                printw("\n|  \\TG HOLD: %d [%s]; ", state->tg_hold, afs_str);
            }
        }

        printw("\n");
    }
#endif
    // if (opts->aggressive_framesync == 0) printw ("| Selective CRC ERR Bypass Enabled (RAS) \n");
    if (state->M == 1) {
        if (state->R != 0) {
            printw("| Forcing Key Priority -- NXDN Sc Key: %05lld \n", state->R);
        }
        if (state->K != 0) {
            printw("| Forcing Key Priority -- Moto BP Key: %03lld \n", state->K);
        }
        if (state->K1 != 0) {
            printw("| Forcing Key Priority -- Hytera BP Key: %016llX \n", state->K1);
        }
        if (state->K != 0 && state->K1 != 0) {
            printw("| Warning! Multiple DMR Key Types Loaded! \n"); //warning may not be required
        }
    }
    if (state->M == 0x21) {
        if (state->R != 0) {
            printw("| Forcing Key Priority -- RC4 Key: %010llX \n", state->R);
        }
    }
    if (state->M == 0x16) {
        printw("| Forcing Key Priority -- TYT 16-bit Key: %04llX \n", state->H);
    }

    if (opts->scanner_mode == 1) {
        printw("| Scan Mode: ");
        if (state->lcn_freq_roll != 0) {
            printw(" Frequency: %.06lf Mhz", (double)state->trunk_lcn_freq[state->lcn_freq_roll - 1] / 1000000);
        }
        printw(" Speed: %.02lf sec \n",
               opts->trunk_hangtime); // default aligned to OP25 (2.0s) unless overridden
    }

    if (opts->reverse_mute == 1) {
        printw("| Reverse Mute - Muting Unencrypted Voice\n");
    }
    // if (opts->call_alert == 1)   printw ("| Call Alert Tone Enabled\n");

    ui_print_hr();
#ifdef USE_RTLSDR
    /* Only show RTL-SDR section and render visualizers when RTL input is active */
    if (opts->audio_in_type == 3) {
        ui_print_header("RTL-SDR Visual Aids");
        int nfft = rtl_stream_spectrum_get_size();
        /* Controls/status line: only show controls relevant to active views */
        printw("| Const View:  %s (%c)", opts->constellation ? "On" : "Off", DSD_KEY_CONST_VIEW_UPPER);
        if (opts->constellation == 1) {
            printw("  Gate: %.02f (</>)  Norm: %s (%c)",
                   (opts->mod_qpsk == 1) ? opts->const_gate_qpsk : opts->const_gate_other,
                   opts->const_norm_mode ? "unit" : "radial", DSD_KEY_CONST_NORM);
        }
        printw("  Eye: %s (%c)", opts->eye_view ? "On" : "Off", DSD_KEY_EYE_VIEW);
        if (opts->eye_view == 1) {
            printw("  Uni: %s (%c) Col: %s (%c)", opts->eye_unicode ? "On" : "off", DSD_KEY_EYE_UNICODE,
                   opts->eye_color ? "On" : "Off", DSD_KEY_EYE_COLOR);
        }
        printw("  Hist: %s (%c)", opts->fsk_hist_view ? "On" : "Off", DSD_KEY_FSK_HIST);
        printw("  Spec: %s (%c)", opts->spectrum_view ? "On" : "Off", DSD_KEY_SPECTRUM);
        if (opts->spectrum_view == 1) {
            printw("  FFT:%d (%c/%c)", nfft, DSD_KEY_SPEC_DEC, DSD_KEY_SPEC_INC);
        }
        addch('\n');
        ui_print_hr();

        if (opts->constellation == 1) {
            print_constellation_view(opts, state);
        }
        if (opts->eye_view == 1) {
            print_eye_view(opts, state);
        }
        if (opts->fsk_hist_view == 1) {
            print_fsk_hist_view();
        }
        if (opts->spectrum_view == 1) {
            print_spectrum_view(opts);
        }
    }
#endif
    /* Ensure our primary UI color remains active after visual aids */
    attron(COLOR_PAIR(4));

    if (state->carrier == 1) {
        attron(COLOR_PAIR(3));
        int level_div = 164; /* baseline scaling for C4FM/GFSK symbol magnitudes */
        if (opts->mod_qpsk == 1 || state->rf_mod == 1) {
            level_div = 82; /* CQPSK phase deltas peak near pi/4 (~4k), so use tighter scale */
        }
        if (level_div < 1) {
            level_div = 1;
        }
        level = (int)state->max / level_div; //only update on carrier present
        if (opts->audio_in_type == 4) {
            level = 50; //hard set when reading symbol bin files, otherwise, it will just be near zero
        }
        if (level > 100) {
            level = 100; //cap max at 100 to prevent it going over
        }
    } else {
        level = 0;
    }

    ui_print_header("Audio Decode");
    if (opts->p25_trunk == 1 && (opts->trunk_is_tuned == 1 || opts->p25_is_tuned == 1)) {
        ui_print_kv_line("Tuner state", "Busy");
    }
    if (opts->p25_trunk == 1 && (opts->trunk_is_tuned == 0 && opts->p25_is_tuned == 0)) {
        ui_print_kv_line("Tuner state", "Free");
    }
    ui_print_label_pad("Demod/Rate");
    {
        const char* modlab = (state->rf_mod == 1) ? "QPSK" : (state->rf_mod == 2) ? "GFSK" : "C4FM";
        printw("[%s][%d] \n", modlab, (48000 * opts->wav_interpolator) / state->samplesPerSymbol);
    }
    /* (RTL-SDR controls moved to dedicated section above) */
    if (opts->m17encoder == 1) {
        printw("| Encoding:    [%s] \n", opts->output_name);
    }
    ui_print_label_pad("Decoding");
    printw("[%s] ", opts->output_name);
    if (opts->aggressive_framesync == 0) {
        printw("CRC/(RAS) ");
    }
    /* Demod SNR (per modulation) */
#ifdef USE_RTLSDR
    {
        double snr = -100.0;
        const char* m = "";
        /* Simple stale detection for cases where SNR stops updating */
        static double last_c4_snr = -999.0; /* C4FM */
        static int last_c4_stable = 0;
        if (state->rf_mod == 0) {
            snr = rtl_stream_get_snr_c4fm();
            m = "C4FM";
            /* If missing or appears stale, compute a quick fallback from the eye buffer */
            if (snr <= -50.0) {
                double fb = rtl_stream_estimate_snr_c4fm_eye();
                if (fb > -50.0) {
                    snr = fb;
                    last_c4_stable = 0;
                }
            } else {
                double delta = fabs(snr - last_c4_snr);
                if (delta < 0.05) {
                    if (++last_c4_stable >= 40) { /* ~couple seconds of no change */
                        double fb = rtl_stream_estimate_snr_c4fm_eye();
                        if (fb > -50.0) {
                            snr = fb;
                        }
                        last_c4_stable = 0;
                    }
                } else {
                    last_c4_stable = 0;
                }
                last_c4_snr = snr;
            }
        } else if (state->rf_mod == 1) {
            snr = rtl_stream_get_snr_cqpsk();
            m = "QPSK";
            /* Fallback: prefer constellation-based QPSK estimator; else use best of C4FM/GFSK */
            static double last_qp_snr = -999.0;
            static int last_qp_stable = 0;
            if (snr <= -50.0) {
                double fb = rtl_stream_estimate_snr_qpsk_const();
                if (fb > -50.0) {
                    snr = fb;
                    last_qp_stable = 0;
                } else {
                    double snr_c = rtl_stream_get_snr_c4fm();
                    double snr_g = rtl_stream_get_snr_gfsk();
                    double snr_fb = (snr_c > snr_g) ? snr_c : snr_g;
                    if (snr_fb > -50.0) {
                        snr = snr_fb;
                    }
                }
            } else {
                double delta = fabs(snr - last_qp_snr);
                if (delta < 0.05) {
                    if (++last_qp_stable >= 40) {
                        double fb = rtl_stream_estimate_snr_qpsk_const();
                        if (fb > -50.0) {
                            snr = fb;
                        }
                        last_qp_stable = 0;
                    }
                } else {
                    last_qp_stable = 0;
                }
                last_qp_snr = snr;
            }
        } else if (state->rf_mod == 2) {
            snr = rtl_stream_get_snr_gfsk();
            m = "GFSK";
            /* Stale/NA fallback: estimate from eye buffer (2-level) */
            static double last_gf_snr = -999.0;
            static int last_gf_stable = 0;
            if (snr <= -50.0) {
                double fb = rtl_stream_estimate_snr_gfsk_eye();
                if (fb > -50.0) {
                    snr = fb;
                    last_gf_stable = 0;
                }
            } else {
                double delta = fabs(snr - last_gf_snr);
                if (delta < 0.05) {
                    if (++last_gf_stable >= 40) {
                        double fb = rtl_stream_estimate_snr_gfsk_eye();
                        if (fb > -50.0) {
                            snr = fb;
                        }
                        last_gf_stable = 0;
                    }
                } else {
                    last_gf_stable = 0;
                }
                last_gf_snr = snr;
            }
        }
        if (snr > -50.0) {
            /* Show current SNR as a compact, colorized meter */
            printw(" SNR: %.1f dB ", snr);
            printw("[");
            /* Pass current modulation for per-mod color bands */
            print_snr_meter(opts, snr, state->rf_mod);
            printw("]");
            printw(" (%s)", m);
        } else {
            /* Show placeholder so users can see the field even when no estimate */
            printw(" SNR: n/a (%s) []", m[0] ? m : "-");
        }
    }
#endif
#ifndef USE_RTLSDR
    /* If built without RTL support, still show a placeholder */
    printw(" SNR: n/a []");
#endif
    printw("\n");
    ui_print_kv_line("In Level", "[%02d%%]", level);
    /* Quick hint for output mute toggle */
    ui_print_kv_line("Output (x)", "[%s]", (opts->audio_out == 0) ? "Muted" : "On");

    /* Hide generic Voice Error line when P25 is active, but keep slot toggles */
    int is_p25p1_active = (lls == 0 || lls == 1);
    int is_p25p2_active = (lls == 35 || lls == 36);
    int is_p25_active = is_p25p1_active || is_p25p2_active;

    if (opts->dmr_stereo == 0) {
        if (!is_p25_active) {
            printw("| Voice Error: [%X][%X]", state->errs & 0xF, state->errs2 & 0xF);
            double avgv = 0.0;
            if (compute_p25p1_voice_avg_err(state, &avgv)) {
                printw(" Avg:%4.1f%%", avgv);
            }
            /* Keep slot toggle state at the end, as before */
            if (opts->slot1_on == 0) {
                printw(" Off");
            }
            if (opts->slot1_on == 1) {
                printw(" On");
            }
            printw("\n");
        } else {
            /* P25 active: show only slot toggle state, no error counters */
            printw("| Slot 1 (1):  [%s]\n", (opts->slot1_on == 1) ? "On" : "Off");
        }
    }

    if (opts->dmr_stereo == 1) {
        if (!is_p25_active) {
            printw("| Voice Error: [%X][%X] Slot 1 (1)", state->errs & 0xF, state->errs2 & 0xF);
        } else {
            ui_print_label_pad("Slot 1 (1)");
            addch('[');
        }
        if (opts->slot1_on == 0) {
            printw(is_p25_active ? "Off" : " Off");
        }
        if (opts->slot1_on == 1) {
            printw(is_p25_active ? "On" : " On");
        }
        if (is_p25_active) {
            printw("]");
        }
        if (opts->slot_preference == 0) {
            printw(" *Preferred (3)");
        }
        printw("\n");

        if (!is_p25_active) {
            printw("| Voice Error: [%X][%X] Slot 2 (2)", state->errsR & 0xF, state->errs2R & 0xF);
        } else {
            ui_print_label_pad("Slot 2 (2)");
            addch('[');
        }
        if (opts->slot2_on == 0) {
            printw(is_p25_active ? "Off" : " Off");
        }
        if (opts->slot2_on == 1) {
            printw(is_p25_active ? "On" : " On");
        }
        if (is_p25_active) {
            printw("]");
        }
        if (opts->slot_preference == 1) {
            printw(" *Preferred (3)");
        }
        printw("\n");
    }
    ui_print_hr();

    /* Dedicated P25 metrics section (toggle in menu) */
    {
        int is_p25p1 = (lls == 0 || lls == 1);
        int is_p25p2 = (lls == 35 || lls == 36);
        if (opts->show_p25_metrics == 1 && (is_p25p1 || is_p25p2)) {
            ui_print_header("P25 Metrics");
            (void)ui_print_p25_metrics(opts, state);
            ui_print_hr();
        }
        /* CC Candidates (toggle) */
        if (opts->show_p25_cc_candidates == 1 && (is_p25p1 || is_p25p2)) {
            if (opts->p25_trunk == 1) {
                ui_print_header("P25 CC Candidates");
                ui_print_p25_cc_candidates(opts, state);
                ui_print_hr();
            }
        }
        /* Neighbors (toggle) */
        if (opts->show_p25_neighbors == 1 && (is_p25p1 || is_p25p2)) {
            ui_print_header("P25 Neighbors");
            ui_print_p25_neighbors(opts, state);
            ui_print_hr();
        }
        /* IDEN Plan (toggle) */
        if (opts->show_p25_iden_plan == 1 && (is_p25p1 || is_p25p2)) {
            ui_print_header("P25 IDEN Plan");
            ui_print_p25_iden_plan(opts, state);
            ui_print_hr();
        }
    }

    /* P25 affiliations (RIDs registered on the system) */
    {
        int is_p25p1 = (lls == 0 || lls == 1);
        int is_p25p2 = (lls == 35 || lls == 36);
        if (opts->show_p25_affiliations == 1 && (is_p25p1 || is_p25p2)) {
            ui_print_header("P25 Affiliations");
            // Compose a recent-first list of up to 20 RIDs
            int idxs[256];
            int n = 0;
            time_t now = time(NULL);
            for (int i = 0; i < 256; i++) {
                if (state->p25_aff_rid[i] != 0) {
                    idxs[n++] = i;
                }
            }
            // Selection sort by last_seen desc (n is typically small)
            for (int i = 0; i < n; i++) {
                int best = i;
                for (int j = i + 1; j < n; j++) {
                    if (state->p25_aff_last_seen[idxs[j]] > state->p25_aff_last_seen[idxs[best]]) {
                        best = j;
                    }
                }
                if (best != i) {
                    int tmp = idxs[i];
                    idxs[i] = idxs[best];
                    idxs[best] = tmp;
                }
            }
            int shown = 0;
            int rows = 0, cols = 80;
            getmaxyx(stdscr, rows, cols);
            (void)rows;
            if (cols < 1) {
                cols = 80;
            }
            // Track the current line width after the left border
            int line_used = 0;
            for (int i = 0; i < n && shown < 20; i++) {
                int k = idxs[i];
                uint32_t rid = state->p25_aff_rid[k];
                long age = (long)((state->p25_aff_last_seen[k] != 0) ? (now - state->p25_aff_last_seen[k]) : 0);
                if (age < 0) {
                    age = 0;
                }
                char buf[64];
                int m = snprintf(buf, sizeof buf, "RID:%u age:%lds", (unsigned)rid, age);
                if (m < 0) {
                    m = 0;
                }
                int sep = (line_used == 0) ? 0 : 4; // spacing between columns
                // If this is the first item on the line, account for "| " at line start
                int left_border = (line_used == 0) ? 2 : 0;
                if ((left_border + line_used + sep + m) > cols) {
                    // New line and reset tracking
                    if (line_used > 0) {
                        addch('\n');
                    }
                    line_used = 0;
                }
                if (line_used == 0) {
                    ui_print_lborder_green();
                    addch(' ');
                } else {
                    addstr("    ");
                }
                addnstr(buf, m);
                line_used += ((line_used == 0) ? 0 : sep) + m;
                shown++;
            }
            if (shown > 0 && line_used > 0) {
                addch('\n');
            }
            if (shown == 0) {
                ui_print_lborder_green();
                addstr(" (none)\n");
            }
            ui_print_hr();
        }
    }

    /* P25 Group Affiliation (RID â†” TG) */
    {
        int is_p25p1 = (lls == 0 || lls == 1);
        int is_p25p2 = (lls == 35 || lls == 36);
        if (opts->show_p25_group_affiliations == 1 && (is_p25p1 || is_p25p2)) {
            ui_print_header("P25 Group Affiliation");
            int idxs[512];
            int n = 0;
            time_t now = time(NULL);
            for (int i = 0; i < 512; i++) {
                if (state->p25_ga_rid[i] != 0 && state->p25_ga_tg[i] != 0) {
                    idxs[n++] = i;
                }
            }
            for (int i = 0; i < n; i++) {
                int best = i;
                for (int j = i + 1; j < n; j++) {
                    if (state->p25_ga_last_seen[idxs[j]] > state->p25_ga_last_seen[idxs[best]]) {
                        best = j;
                    }
                }
                if (best != i) {
                    int tmp = idxs[i];
                    idxs[i] = idxs[best];
                    idxs[best] = tmp;
                }
            }
            int shown = 0;
            int rows = 0, cols = 80;
            getmaxyx(stdscr, rows, cols);
            (void)rows;
            if (cols < 1) {
                cols = 80;
            }
            int line_used = 0;
            for (int i = 0; i < n && shown < 20; i++) {
                int k = idxs[i];
                uint32_t rid = state->p25_ga_rid[k];
                uint16_t tg = state->p25_ga_tg[k];
                long age = (long)((state->p25_ga_last_seen[k] != 0) ? (now - state->p25_ga_last_seen[k]) : 0);
                if (age < 0) {
                    age = 0;
                }
                char buf[80];
                int m = snprintf(buf, sizeof buf, "RID:%u TG:%u age:%lds", (unsigned)rid, (unsigned)tg, age);
                if (m < 0) {
                    m = 0;
                }
                int sep = (line_used == 0) ? 0 : 4;
                int left_border = (line_used == 0) ? 2 : 0;
                if ((left_border + line_used + sep + m) > cols) {
                    if (line_used > 0) {
                        addch('\n');
                    }
                    line_used = 0;
                }
                if (line_used == 0) {
                    ui_print_lborder_green();
                    addch(' ');
                } else {
                    addstr("    ");
                }
                addnstr(buf, m);
                line_used += ((line_used == 0) ? 0 : sep) + m;
                shown++;
            }
            if (shown > 0 && line_used > 0) {
                addch('\n');
            }
            if (shown == 0) {
                ui_print_lborder_green();
                addstr(" (none)\n");
            }
            ui_print_hr();
        }
    }

    ui_print_header("Call Info");

    //DSTAR
    if (lls == 6 || lls == 7 || lls == 18 || lls == 19) {
        printw("| %s ", SyncTypes[lls]);
        printw("\n");
        printw("| RPT2: %s", state->dstar_rpt2);
        printw(" RPT1: %s", state->dstar_rpt1);
        printw("\n");
        printw("| DEST: %s", state->dstar_dst);
        printw("  SRC: %s", state->dstar_src);
        printw("\n");
        printw("| TEXT: %s", state->dstar_txt);
        printw("\n");
        printw("| DATA: %s", state->dstar_gps);
        printw("\n");
    }

    //M17
    if (lls == 8 || lls == 9 || lls == 16 || lls == 17) {

        printw("| ");
        printw("M17: ");

        //insert data type and frame information
        if (state->m17_str_dt == 0) {
            printw("Reserved");
        }
        if (state->m17_str_dt == 1) {
            printw("Data ");
        }
        if (state->m17_str_dt == 2) {
            printw("Voice (3200) ");
        }
        if (state->m17_str_dt == 3) {
            printw("Voice (1600) + Data");
        }

        printw("\n");
        printw("| ");

        printw("DST: ");
        if (state->m17_dst == 0xFFFFFFFFFFFF) {
            printw("BROADCAST ");
        } else if (state->m17_dst != 0 && state->m17_dst >= 0xEE6B28000000) {
            printw("RESERVED (%012llx) ", state->m17_dst);
        } else {
            printw("%s", state->m17_dst_str);
        }

        printw("\n");
        printw("| ");

        printw("SRC: ");
        if (state->m17_src != 0 && state->m17_src >= 0xEE6B28000000) {
            printw("RESERVED (%012llx)", state->m17_src);
        } else {
            printw("%s", state->m17_src_str);
        }

        printw("\n");
        printw("| ");

        printw("CAN: %02d ", state->m17_can);

        printw("\n");
        printw("| ");

        //fill in any extra info, like Meta (IV, etc)
        if (state->m17_enc == 1) {
            printw(" Scrambler - Type: %d", state->m17_enc_st);
        }

        if (state->m17_enc == 2) {
            attron(COLOR_PAIR(1));
            printw("AES-CTR - IV: ");
            //display packed meta as IV
            for (i = 0; i < 16; i++) {
                printw("%02X", state->m17_meta[i]);
            }
        }

        if (state->m17_enc == 3) {
            printw(" Reserved Enc - Type: %d", state->m17_enc_st);
        }

        printw("\n");
    }

    //YSF
    if (lls == 30 || lls == 31) {
        // printw ("\n");
        printw("| ");
        printw("Fusion - ");
        //insert data type and frame information
        if (state->ysf_dt == 0) {
            printw("V/D1 ");
        }
        if (state->ysf_dt == 1) {
            printw("DATA ");
        }
        if (state->ysf_dt == 2) {
            printw("V/D2 ");
        }
        if (state->ysf_dt == 3) {
            printw("VWFR ");
        }
        printw(" ");
        if (state->ysf_cm == 0) {
            printw("Group/CQ ");
        }
        if (state->ysf_cm == 3) {
            printw("Private  ");
        }
        if (state->ysf_cm == 1) {
            printw("Radio ID ");
        }
        if (state->ysf_cm == 2) {
            printw("Reserved ");
        }

        if (state->ysf_fi == 0) {
            printw("HC ");
        }
        if (state->ysf_fi == 1) {
            printw("CC ");
        }
        if (state->ysf_fi == 2) {
            printw("TC ");
        }
        if (state->ysf_fi == 3) {
            printw("XX ");
        }

        printw("\n");
        printw("| ");
        //NOTE: In Radio ID Mode, the DST will be split on Destination and Source Radio ID values
        printw("DST: %s ", state->ysf_tgt);
        printw("SRC: %s ", state->ysf_src);
        printw("\n");
        printw("| ");
        printw("UPL: %s ", state->ysf_upl);
        printw("DNL: %s ", state->ysf_dnl);
        printw("\n");
        printw("| ");
        printw("RM1: %s ", state->ysf_rm1);
        printw("RM2: %s ", state->ysf_rm2);
        printw("\n");
        printw("| ");
        printw("RM3: %s ", state->ysf_rm3);
        printw("RM4: %s ", state->ysf_rm4);

        //these texts can get pretty long and out of sorts, and lots of 0x20 spaces
        //just going to leave these to only be in the console output

        // printw ("\n");
        // printw ("| ");
        // printw ("TXT: ");
        // for (i = 4; i < 8; i++)
        // {
        //   for (int j = 0; j < 20; j++)
        //   {
        //     //no spaces and no asterisks
        //     if (state->ysf_txt[i][j] != 0x2A)
        //       printw ("%c", state->ysf_txt[i][j]);
        //   }
        //   // printw (" "); //just a single space between each 'block'
        // }

        printw("\n");
    }

    //NXDN
    if (lls == 28 || lls == 29) {
        if (strcmp(state->nxdn_location_category, "Type-D") == 0) {
            idas = 1;
        }

        if (opts->p25_trunk == 1) {

            printw("| ");
            if (opts->p25_is_tuned == 0) {
                if (idas == 0) {
                    printw("Monitoring RCCH Channel"); //Control Channel
                }
                if (idas == 1) {
                    printw("Monitoring RTCH2 Channel"); //Idas RTCH2 Channel
                }
                if (state->trunk_cc_freq != 0 || state->p25_cc_freq != 0) {
                    long f = (state->trunk_cc_freq != 0) ? state->trunk_cc_freq : state->p25_cc_freq;
                    printw(" - Frequency: %.06lf Mhz ", (double)f / 1000000);
                }
            } else if (opts->p25_is_tuned == 1) {
                if (idas == 0) {
                    printw("Monitoring RTCH Channel"); //Traffic Channel
                }
                if (idas == 1) {
                    printw("Monitoring RTCH2 Channel"); //Idas RTCH2
                }
                if (state->trunk_vc_freq[0] != 0 || state->p25_vc_freq[0] != 0) {
                    long f = (state->trunk_vc_freq[0] != 0) ? state->trunk_vc_freq[0] : state->p25_vc_freq[0];
                    printw(" - Frequency: %.06lf Mhz ", (double)f / 1000000);
                }
            }

            printw("\n");
        }

        printw("| ");
        // #ifdef LIMAZULUTWEAKS
        if (idas == 0) {
            printw("NXDN - RAN: %02d; ", state->nxdn_last_ran);
        }
        if (idas == 1) {
            printw("IDAS - Area: %02d; ", state->nxdn_last_ran);
        }
        // #else
        // if (idas == 0) printw ("NXDN - RAN: [%02d] ", rn);
        // if (idas == 1) printw ("IDAS - Area: [%02d] ", rn);
        // #endif
        if (state->nxdn_location_site_code != 0) {
            printw("Cat: %s; ", state->nxdn_location_category);
            printw("Sys Code: %d; ", state->nxdn_location_sys_code);
            printw("Site Code: %d; ", state->nxdn_location_site_code);
        }

        //if system supports Direct Frequency Assignment
        if (state->nxdn_rcn == 1) {
            printw("DFA ");
        }

        printw("\n");
        printw("| ");
        printw("TGT: [%5d] ", state->nxdn_last_tg);
        printw("SRC: [%5d] ", state->nxdn_last_rid);
        printw("Alias: [%s]", state->generic_talker_alias[0]);

        //Group Name Labels from CSV import
        for (unsigned int k = 0; k < state->group_tally; k++) {
            if (state->group_array[k].groupNumber == (unsigned long)state->nxdn_last_tg) {
                printw("TG: ");
                attron(COLOR_PAIR(4));
                printw(" [%s]", state->group_array[k].groupName);
                printw("[%s] ", state->group_array[k].groupMode);
            } else if (state->group_array[k].groupNumber == (unsigned long)state->nxdn_last_rid) {
                attron(COLOR_PAIR(4));
                printw(" [%s]", state->group_array[k].groupName);
            }
            if (state->carrier == 1) {
                attron(COLOR_PAIR(3));
            }
        }

        if (state->carrier == 1) {
            printw(" %s ", state->nxdn_call_type);
        }
        printw("\n|");
        if (state->nxdn_cipher_type > 0) {
            // printw (" ALG: %d Key ID: %02X ", state->nxdn_cipher_type, state->nxdn_key);
            printw(" ALG: %d Key ID: %02d ", state->nxdn_cipher_type, state->nxdn_key);
        }
        if (state->nxdn_cipher_type == 0x1 && state->carrier == 1) {
            if (state->R == 0) {
                attron(COLOR_PAIR(2));
            }
            printw("Scrambler ");
            if (state->R == 0) {
                attroff(COLOR_PAIR(2));
            }
            attron(COLOR_PAIR(3));
            if (state->R != 0) {
                attron(COLOR_PAIR(1));
                printw("Seed: %04llX ", state->payload_miN);
                printw("Key: %05lld ", state->R);
                attron(COLOR_PAIR(3));
            }
        }
        if (state->nxdn_cipher_type == 0x2 && state->carrier == 1) {
            attron(COLOR_PAIR(1));
            printw("IV: %016llX ", state->payload_miN);
            attron(COLOR_PAIR(2));
            printw("DES1 ");
            if (state->R != 0) {
                printw("Key: %016llX ", state->R);
            }
            attroff(COLOR_PAIR(2));
            attron(COLOR_PAIR(3));
        }
        if (state->nxdn_cipher_type == 0x3 && state->carrier == 1) {
            attron(COLOR_PAIR(1));
            printw("IV: %016llX ", state->payload_miN);
            attron(COLOR_PAIR(2));
            printw("AES-256 ");
            if (state->aes_key_loaded[0] == 1) {
                printw("KS: %016llX", state->A4[0]);
            }
            attroff(COLOR_PAIR(2));
            attron(COLOR_PAIR(3));
        }
        if (state->nxdn_cipher_type > 0x3 && state->carrier == 1) {
            attron(COLOR_PAIR(2));
            printw("Unknown Encryption ");
            attroff(COLOR_PAIR(2));
            attron(COLOR_PAIR(3));
        }

        //Active Trunking Channels (NXDN and IDAS)
        if (1 == 1) //opts->p25_trunk
        {
            printw("\n");
            printw("| ");

            //active channel display
            attron(COLOR_PAIR(4));
            for (int i = 0; i < 16; i++) {
                if (state->active_channel[i][0] != '\0') {
                    const char* s = state->active_channel[i];
                    int locked = ui_is_locked_from_label(state, s);
                    /* Also show disabled classes (global toggles) in red */
                    if (!locked && opts) {
                        if (opts->trunk_tune_data_calls == 0 && strstr(s, "Active Data Ch:") != NULL) {
                            locked = 1;
                        }
                        if (!locked && opts->trunk_tune_group_calls == 0 && strstr(s, "TG:") != NULL) {
                            locked = 1;
                        }
                        if (!locked && opts->trunk_tune_private_calls == 0 && strstr(s, "TGT:") != NULL) {
                            locked = 1;
                        }
                    }
                    if (locked) {
                        // Highlight locked-out TGs in red
                        attron(COLOR_PAIR(2));
                        printw("%s", s);
                        attron(COLOR_PAIR(4)); // restore cyan for subsequent items
                    } else {
                        printw("%s", s);
                    }
                }
            }

            if (state->carrier == 1) {
                attron(COLOR_PAIR(3));
            } else {
                /* When no active call, keep UI in idle cyan instead of default white */
                attron(COLOR_PAIR(4));
            }
        }

        //TG Hold, if specified by user
        if (state->tg_hold != 0) {
            printw("TG HOLD: %d", state->tg_hold);
        }

        printw("\n");
    }

    //P25 and DMR BS/MS
    if (lls == 0 || lls == 1 || lls == 12 || lls == 13 || lls == 10 || lls == 11 || lls == 32 || lls == 33 || lls == 34
        || lls == 35 || lls == 36) {
        printw("| ");
        if (lls > 1 && lls < 30) {
            printw("DMR BS - DCC: %02i; ", state->dmr_color_code);
            // printw ("%s %s", state->dmr_branding, state->dmr_branding_sub);
            printw("%s ", state->dmr_branding);
            printw("%s", state->dmr_branding_sub);
            printw("%s", state->dmr_site_parms); //site id, net id, etc
            if (state->dmr_rest_channel > 0) {
                printw("Rest LSN: %02d; ", state->dmr_rest_channel);
                if (state->trunk_chan_map[state->dmr_rest_channel] != 0) {
                    printw("Freq: %.06lf Mhz", (double)state->trunk_chan_map[state->dmr_rest_channel] / 1000000);
                }
            } else if (state->trunk_cc_freq != 0 || state->p25_cc_freq != 0) {
                long f = (state->trunk_cc_freq != 0) ? state->trunk_cc_freq : state->p25_cc_freq;
                printw("Freq: %.06lf MHz", (double)f / 1000000);
            }

        } else if (lls == 32 || lls == 33 || lls == 34) {
            printw("DMR MS - DCC: %02i; ", state->dmr_color_code);
        } else if (lls == 0 || lls == 1) //P1
        {
            // Clarify identifiers to avoid confusion when SYSID and NAC
            // happen to have the same numeric value on some systems.
            char callsign[7] = {0};
            if (opts->show_p25_callsign_decode && (state->p2_wacn != 0 || state->p2_sysid != 0)) {
                p25_wacn_sysid_to_callsign((uint32_t)state->p2_wacn, (uint16_t)state->p2_sysid, callsign);
            }
            printw("P25p1  - WACN: %05llX SYS: %03llX NAC: %03llX", state->p2_wacn, state->p2_sysid, state->p2_cc);
            if (opts->show_p25_callsign_decode && callsign[0] != '\0' && callsign[0] != ' ') {
                printw(" [%s]", callsign);
            }
            printw("; RFSS: %lld SITE: %lld ", state->p2_rfssid, state->p2_siteid);
            if (state->trunk_cc_freq != 0 || state->p25_cc_freq != 0) {
                long f = (state->trunk_cc_freq != 0) ? state->trunk_cc_freq : state->p25_cc_freq;
                printw("FREQ: %.06lf MHz", (double)f / 1000000);
            }

            //load talker aliases here (Moto, Tait, Harris)
            for (unsigned int i = 0; i < state->group_tally; i++) {
                if (state->group_array[i].groupNumber == (unsigned long)state->lastsrc) //or state->lastsrc
                {
                    snprintf(state->generic_talker_alias[0], sizeof state->generic_talker_alias[0], "%s",
                             state->group_array[i].groupName);
                    break;
                }
            }

        } else if (lls == 35 || lls == 36) //P2
        {
            // Clarify identifiers to avoid confusion when SYSID and NAC
            // happen to have the same numeric value on some systems.
            char callsign[7] = {0};
            if (opts->show_p25_callsign_decode && (state->p2_wacn != 0 || state->p2_sysid != 0)) {
                p25_wacn_sysid_to_callsign((uint32_t)state->p2_wacn, (uint16_t)state->p2_sysid, callsign);
            }
            printw("P25p2  - WACN: %05llX SYS: %03llX NAC: %03llX", state->p2_wacn, state->p2_sysid, state->p2_cc);
            if (opts->show_p25_callsign_decode && callsign[0] != '\0' && callsign[0] != ' ') {
                printw(" [%s]", callsign);
            }
            printw("; RFSS: %lld SITE: %lld ", state->p2_rfssid, state->p2_siteid);
            if (state->p2_wacn == 0 || state->p2_sysid == 0 || state->p2_cc == 0) {
                attron(COLOR_PAIR(2));
                printw(" Phase 2 Missing Parameters ");
                attron(COLOR_PAIR(3));
            } else if (state->p2_wacn == 0xFFFFF || state->p2_sysid == 0xFFF || state->p2_cc == 0xFFF) {
                attron(COLOR_PAIR(2));
                printw(" Phase 2 Invalid Parameters ");
                attron(COLOR_PAIR(3));
            } else {
                if (state->trunk_cc_freq != 0 || state->p25_cc_freq != 0) {
                    long f = (state->trunk_cc_freq != 0) ? state->trunk_cc_freq : state->p25_cc_freq;
                    printw("FREQ: %.06lf MHz", (double)f / 1000000);
                }
            }

            //load talker aliases here (Moto, Tait, Harris)
            for (unsigned int i = 0; i < state->group_tally; i++) {
                if (state->group_array[i].groupNumber == (unsigned long)state->lastsrc) {
                    snprintf(state->generic_talker_alias[0], sizeof state->generic_talker_alias[0], "%s",
                             state->group_array[i].groupName);
                    break;
                }
            }

            //load talker aliases here (Moto, Tait, Harris)
            for (unsigned int i = 0; i < state->group_tally; i++) {
                if (state->group_array[i].groupNumber == (unsigned long)state->lastsrcR) {
                    snprintf(state->generic_talker_alias[1], sizeof state->generic_talker_alias[1], "%s",
                             state->group_array[i].groupName);
                    break;
                }
            }
        }

        printw("\n");
        //Slot 1 [0]
        printw("| SLOT 1 - ");
        if (state->dmrburstL < 16 && state->carrier == 1 && state->lasttg > 0 && state->lastsrc > 0) {
            attron(COLOR_PAIR(2));
        }
        // Only show IDs when the left slot is actively in a call; otherwise avoid stale values
        // Active when:
        //  - DMR voice (16)
        //  - P25p2: PTT/VOICE/HANGTIME (20/21/22)
        //  - P25p1 voice frames (26/27)
        int show_l_ids = (state->dmrburstL == 16) || (state->dmrburstL >= 20 && state->dmrburstL <= 22)
                         || (state->dmrburstL == 26) || (state->dmrburstL == 27);
        if (show_l_ids) {
            printw("TGT: [%8i] SRC: [%8i] ", state->lasttg, state->lastsrc);
            // P25 call flags: show [EM] and [PR:n] when active
            if (state->p25_call_emergency[0]) {
                printw("[EM] ");
            }
            if (state->p25_call_priority[0] > 0) {
                printw("[PR:%d] ", (int)state->p25_call_priority[0]);
            }
        } else {
            // Blank out IDs cleanly when slot 1 is not in an active call
            printw("TGT: [        ] SRC: [        ] ");
        }
        if (state->dmrburstL != 16 && state->carrier == 1 && state->lasttg > 0 && state->lastsrc > 0) {
            attroff(COLOR_PAIR(2));
            attron(COLOR_PAIR(3));
        }

        // Show banner only when actively in a call; otherwise blank to avoid stale labels
        if (show_l_ids) {
            printw("%s | ", state->call_string[0]);
        } else {
            printw("%s | ", "                     "); // 21 spaces
        }
        printw("%s ", DMRBusrtTypes[state->dmrburstL]);

        printw("\n");

        printw("| V XTRA | "); //10 spaces

        if (state->dmrburstL == 16 && state->payload_algid == 0
            && state->dmr_so & 0x40) //4F or CF mask? & 0xCF currently //&& (state->dmr_so & 0xCF) == 0x40
        {
            attron(COLOR_PAIR(5));
            printw(" **BP** ");
            attroff(COLOR_PAIR(5));
            attron(COLOR_PAIR(3));
        }

        if (state->dmrburstL == 16 && state->payload_algid == 0 && state->K > 0 && state->dmr_fid == 0x10
            && state->dmr_so & 0x40) {
            attron(COLOR_PAIR(1));
            printw("BP Key: %3lld ", state->K);
            attroff(COLOR_PAIR(1));
            attron(COLOR_PAIR(3));
        }

        if (state->dmrburstL == 16 && state->payload_algid == 0 && state->H > 0 && state->dmr_fid == 0x68
            && state->dmr_so & 0x40) {
            attron(COLOR_PAIR(1));
            printw("Hytera BP Key: %010llX ", state->H);
            attroff(COLOR_PAIR(1));
            attron(COLOR_PAIR(3));
        }

        //ALG, KeyID, MI                            //was key_id
        if (state->dmrburstL == 16 && state->payload_algid > 0 && state->dmr_so & 0x40) {
            attron(COLOR_PAIR(1));
            printw("ALG: 0x%02X KEY: 0x%02X MI: 0x%08llX ", state->payload_algid, state->payload_keyid,
                   state->payload_mi);
            attroff(COLOR_PAIR(1));
            attron(COLOR_PAIR(3));
        }

        //P25 FDMA/TDMA
        if (state->dmrburstL > 19 && state->payload_algid > 0 && state->payload_algid != 0x80) {
            attron(COLOR_PAIR(1));
            printw("ALG: 0x%02X KEY: 0x%04X MI: 0x%016llX ", state->payload_algid, state->payload_keyid,
                   state->payload_miP);
            attroff(COLOR_PAIR(1));
            attron(COLOR_PAIR(3));
        }

        //Anytone 0x01 will never show here since its converted to 0x21 for handling
        if (state->payload_algid == 0xAA || state->payload_algid == 0x21 || state->payload_algid == 0x01) {
            attron(COLOR_PAIR(1));
            printw("RC4 ");
            if (state->R != 0) {
                printw("Key: %010llX ", state->R);
            }
            attron(COLOR_PAIR(3));
        }
        if (state->payload_algid == 0x81 || state->payload_algid == 0x22) {
            attron(COLOR_PAIR(1));
            printw("DES1 ");
            if (state->R != 0) {
                printw("Key: %010llX ", state->R);
            }
            attron(COLOR_PAIR(3));
        }
        if (state->payload_algid == 0x9F) {
            attron(COLOR_PAIR(1));
            printw("DES-XL ");
            if (state->R != 0) {
                printw("Key: %010llX ", state->R);
            }
            attron(COLOR_PAIR(3));
        }
        if (state->payload_algid == 0x82) {
            attron(COLOR_PAIR(1));
            printw("DES2 ");
            attron(COLOR_PAIR(3));
        }
        if (state->payload_algid == 0x83) {
            attron(COLOR_PAIR(1));
            printw("DES3 ");
            attron(COLOR_PAIR(3));
        }
        if (state->payload_algid == 0x89 || state->payload_algid == 0x24) {
            attron(COLOR_PAIR(1));
            printw("AES-128 ");
            if (state->aes_key_loaded[0] != 0) {
                printw("KS: %016llX ", state->A2[0]);
            }
            attron(COLOR_PAIR(3));
        }
        if (state->payload_algid == 0x84 || state->payload_algid == 0x25 || state->payload_algid == 0x05) {
            attron(COLOR_PAIR(1));
            printw("AES-256 ");
            if (state->aes_key_loaded[0] != 0) {
                printw("KS: %016llX ", state->A4[0]);
            }
            attron(COLOR_PAIR(3));
        }
        if (state->payload_algid == 0x02) {
            attron(COLOR_PAIR(1));
            printw("Hytera Enhanced");
            if (state->R != 0) {
                printw(" Key: %010llX", state->R);
            }
            attron(COLOR_PAIR(3));
        }

        printw("\n");

        //printw ("|        | "); //10 spaces
        printw("| D XTRA | ");

        attron(COLOR_PAIR(4));

        if (state->dmrburstL == 16 || state->dmrburstL == 21 || state->dmrburstL == 26 || state->dmrburstL == 27
            || state->dmrburstL == 32) //only during call
        {

            attron(COLOR_PAIR(4));

            //Embedded GPS (not LRRP)
            printw("%s ", state->dmr_embedded_gps[0]);

            //Embedded Talker Alias String (show when present during active call)
            if (state->generic_talker_alias[0][0] != '\0') {
                printw("%s ", state->generic_talker_alias[0]);
            }

            attroff(COLOR_PAIR(5));
            if (state->carrier == 1) {
                attron(COLOR_PAIR(3));
            }
        }

        //LRRP
        if (state->dmrburstL != 16) //only during data and no trunking
        {
            attron(COLOR_PAIR(4));
            printw("%s", state->dmr_lrrp_gps[0]);
        }

        //Group Name Labels from CSV import
        if (state->dmrburstL == 16 || state->dmrburstL > 19) {
            for (unsigned int k = 0; k < state->group_tally; k++) {
                if (state->group_array[k].groupNumber == (unsigned long)state->lasttg) {
                    attron(COLOR_PAIR(4));
                    printw(" [%s]", state->group_array[k].groupName);
                    printw("[%s] ", state->group_array[k].groupMode);
                    if (state->carrier == 1) {
                        attron(COLOR_PAIR(3));
                    }
                }
            }
        }

        if (state->carrier == 1) {
            attron(COLOR_PAIR(3));
        } else {
            /* Restore idle cyan after extras when carrier drops */
            attron(COLOR_PAIR(4));
        }

        printw("\n");

        //Slot 2 [1] -- Also Including DMR MS now to keep the display more 'uniform' in nature
        // if (lls < 30 || lls == 35 || lls == 36)
        {
            printw("| SLOT 2 - ");
            if (state->dmrburstR < 16 && state->carrier == 1 && state->lasttgR > 0 && state->lastsrcR > 0) {
                attron(COLOR_PAIR(2));
            }
            // Only show IDs when the right slot is actively in a call; otherwise avoid stale values
            // Active when:
            //  - DMR voice (16)
            //  - P25p2: PTT/VOICE/HANGTIME (20/21/22)
            //  - P25p1 voice frames (26/27) [right slot used for MS/dual displays]
            int show_r_ids = (state->dmrburstR == 16) || (state->dmrburstR >= 20 && state->dmrburstR <= 22)
                             || (state->dmrburstR == 26) || (state->dmrburstR == 27);
            if (show_r_ids) {
                printw("TGT: [%8i] SRC: [%8i] ", state->lasttgR, state->lastsrcR);
                // P25 call flags for right slot
                if (state->p25_call_emergency[1]) {
                    printw("[EM] ");
                }
                if (state->p25_call_priority[1] > 0) {
                    printw("[PR:%d] ", (int)state->p25_call_priority[1]);
                }
            } else {
                // Blank out IDs cleanly when slot 2 is not in an active call
                printw("TGT: [        ] SRC: [        ] ");
            }
            if (state->dmrburstR != 16 && state->carrier == 1 && state->lasttgR > 0 && state->lastsrcR > 0) {
                attroff(COLOR_PAIR(2));
                attron(COLOR_PAIR(3));
            }

            // Show banner only during active call states on slot 2
            if (show_r_ids) {
                printw("%s | ", state->call_string[1]);
            } else {
                printw("%s | ", "                     "); // 21 spaces
            }
            printw("%s ", DMRBusrtTypes[state->dmrburstR]);

            printw("\n");

            printw("| V XTRA | "); //10 spaces

            if (state->dmrburstR == 16 && state->payload_algidR == 0 && state->dmr_soR & 0x40) //4F or CF mask?
            {
                attron(COLOR_PAIR(5));
                printw(" **BP** ");
                attroff(COLOR_PAIR(5));
                attron(COLOR_PAIR(3));
            }

            if (state->dmrburstR == 16 && state->payload_algidR == 0 && state->K > 0 && state->dmr_soR & 0x40
                && state->dmr_fidR == 0x10) {
                attron(COLOR_PAIR(1));
                printw("BP Key: %3lld ", state->K);
                attroff(COLOR_PAIR(1));
                attron(COLOR_PAIR(3));
            }
            if (state->dmrburstR == 16 && state->payload_algidR == 0 && state->H > 0 && state->dmr_soR & 0x40
                && state->dmr_fidR == 0x68) {
                attron(COLOR_PAIR(1));
                printw("Hytera BP Key: %010llX ", state->H);
                attroff(COLOR_PAIR(1));
                attron(COLOR_PAIR(3));
            }
            //ALG, KeyID, MI 2                          //was keyidR
            if (state->dmrburstR == 16 && state->payload_algidR > 0 && state->dmr_soR & 0x40) {
                attron(COLOR_PAIR(1));
                printw("ALG: 0x%02X KEY: 0x%02X MI: 0x%08llX ", state->payload_algidR, state->payload_keyidR,
                       state->payload_miR);
                attroff(COLOR_PAIR(1));
                attron(COLOR_PAIR(3));
            }
            //P25-P1 and P2
            if (state->dmrburstR > 19 && state->payload_algidR > 0 && state->payload_algidR != 0x80) {
                attron(COLOR_PAIR(1));
                printw("ALG: 0x%02X KEY: 0x%04X MI: 0x%016llX ", state->payload_algidR, state->payload_keyidR,
                       state->payload_miN);
                attroff(COLOR_PAIR(1));
                attron(COLOR_PAIR(3));
            }

            //Anytone 0x01 will never show here since its converted to 0x21 for handling
            if (state->payload_algidR == 0xAA || state->payload_algidR == 0x21 || state->payload_algidR == 0x01) {
                attron(COLOR_PAIR(1));
                printw("RC4 ");
                if (state->RR != 0) {
                    printw("Key: %010llX ", state->RR);
                }
                attron(COLOR_PAIR(3));
            }
            if (state->payload_algidR == 0x81 || state->payload_algidR == 0x22) {
                attron(COLOR_PAIR(1));
                printw("DES1 ");
                if (state->RR != 0) {
                    printw("Key: %010llX ", state->RR);
                }
                attron(COLOR_PAIR(3));
            }
            if (state->payload_algidR == 0x9F) {
                attron(COLOR_PAIR(1));
                printw("DES-XL ");
                if (state->RR != 0) {
                    printw("Key: %010llX ", state->RR);
                }
                attron(COLOR_PAIR(3));
            }
            if (state->payload_algidR == 0x82) {
                attron(COLOR_PAIR(1));
                printw("DES2 ");
                attron(COLOR_PAIR(3));
            }
            if (state->payload_algidR == 0x83) {
                attron(COLOR_PAIR(1));
                printw("DES3 ");
                attron(COLOR_PAIR(3));
            }
            if (state->payload_algidR == 0x89 || state->payload_algidR == 0x24) {
                attron(COLOR_PAIR(1));
                printw("AES-128 ");
                if (state->aes_key_loaded[1] != 0) {
                    printw("KS: %016llX ", state->A2[1]);
                }
                attron(COLOR_PAIR(3));
            }
            if (state->payload_algidR == 0x84 || state->payload_algidR == 0x25 || state->payload_algidR == 0x05) {
                attron(COLOR_PAIR(1));
                printw("AES-256 ");
                if (state->aes_key_loaded[1] != 0) {
                    printw("KS: %016llX ", state->A4[1]);
                }
                attron(COLOR_PAIR(3));
            }
            if (state->payload_algidR == 0x02) {
                attron(COLOR_PAIR(1));
                printw("Hytera Enhanced");
                if (state->RR != 0) {
                    printw(" Key: %010llX", state->RR);
                }
                attron(COLOR_PAIR(3));
            }

            printw("\n");

            //printw ("|        | ");
            printw("| D XTRA | ");

            attron(COLOR_PAIR(4));

            if (state->dmrburstR == 16 || state->dmrburstR == 21) //only during call
            {

                //Embedded GPS (not LRRP)
                attron(COLOR_PAIR(4));
                printw("%s ", state->dmr_embedded_gps[1]);

                //Embedded Talker Alias String (show when present during active call)
                if (state->generic_talker_alias[1][0] != '\0') {
                    printw("%s ", state->generic_talker_alias[1]);
                }

                attroff(COLOR_PAIR(5));
                if (state->carrier == 1) {
                    attron(COLOR_PAIR(3));
                }
            }

            //LRRP
            if (state->dmrburstR != 16) //only during data and no trunking
            {
                attron(COLOR_PAIR(4));
                printw("%s", state->dmr_lrrp_gps[1]);
            }

            //Group Name Labels from CSV import
            if (state->dmrburstR == 16 || state->dmrburstR > 19) {
                for (unsigned int k = 0; k < state->group_tally; k++) {
                    if (state->group_array[k].groupNumber == (unsigned long)state->lasttgR) {
                        attron(COLOR_PAIR(4));
                        printw(" [%s]", state->group_array[k].groupName);
                        printw("[%s] ", state->group_array[k].groupMode);
                    }
                    if (state->carrier == 1) {
                        attron(COLOR_PAIR(3));
                    }
                }
            }

            if (state->carrier == 1) {
                attron(COLOR_PAIR(3));
            } else {
                /* Keep cyan when idle to avoid white fallback */
                attron(COLOR_PAIR(4));
            }

            printw("\n");

            if (1 == 1) //opts->p25_trunk == 1
            {
                printw("|        | "); //Active Trunking Channels

                //active channel display
                attron(COLOR_PAIR(4));
                for (unsigned int i = 0; i < 31; i++) //up to 31 idas channels
                {
                    if (state->active_channel[i][0] != '\0') {
                        const char* s = state->active_channel[i];
                        int locked = ui_is_locked_from_label(state, s);
                        /* Also show disabled classes (global toggles) in red */
                        if (!locked && opts) {
                            if (opts->trunk_tune_data_calls == 0 && strstr(s, "Active Data Ch:") != NULL) {
                                locked = 1;
                            }
                            if (!locked && opts->trunk_tune_group_calls == 0 && strstr(s, "TG:") != NULL) {
                                locked = 1;
                            }
                            if (!locked && opts->trunk_tune_private_calls == 0 && strstr(s, "TGT:") != NULL) {
                                locked = 1;
                            }
                        }
                        if (locked) {
                            attron(COLOR_PAIR(2));
                            printw("%s", s);
                            attron(COLOR_PAIR(4));
                        } else {
                            printw("%s", s);
                        }
                    }
                }

                if (state->carrier == 1) {
                    attron(COLOR_PAIR(3));
                } else {
                    /* Keep cyan when idle to avoid white fallback */
                    attron(COLOR_PAIR(4));
                }
                printw("\n");
            }

            if (opts->p25_trunk == 1) {
                printw("|        | "); //Currently Tuned Frequency

                // Only render VC frequency when tuned off CC (on a voice/data channel)
                if (opts->p25_is_tuned == 1) {
                    // Tuned/Active Frequency Display: prefer tuned VC; else derive from active channel text/map
                    long int vc = (state->trunk_vc_freq[0] != 0) ? state->trunk_vc_freq[0] : state->p25_vc_freq[0];
                    if (vc == 0) {
                        vc = ui_guess_active_vc_freq(state);
                    }
                    if (vc != 0) {
                        attron(COLOR_PAIR(4));
                        printw("Frequency: %.06lf MHz  ", (double)vc / 1000000);
                    }
                }

                //TG Hold, if specified by user
                if (state->tg_hold != 0) {
                    printw("TG HOLD: %d", state->tg_hold);
                }

                if (state->carrier == 1) {
                    attron(COLOR_PAIR(3));
                } else {
                    /* Keep cyan when idle to avoid white fallback */
                    attron(COLOR_PAIR(4));
                }
                printw("\n");
            }

        } // end if not MS
    } //end DMR BS Types

    //dPMR
    if (lls == 20 || lls == 21 || lls == 22 || lls == 23 || lls == 24 || lls == 25 || lls == 26 || lls == 27) {
        printw("| DCC: [%i] ", state->dpmr_color_code);
        printw("TGT: [%s] SRC: [%s] ", state->dpmr_target_id, state->dpmr_caller_id);
        printw("\n| ");
        if (state->dPMRVoiceFS2Frame.Version[0] == 3) {
            attron(COLOR_PAIR(2));
            printw("Scrambler ");
            attroff(COLOR_PAIR(2));
            attron(COLOR_PAIR(3));
            if (state->R != 0) {
                attron(COLOR_PAIR(1));
                printw("KEY VALUE: [%05lld] ", state->R);
                //printw ("SEED: [%04llX]", state->payload_miN);
                attron(COLOR_PAIR(3));
            }
        }
        printw("\n");
    }

    //EDACS and ProVoice
    if (lls == 14 || lls == 15 || lls == 37 || lls == 38) {
        attroff(COLOR_PAIR(3)); //colors off for EDACS
        if (state->edacs_site_id != 0) {
            if (opts->trunk_is_tuned == 0 && opts->p25_is_tuned == 0) {
                printw("| Monitoring CC - LCN [%02d]\n", state->edacs_cc_lcn);
            } else {
                printw("| Monitoring VC - LCN [%02d]\n", state->edacs_tuned_lcn);
                //since we are tuned, keep updating the time so it doesn't disappear during call
                edacs_channel_tree[state->edacs_tuned_lcn][5] = time(NULL);
            }
            printw("| SITE [%03lld][%02llX]", state->edacs_site_id, state->edacs_site_id);

            if (state->ea_mode == 1) {
                printw(" Extended Addressing");
            } else {
                printw(" Standard/Networked");
            }
            if (state->esk_mask == 0xA0) {
                printw(" w/  ESK");
            } else {
                printw(" w/o ESK");
            }
            printw("\n");
        }
        for (i = 1; i <= state->edacs_lcn_count; i++) {
            // Compute AFS for display purposes only
            int a = (edacs_channel_tree[i][2] >> state->edacs_a_shift) & state->edacs_a_mask;
            int f = (edacs_channel_tree[i][2] >> state->edacs_f_shift) & state->edacs_f_mask;
            int s = edacs_channel_tree[i][2] & state->edacs_s_mask;
            printw("| - LCN [%02d][%010.06lf] MHz", i, (double)state->trunk_lcn_freq[i - 1] / 1000000);

            //print Control Channel on LCN line with the current Control Channel
            if ((i) == state->edacs_cc_lcn) {
                attron(COLOR_PAIR(1)); //yellow
                printw(" Control Channel");
                attroff(COLOR_PAIR(1));
            }

            int print_call = 0;
            //print active calls on corresponding LCN line
            if ((i != state->edacs_cc_lcn) && time(NULL) - edacs_channel_tree[i][5] < 2) {
                print_call = 3;
                attron(COLOR_PAIR(3));
            }
            //print dying or dead calls in red for x seconds longer
            else if ((i != state->edacs_cc_lcn) && (time(NULL) - edacs_channel_tree[i][5] >= 2)
                     && (time(NULL) - edacs_channel_tree[i][5] < 5)) {
                print_call = 2;
                attron(COLOR_PAIR(2));
            }

            if (print_call != 0) {
                if (state->ea_mode == 1) {
                    // Voice call
                    if ((edacs_channel_tree[i][4] & EDACS_IS_VOICE) != 0) {
                        // Group call
                        if ((edacs_channel_tree[i][4] & EDACS_IS_GROUP) != 0) {
                            printw(" TGT [%8lld] SRC [%8lld]", edacs_channel_tree[i][2], edacs_channel_tree[i][3]);
                        }
                        // I-Call
                        else if ((edacs_channel_tree[i][4] & EDACS_IS_INDIVIDUAL) != 0) {
                            printw(" TGT [%8lld] SRC [%8lld] I-Call", edacs_channel_tree[i][2],
                                   edacs_channel_tree[i][3]);
                        }
                        // System all-call
                        else if ((edacs_channel_tree[i][4] & EDACS_IS_ALL_CALL) != 0) {
                            printw(" TGT [ SYSTEM ] SRC [%8lld] All-Call", edacs_channel_tree[i][3]);
                        }
                        // Interconnect call
                        else if ((edacs_channel_tree[i][4] & EDACS_IS_INTERCONNECT) != 0) {
                            printw(" TGT [ SYSTEM ] SRC [%8lld] Interconnect", edacs_channel_tree[i][3]);
                        }
                        // Test call
                        else if ((edacs_channel_tree[i][4] & EDACS_IS_TEST_CALL) != 0) {
                            printw(" TGT [ SYSTEM ] SRC [ SYSTEM ] Test Call");
                        }
                        // Unknown call
                        else {
                            printw(" Unknown call type");
                        }

                        // Call flags
                        if ((edacs_channel_tree[i][4] & EDACS_IS_TEST_CALL) != 0) {
                        } else if ((edacs_channel_tree[i][4] & EDACS_IS_DIGITAL) == 0) {
                            printw(" [Ana]");
                        } else {
                            printw(" [Dig]");
                        }
                        if ((edacs_channel_tree[i][4] & EDACS_IS_EMERGENCY) != 0) {
                            printw("[EM]");
                        }
                    } else {
                        // Data call
                        printw(" TGT [  DATA  ] SRC [%8lld] Data", edacs_channel_tree[i][3]);
                    }
                } else {
                    // Voice call
                    if ((edacs_channel_tree[i][4] & EDACS_IS_VOICE) != 0) {
                        // Group call
                        if ((edacs_channel_tree[i][4] & EDACS_IS_GROUP) != 0) {
                            char afs_str[8];
                            getAfsString(state, afs_str, a, f, s);
                            printw(" TGT [%6lld][%s] SRC [%5lld]", edacs_channel_tree[i][2], afs_str,
                                   edacs_channel_tree[i][3]);
                        }
                        // I-Call
                        else if ((edacs_channel_tree[i][4] & EDACS_IS_INDIVIDUAL) != 0) {
                            if (getAfsStringLength(state) == 6) {
                                printw(" TGT [%6lld][ UNIT ] SRC [%5lld] I-Call", edacs_channel_tree[i][2],
                                       edacs_channel_tree[i][3]);
                            } else {
                                printw(" TGT [%6lld][  UNIT ] SRC [%5lld] I-Call", edacs_channel_tree[i][2],
                                       edacs_channel_tree[i][3]);
                            }
                        }
                        // System all-call
                        else if ((edacs_channel_tree[i][4] & EDACS_IS_ALL_CALL) != 0) {
                            if (getAfsStringLength(state) == 6) {
                                printw(" TGT [    SYSTEM    ] SRC [%5lld] All-Call", edacs_channel_tree[i][3]);
                            } else {
                                printw(" TGT [     SYSTEM    ] SRC [%5lld] All-Call", edacs_channel_tree[i][3]);
                            }
                        }
                        // Interconnect call
                        else if ((edacs_channel_tree[i][4] & EDACS_IS_INTERCONNECT) != 0) {
                            if (getAfsStringLength(state) == 6) {
                                printw(" TGT [    SYSTEM    ] SRC [%5lld] Interconnect", edacs_channel_tree[i][3]);
                            } else {
                                printw(" TGT [     SYSTEM    ] SRC [%5lld] Interconnect", edacs_channel_tree[i][3]);
                            }
                        }
                        // Test call
                        else if ((edacs_channel_tree[i][4] & EDACS_IS_TEST_CALL) != 0) {
                            if (getAfsStringLength(state) == 6) {
                                printw(" TGT [    SYSTEM    ] SRC [ SYS ] Test Call");
                            } else {
                                printw(" TGT [     SYSTEM    ] SRC [ SYS ] Test Call");
                            }
                        }
                        // Unknown call
                        else {
                            printw(" Unknown call type");
                        }

                        // Call flags
                        if ((edacs_channel_tree[i][4] & EDACS_IS_TEST_CALL) != 0) {
                        } else if ((edacs_channel_tree[i][4] & EDACS_IS_DIGITAL) == 0) {
                            printw(" [Ana]");
                        } else {
                            printw(" [Dig]");
                        }
                        if ((edacs_channel_tree[i][4] & EDACS_IS_AGENCY_CALL) != 0) {
                            printw("[A]");
                        }
                        if ((edacs_channel_tree[i][4] & EDACS_IS_FLEET_CALL) != 0) {
                            printw("[F]");
                        }
                        if ((edacs_channel_tree[i][4] & EDACS_IS_EMERGENCY) != 0) {
                            printw("[EM]");
                        }
                    }
                    // Data call
                    else if (getAfsStringLength(state) == 6) {
                        printw(" TGT [     DATA     ] SRC [%5lld] Data", edacs_channel_tree[i][3]);
                    } else {
                        printw(" TGT [      DATA     ] SRC [%5lld] Data", edacs_channel_tree[i][3]);
                    }
                }
                for (unsigned int k = 0; k < state->group_tally; k++) {
                    if ((state->group_array[k].groupNumber == (unsigned long)edacs_channel_tree[i][2]
                         && edacs_channel_tree[i][2] != 0)
                        || (state->group_array[k].groupNumber == (unsigned long)edacs_channel_tree[i][3]
                            && edacs_channel_tree[i][3] != 0)) {
                        printw(" [%s]", state->group_array[k].groupName);
                        printw("[%s]", state->group_array[k].groupMode);
                        break;
                    }
                }

                if (print_call == 3) {
                    attroff(COLOR_PAIR(3));
                } else if (print_call == 2) {
                    attroff(COLOR_PAIR(2));
                }
            }

            if (i == state->edacs_tuned_lcn && (opts->trunk_is_tuned == 1 || opts->p25_is_tuned == 1)) {
                printw(" **T**"); //asterisk which lcn is tuned
            }
            printw("\n");
        }
        if (state->carrier == 1) {
            attron(COLOR_PAIR(3));
        }
    }

    // If any P25 patches are active, show them in wrapped columns (3 per line)
    // to avoid overflowing the Call Info width (similar to Channels layout).
    {
        char patch_line[192] = {0};
        int n = p25_patch_compose_details(state, patch_line, sizeof patch_line);
        if (n > 0) {
            // Parse tokens separated by ';' and compute uniform column width
            char tokens[48][64];
            int count = 0;
            const char* s = patch_line;
            while (*s && count < 48) {
                while (*s == ';' || *s == ' ') {
                    s++;
                }
                if (!*s) {
                    break;
                }
                int t = 0;
                while (*s && *s != ';' && t < 63) {
                    tokens[count][t++] = *s++;
                }
                while (t > 0 && tokens[count][t - 1] == ' ') {
                    t--; // rtrim
                }
                tokens[count][t] = '\0';
                if (t > 0) {
                    count++;
                }
                if (*s == ';') {
                    s++;
                }
            }
            if (count > 0) {
                int colw = 0;
                for (int i = 0; i < count; i++) {
                    int len = (int)strlen(tokens[i]);
                    if (len > colw) {
                        colw = len;
                    }
                }
                if (colw > 28) {
                    colw = 28; // clamp
                }
                const int cols_per_line = 3;
                const char* label = "Patches: ";
                int idx = 0;
                while (idx < count) {
                    printw("|        | ");
                    if (idx == 0) {
                        attron(COLOR_PAIR(4));
                        printw("%s", label);
                    } else {
                        for (size_t sp = 0; sp < strlen(label); sp++) {
                            addch(' ');
                        }
                    }
                    for (int c = 0; c < cols_per_line && idx < count; c++, idx++) {
                        attron(COLOR_PAIR(4));
                        printw("%-*s", colw, tokens[idx]);
                        if (state->carrier == 1) {
                            attron(COLOR_PAIR(3));
                        } else {
                            attron(COLOR_PAIR(4));
                        }
                        if (c < cols_per_line - 1 && idx < count) {
                            addstr("   ");
                        }
                    }
                    printw("\n");
                }
            }
        }
    }

    // Bottom border for Call Info section
    ui_print_hr();

    // Render learned LCNs just under the Call Info section when trunking (toggle in menu)
    if (opts->show_channels == 1) {
        ui_print_learned_lcns(opts, state);
        // fence bottom only when Channels are shown
        ui_print_hr();
    }
    //colors off
    if (state->carrier == 1) { //same as above
        attroff(COLOR_PAIR(3));
    }
    //only print event history if enabled
    attron(COLOR_PAIR(4)); //cyan for history
    {
        /* Custom header to underline active Cycle (h) mode */
        int rows = 0, cols = 80;
        getmaxyx(stdscr, rows, cols);
        if (cols < 4) {
            cols = 80;
        }
        int y = 0, x0 = 0;
        getyx(stdscr, y, x0);
        (void)x0;

        /* Left prefix and static portion */
        addstr("--");
        printw("Latest Event History ([|])  Slot %d (\\)  Cycle (h): ", state->eh_slot + 1);

        /* Underline the active cycle indicator based on opts->ncurses_history
           0 = Off, 1 = Short, 2 = Long */
        const int hist = opts->ncurses_history % 3;

        if (hist == 1) {
            attron(A_UNDERLINE);
        }
        addstr("Short");
        if (hist == 1) {
            attroff(A_UNDERLINE);
        }

        addch('/');

        if (hist == 2) {
            attron(A_UNDERLINE);
        }
        addstr("Long");
        if (hist == 2) {
            attroff(A_UNDERLINE);
        }

        addch('/');

        if (hist == 0) {
            attron(A_UNDERLINE);
        }
        addstr("Off");
        if (hist == 0) {
            attroff(A_UNDERLINE);
        }

        /* Fill remainder of line with '-' and advance to next line */
        int used_y = 0, used = 0;
        getyx(stdscr, used_y, used);
        (void)used_y;
        if (used < cols) {
            mvhline(y, used, '-', cols - used);
        }
        if (y + 1 < rows) {
            move(y + 1, 0);
        } else {
            addch('\n');
        }
    }
    if (opts->ncurses_history != 0) {
        for (uint16_t i = (state->eh_index + 1); i < (state->eh_index + 11); i++) {
            uint16_t string_size = 71; //short uniform size that doesn't exceed the fence
            if (opts->ncurses_history == 2) {
                string_size = 1999; //full string size
            }
            uint8_t slot = state->eh_slot;
            uint8_t color_pair = state->event_history_s[slot]
                                     .Event_History_Items[i % 255]
                                     .color_pair; //this is the color pair assignment for this line
            attron(COLOR_PAIR(4));

            char text_string[2000];
            memset(text_string, 0, sizeof(text_string));
            snprintf(text_string, sizeof text_string, "%s", "BUMBLEBEETUNA");
            if (strncmp(text_string, state->event_history_s[slot].Event_History_Items[i % 255].event_string, 13) != 0) {
                memcpy(text_string, state->event_history_s[slot].Event_History_Items[i % 255].event_string,
                       string_size * sizeof(char));
                text_string[string_size] = 0; //terminate string
                printw("| #%03d ", i % 255);
                attron(COLOR_PAIR(color_pair)); //this is where the custom color switch occurs for the event_string
                printw("%s\n", text_string);
                attron(COLOR_PAIR(4));
            } else {
                printw("| #%03d \n", i % 255); //empty event, but since we can freely scroll now, keeps things uniform
            }

            snprintf(text_string, sizeof text_string, "%s", "BUMBLEBEETUNA");
            if (strncmp(text_string, state->event_history_s[slot].Event_History_Items[i % 255].text_message, 13) != 0) {
                printw("|");
                attron(COLOR_PAIR(4)); //feel free to change this to any value you want
                printw("      %s\n", state->event_history_s[slot].Event_History_Items[i % 255].text_message);
                attron(COLOR_PAIR(4));
            }

            if (strncmp(text_string, state->event_history_s[slot].Event_History_Items[i % 255].alias, 13) != 0) {
                printw("|");
                attron(COLOR_PAIR(4)); //feel free to change this to any value you want
                printw("      Alias: %s \n", state->event_history_s[slot].Event_History_Items[i % 255].alias);
                attron(COLOR_PAIR(4));
            }

            if (strncmp(text_string, state->event_history_s[slot].Event_History_Items[i % 255].gps_s, 13) != 0) {
                printw("|");
                attron(COLOR_PAIR(4)); //feel free to change this to any value you want
                printw("      GPS: %s \n", state->event_history_s[slot].Event_History_Items[i % 255].gps_s);
                attron(COLOR_PAIR(4));
            }

            if (strncmp(text_string, state->event_history_s[slot].Event_History_Items[i % 255].internal_str, 13) != 0) {
                printw("|");
                attron(COLOR_PAIR(4)); //feel free to change this to any value you want
                printw("      DSD-neo: %s \n", state->event_history_s[slot].Event_History_Items[i % 255].internal_str);
                attron(COLOR_PAIR(4));
            }
        }
    }

    ui_print_hr();
    attroff(COLOR_PAIR(4)); //cyan for history

    refresh();

    // Draw menu overlay last so it sits above base UI
    if (ui_menu_is_open()) {
        ui_menu_tick(opts, state);
    }

    //handle input
    ncurses_input_handler(opts, state, c);
}

// ncursesClose provided by ncurses_init.c
