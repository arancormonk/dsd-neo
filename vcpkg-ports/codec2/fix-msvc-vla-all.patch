diff --git a/src/lpc.c b/src/lpc.c
index 3117a1a..eeb1008 100644
--- a/src/lpc.c
+++ b/src/lpc.c
@@ -143,10 +143,12 @@ void levinson_durbin(float R[],    /* order+1 autocorrelation coeff */
                      float lpcs[], /* order+1 LPC's */
                      int order     /* order of the LPC analysis */
 ) {
-  float a[order + 1][order + 1];
+  float a[LPC_MAX_ORDER + 1][LPC_MAX_ORDER + 1];
   float sum, e, k;
   int i, j; /* loop variables */
 
+  assert(order <= LPC_MAX_ORDER);
+
   e = R[0]; /* Equation 38a, Makhoul */
 
   for (i = 1; i <= order; i++) {
@@ -244,10 +246,11 @@ void find_aks(float Sn[], /* Nsam samples with order sample memory */
               float *E    /* residual energy */
 ) {
   float Wn[LPC_MAX_N]; /* windowed frame of Nsam speech samples */
-  float R[order + 1];  /* order+1 autocorrelation values of Sn[] */
+  float R[LPC_MAX_ORDER + 1];  /* order+1 autocorrelation values of Sn[] */
   int i;
 
   assert(Nsam < LPC_MAX_N);
+  assert(order <= LPC_MAX_ORDER);
 
   hanning_window(Sn, Wn, Nsam);
   autocorrelate(Wn, R, Nsam, order);
diff --git a/src/nlp.c b/src/nlp.c
index 53cf040..48ba7c9 100644
--- a/src/nlp.c
+++ b/src/nlp.c
@@ -252,7 +252,8 @@ float nlp(
     m /= 2;
     n /= 2;
 
-    float Sn8k[n];
+    float Sn8k[PMAX_M];
+    assert(n <= PMAX_M);
     fdmdv_16_to_8(Sn8k, &nlp->Sn16k[FDMDV_OS_TAPS_16K], n);
 
     /* Square latest input samples */
diff --git a/src/codec2.c b/src/codec2.c
index b27626a..0ab7cbf 100644
--- a/src/codec2.c
+++ b/src/codec2.c
@@ -1450,7 +1450,7 @@ void codec2_encode_700c(struct CODEC2 *c2, unsigned char *bits,
     analyse_one_frame(c2, &model, &speech[i * c2->n_samp]);
   }
 
-  int K = 20;
+  enum { K = 20 };
   float rate_K_vec[K], mean;
   float rate_K_vec_no_mean[K], rate_K_vec_no_mean_[K];
 
@@ -1511,7 +1511,7 @@ void codec2_decode_700c(struct CODEC2 *c2, short speech[],
   indexes[2] = unpack_natural_or_gray(bits, &nbit, 4, 0);
   indexes[3] = unpack_natural_or_gray(bits, &nbit, 6, 0);
 
-  int M = 4;
+  enum { M = 4 };
   COMP HH[M][MAX_AMP + 1];
   float interpolated_surface_[M][NEWAMP1_K];
 
@@ -1883,15 +1883,19 @@ void codec2_load_codebook(struct CODEC2 *codec2_state, int num,
   }
   // fprintf(stderr, "reading newamp1vq_cb[%d] k=%d m=%d\n", num,
   // newamp1vq_cb[num].k, newamp1vq_cb[num].m);
-  float tmp[newamp1vq_cb[num].k * newamp1vq_cb[num].m];
-  int nread =
-      fread(tmp, sizeof(float), newamp1vq_cb[num].k * newamp1vq_cb[num].m, f);
+  int count = newamp1vq_cb[num].k * newamp1vq_cb[num].m;
+  float *tmp = (float *)malloc(sizeof(float) * count);
+  if (tmp == NULL) {
+    fprintf(stderr, "error allocating codebook tmp\n");
+    exit(1);
+  }
+  int nread = fread(tmp, sizeof(float), count, f);
   float *p = (float *)newamp1vq_cb[num].cb;
-  for (int i = 0; i < newamp1vq_cb[num].k * newamp1vq_cb[num].m; i++)
-    p[i] = tmp[i];
+  for (int i = 0; i < count; i++) p[i] = tmp[i];
   // fprintf(stderr, "nread = %d %f %f\n", nread, newamp1vq_cb[num].cb[0],
   // newamp1vq_cb[num].cb[1]);
-  assert(nread == newamp1vq_cb[num].k * newamp1vq_cb[num].m);
+  assert(nread == count);
+  free(tmp);
   fclose(f);
 }
 #endif
diff --git a/src/freedv_1600.c b/src/freedv_1600.c
index 8b2eac4..52edcd0 100644
--- a/src/freedv_1600.c
+++ b/src/freedv_1600.c
@@ -69,7 +69,9 @@ void freedv_1600_open(struct freedv *f) {
 void freedv_comptx_fdmdv_1600(struct freedv *f, COMP mod_out[]) {
   int i, j;
   int data, codeword1, data_flag_index;
-  COMP tx_fdm[f->n_nat_modem_samples];
+  COMP *tx_fdm =
+      (COMP *)MALLOC(sizeof(COMP) * f->n_nat_modem_samples);
+  assert(tx_fdm != NULL);
 
   // spare bit in frame that codec defines.  Use this 1
   // bit/frame to send txt messages
@@ -144,6 +146,8 @@ void freedv_comptx_fdmdv_1600(struct freedv *f, COMP mod_out[]) {
 
   for (i = 0; i < f->n_nom_modem_samples; i++)
     mod_out[i] = fcmult(FDMDV_SCALE, tx_fdm[i]);
+
+  FREE(tx_fdm);
 }
 
 int freedv_comprx_fdmdv_1600(struct freedv *f, COMP demod_in[]) {
@@ -155,7 +159,8 @@ int freedv_comprx_fdmdv_1600(struct freedv *f, COMP demod_in[]) {
   int reliable_sync_bit;
   int rx_status = 0;
 
-  COMP ademod_in[f->nin];
+  COMP *ademod_in = (COMP *)MALLOC(sizeof(COMP) * f->nin);
+  assert(ademod_in != NULL);
   for (i = 0; i < f->nin; i++)
     ademod_in[i] = fcmult(1.0 / FDMDV_SCALE, demod_in[i]);
 
@@ -227,7 +232,10 @@ int freedv_comprx_fdmdv_1600(struct freedv *f, COMP demod_in[]) {
         rx_status |= FREEDV_RX_BITS;
       } else {
         int test_frame_sync, bit_errors, ntest_bits, k;
-        short error_pattern[fdmdv_error_pattern_size(f->fdmdv)];
+        int error_pattern_size = fdmdv_error_pattern_size(f->fdmdv);
+        short *error_pattern =
+            (short *)MALLOC(sizeof(short) * error_pattern_size);
+        assert(error_pattern != NULL);
 
         for (k = 0; k < 2; k++) {
           /* test frames, so lets sync up to the test frames and count any
@@ -249,13 +257,15 @@ int freedv_comprx_fdmdv_1600(struct freedv *f, COMP demod_in[]) {
               if (f->freedv_put_error_pattern != NULL) {
                 (*f->freedv_put_error_pattern)(
                     f->error_pattern_callback_state, error_pattern,
-                    fdmdv_error_pattern_size(f->fdmdv));
+                    error_pattern_size);
               }
             }
             f->test_frame_count++;
             if (f->test_frame_count == 4) f->test_frame_count = 0;
           }
         }
+
+        FREE(error_pattern);
       } /* if (test_frames == 0) .... */
     }
 
@@ -268,5 +278,6 @@ int freedv_comprx_fdmdv_1600(struct freedv *f, COMP demod_in[]) {
 
   } /* if (sync) .... */
 
+  FREE(ademod_in);
   return rx_status;
 }
diff --git a/src/freedv_2020.c b/src/freedv_2020.c
index f1dee28..1bc12e4 100644
--- a/src/freedv_2020.c
+++ b/src/freedv_2020.c
@@ -155,7 +155,8 @@ void freedv_comptx_2020(struct freedv *f, COMP mod_out[]) {
   int i, k;
 
   int data_bits_per_frame = f->ldpc->data_bits_per_frame;
-  uint8_t tx_bits[data_bits_per_frame];
+  uint8_t *tx_bits = (uint8_t *)MALLOC(data_bits_per_frame);
+  assert(tx_bits != NULL);
 
   memcpy(tx_bits, f->tx_payload_bits, data_bits_per_frame);
 
@@ -164,7 +165,11 @@ void freedv_comptx_2020(struct freedv *f, COMP mod_out[]) {
   // added to each frame after interleaver as done it's thing
 
   int nspare = f->ofdm_ntxtbits;
-  uint8_t txt_bits[nspare];
+  uint8_t *txt_bits = NULL;
+  if (nspare > 0) {
+    txt_bits = (uint8_t *)MALLOC(nspare);
+    assert(txt_bits != NULL);
+  }
 
   for (k = 0; k < nspare; k++) {
     if (f->nvaricode_bits == 0) {
@@ -188,17 +193,25 @@ void freedv_comptx_2020(struct freedv *f, COMP mod_out[]) {
   /* optionally replace codec payload bits with test frames known to rx */
 
   if (f->test_frames) {
-    uint8_t payload_data_bits[data_bits_per_frame];
-    ofdm_generate_payload_data_bits(payload_data_bits, data_bits_per_frame);
+    uint8_t *payload_data_bits =
+        (uint8_t *)MALLOC(data_bits_per_frame);
+    assert(payload_data_bits != NULL);
+    ofdm_generate_payload_data_bits(payload_data_bits,
+                                    data_bits_per_frame);
 
     for (i = 0; i < data_bits_per_frame; i++) {
       tx_bits[i] = payload_data_bits[i];
     }
+
+    FREE(payload_data_bits);
   }
 
   /* OK now ready to LDPC encode, interleave, and OFDM modulate */
   ofdm_ldpc_interleave_tx(f->ofdm, f->ldpc, (complex float *)mod_out, tx_bits,
                           txt_bits);
+
+  FREE(txt_bits);
+  FREE(tx_bits);
 }
 
 int freedv_comprx_2020(struct freedv *f, COMP demod_in[]) {
@@ -213,10 +226,20 @@ int freedv_comprx_2020(struct freedv *f, COMP demod_in[]) {
   int coded_syms_per_frame = ldpc->coded_bits_per_frame / ofdm->bps;
   COMP *codeword_symbols = f->codeword_symbols;
   float *codeword_amps = f->codeword_amps;
-  int rx_bits[f->ofdm_bitsperframe];
-  short txt_bits[f->ofdm_ntxtbits];
-  COMP payload_syms[coded_syms_per_frame];
-  float payload_amps[coded_syms_per_frame];
+  int *rx_bits =
+      (int *)MALLOC(sizeof(int) * f->ofdm_bitsperframe);
+  assert(rx_bits != NULL);
+  short *txt_bits = NULL;
+  if (f->ofdm_ntxtbits > 0) {
+    txt_bits = (short *)MALLOC(sizeof(short) * f->ofdm_ntxtbits);
+    assert(txt_bits != NULL);
+  }
+  COMP *payload_syms =
+      (COMP *)MALLOC(sizeof(COMP) * coded_syms_per_frame);
+  float *payload_amps =
+      (float *)MALLOC(sizeof(float) * coded_syms_per_frame);
+  assert(payload_syms != NULL);
+  assert(payload_amps != NULL);
 
   int rx_status = 0;
 
@@ -225,7 +248,9 @@ int freedv_comprx_2020(struct freedv *f, COMP demod_in[]) {
   int Ncoded;
   int iter = 0;
   int parityCheckCount = 0;
-  uint8_t rx_uw[f->ofdm_nuwbits];
+  uint8_t *rx_uw = (uint8_t *)MALLOC(f->ofdm_nuwbits);
+  assert(rx_uw != NULL);
+  memset(rx_uw, 0, f->ofdm_nuwbits);
 
   f->sync = 0;
 
@@ -268,16 +293,24 @@ int freedv_comprx_2020(struct freedv *f, COMP demod_in[]) {
 
     /* run de-interleaver */
 
-    COMP codeword_symbols_de[coded_syms_per_frame];
-    float codeword_amps_de[coded_syms_per_frame];
+    COMP *codeword_symbols_de =
+        (COMP *)MALLOC(sizeof(COMP) * coded_syms_per_frame);
+    float *codeword_amps_de =
+        (float *)MALLOC(sizeof(float) * coded_syms_per_frame);
+    assert(codeword_symbols_de != NULL);
+    assert(codeword_amps_de != NULL);
 
     gp_deinterleave_comp(codeword_symbols_de, codeword_symbols,
                          coded_syms_per_frame);
     gp_deinterleave_float(codeword_amps_de, codeword_amps,
                           coded_syms_per_frame);
 
-    float llr[coded_bits_per_frame];
-    uint8_t out_char[coded_bits_per_frame];
+    float *llr =
+        (float *)MALLOC(sizeof(float) * coded_bits_per_frame);
+    uint8_t *out_char =
+        (uint8_t *)MALLOC(coded_bits_per_frame);
+    assert(llr != NULL);
+    assert(out_char != NULL);
 
     if (f->test_frames) {
       Nerrs_raw =
@@ -293,8 +326,11 @@ int freedv_comprx_2020(struct freedv *f, COMP demod_in[]) {
       rx_status |= FREEDV_RX_BIT_ERRORS;
 
     if (f->test_frames) {
-      uint8_t payload_data_bits[data_bits_per_frame];
-      ofdm_generate_payload_data_bits(payload_data_bits, data_bits_per_frame);
+      uint8_t *payload_data_bits =
+          (uint8_t *)MALLOC(data_bits_per_frame);
+      assert(payload_data_bits != NULL);
+      ofdm_generate_payload_data_bits(payload_data_bits,
+                                      data_bits_per_frame);
       count_errors_protection_mode(ldpc->protection_mode, &Nerrs_coded, &Ncoded,
                                    payload_data_bits, out_char,
                                    data_bits_per_frame);
@@ -302,6 +338,8 @@ int freedv_comprx_2020(struct freedv *f, COMP demod_in[]) {
       f->total_bits_coded += Ncoded;
       if (Nerrs_coded) f->total_packet_errors++;
       f->total_packets++;
+
+      FREE(payload_data_bits);
     } else {
       memcpy(f->rx_payload_bits, out_char, data_bits_per_frame);
     }
@@ -340,6 +378,11 @@ int freedv_comprx_2020(struct freedv *f, COMP demod_in[]) {
     ofdm_get_demod_stats(f->ofdm, &f->stats, ofdm->rx_np,
                          ofdm->rowsperframe * ofdm->nc);
     f->snr_est = f->stats.snr_est;
+
+    FREE(out_char);
+    FREE(llr);
+    FREE(codeword_amps_de);
+    FREE(codeword_symbols_de);
   }
 
   /* iterate state machine and update nin for next call */
@@ -358,6 +401,11 @@ int freedv_comprx_2020(struct freedv *f, COMP demod_in[]) {
             parityCheckCount, rx_sync_flags_to_text[rx_status]);
   }
 
+  FREE(rx_uw);
+  FREE(payload_amps);
+  FREE(payload_syms);
+  FREE(txt_bits);
+  FREE(rx_bits);
   return rx_status;
 }
 #endif
diff --git a/src/freedv_700.c b/src/freedv_700.c
index a7d7aac..4b27dcc 100644
--- a/src/freedv_700.c
+++ b/src/freedv_700.c
@@ -86,7 +86,8 @@ void freedv_700c_open(struct freedv *f) {
 
 void freedv_comptx_700c(struct freedv *f, COMP mod_out[]) {
   int i;
-  COMP tx_fdm[f->n_nat_modem_samples];
+  assert(f->n_nat_modem_samples <= COHPSK_NOM_SAMPLES_PER_FRAME);
+  COMP tx_fdm[COHPSK_NOM_SAMPLES_PER_FRAME];
   int tx_bits[COHPSK_BITS_PER_FRAME];
 
   /* earlier modems used one bit per int for unpacked bits */
@@ -263,7 +264,11 @@ void freedv_comptx_ofdm(struct freedv *f, COMP mod_out[]) {
 
   /* Generate Varicode txt bits (if used), waren't protected by FEC */
   nspare = f->ofdm_ntxtbits;
-  uint8_t txt_bits[nspare];
+  uint8_t *txt_bits = NULL;
+  if (nspare > 0) {
+    txt_bits = (uint8_t *)MALLOC(nspare);
+    assert(txt_bits != NULL);
+  }
 
   for (k = 0; k < nspare; k++) {
     if (f->nvaricode_bits == 0) {
@@ -286,17 +291,24 @@ void freedv_comptx_ofdm(struct freedv *f, COMP mod_out[]) {
 
   /* optionally replace payload bits with test frames known to rx */
   if (f->test_frames) {
-    uint8_t payload_data_bits[f->bits_per_modem_frame];
-    ofdm_generate_payload_data_bits(payload_data_bits, f->bits_per_modem_frame);
+    uint8_t *payload_data_bits =
+        (uint8_t *)MALLOC(f->bits_per_modem_frame);
+    assert(payload_data_bits != NULL);
+    ofdm_generate_payload_data_bits(payload_data_bits,
+                                    f->bits_per_modem_frame);
 
     for (i = 0; i < f->bits_per_modem_frame; i++) {
       f->tx_payload_bits[i] = payload_data_bits[i];
     }
+
+    FREE(payload_data_bits);
   }
 
   /* OK now ready to LDPC encode, interleave, and OFDM modulate */
   ofdm_ldpc_interleave_tx(f->ofdm, f->ldpc, (complex float *)mod_out,
                           f->tx_payload_bits, txt_bits);
+
+  FREE(txt_bits);
 }
 
 int freedv_comprx_700c(struct freedv *f, COMP demod_in_8kHz[]) {
@@ -311,11 +323,13 @@ int freedv_comprx_700c(struct freedv *f, COMP demod_in_8kHz[]) {
   // freedv_nin(f): input samples at Fs=8000 Hz
   // f->nin: input samples at Fs=7500 Hz
 
-  COMP demod_in[freedv_nin(f)];
+  int nin8 = freedv_nin(f);
+  COMP *demod_in = (COMP *)MALLOC(sizeof(COMP) * nin8);
+  assert(demod_in != NULL);
 
-  for (i = 0; i < freedv_nin(f); i++) demod_in[i] = demod_in_8kHz[i];
+  for (i = 0; i < nin8; i++) demod_in[i] = demod_in_8kHz[i];
 
-  i = quisk_cfInterpDecim((complex float *)demod_in, freedv_nin(f),
+  i = quisk_cfInterpDecim((complex float *)demod_in, nin8,
                           f->ptFilter8000to7500, 15, 16);
 
   for (i = 0; i < f->nin; i++)
@@ -402,6 +416,7 @@ int freedv_comprx_700c(struct freedv *f, COMP demod_in_8kHz[]) {
     }
   }
 
+  FREE(demod_in);
   return rx_status;
 }
 
@@ -431,16 +446,26 @@ int freedv_comp_short_rx_ofdm(struct freedv *f, void *demod_in_8kHz,
   complex float *rx_syms = (complex float *)f->rx_syms;
   float *rx_amps = f->rx_amps;
 
-  int rx_bits[Nbitsperframe];
-  short txt_bits[f->ofdm_ntxtbits];
-  COMP payload_syms[Npayloadsymsperpacket];
-  float payload_amps[Npayloadsymsperpacket];
+  int *rx_bits = (int *)MALLOC(sizeof(int) * Nbitsperframe);
+  assert(rx_bits != NULL);
+  short *txt_bits = NULL;
+  if (f->ofdm_ntxtbits > 0) {
+    txt_bits = (short *)MALLOC(sizeof(short) * f->ofdm_ntxtbits);
+    assert(txt_bits != NULL);
+  }
+  COMP *payload_syms =
+      (COMP *)MALLOC(sizeof(COMP) * Npayloadsymsperpacket);
+  float *payload_amps =
+      (float *)MALLOC(sizeof(float) * Npayloadsymsperpacket);
+  assert(payload_syms != NULL);
+  assert(payload_amps != NULL);
 
   int Nerrs_raw = 0;
   int Nerrs_coded = 0;
   int iter = 0;
   int parityCheckCount = 0;
-  uint8_t rx_uw[f->ofdm_nuwbits];
+  uint8_t *rx_uw = (uint8_t *)MALLOC(f->ofdm_nuwbits);
+  assert(rx_uw != NULL);
 
   float new_gain = gain / f->ofdm->amp_scale;
 
@@ -494,15 +519,23 @@ int freedv_comp_short_rx_ofdm(struct freedv *f, void *demod_in_8kHz,
           ofdm, rx_syms, rx_amps, payload_syms, payload_amps, txt_bits,
           &txt_sym_index);
 
-      COMP payload_syms_de[Npayloadsymsperpacket];
-      float payload_amps_de[Npayloadsymsperpacket];
+      COMP *payload_syms_de =
+          (COMP *)MALLOC(sizeof(COMP) * Npayloadsymsperpacket);
+      float *payload_amps_de =
+          (float *)MALLOC(sizeof(float) * Npayloadsymsperpacket);
+      assert(payload_syms_de != NULL);
+      assert(payload_amps_de != NULL);
       gp_deinterleave_comp(payload_syms_de, payload_syms,
                            Npayloadsymsperpacket);
       gp_deinterleave_float(payload_amps_de, payload_amps,
                             Npayloadsymsperpacket);
 
-      float llr[Npayloadbitsperpacket];
-      uint8_t decoded_codeword[Npayloadbitsperpacket];
+      float *llr =
+          (float *)MALLOC(sizeof(float) * Npayloadbitsperpacket);
+      uint8_t *decoded_codeword =
+          (uint8_t *)MALLOC(Npayloadbitsperpacket);
+      assert(llr != NULL);
+      assert(decoded_codeword != NULL);
       symbols_to_llrs(llr, payload_syms_de, payload_amps_de, EsNo,
                       ofdm->mean_amp, Npayloadsymsperpacket);
       ldpc_decode_frame(ldpc, &parityCheckCount, &iter, decoded_codeword, llr);
@@ -532,8 +565,11 @@ int freedv_comp_short_rx_ofdm(struct freedv *f, void *demod_in_8kHz,
         f->total_bits += Npayloadbitsperpacket;
 
         /* coded errors from decoded bits */
-        uint8_t payload_data_bits[Ndatabitsperpacket];
-        ofdm_generate_payload_data_bits(payload_data_bits, Ndatabitsperpacket);
+        uint8_t *payload_data_bits =
+            (uint8_t *)MALLOC(Ndatabitsperpacket);
+        assert(payload_data_bits != NULL);
+        ofdm_generate_payload_data_bits(payload_data_bits,
+                                        Ndatabitsperpacket);
         if (strlen(ofdm->data_mode)) {
           uint16_t tx_crc16 =
               freedv_crc16_unpacked(payload_data_bits, Ndatabitsperpacket - 16);
@@ -547,6 +583,8 @@ int freedv_comp_short_rx_ofdm(struct freedv *f, void *demod_in_8kHz,
         f->total_bits_coded += Ndatabitsperpacket;
         if (Nerrs_coded) f->total_packet_errors++;
         f->total_packets++;
+
+        FREE(payload_data_bits);
       }
 
       /* decode txt bits (if used) */
@@ -566,6 +604,11 @@ int freedv_comp_short_rx_ofdm(struct freedv *f, void *demod_in_8kHz,
 
       ofdm_get_demod_stats(ofdm, &f->stats, rx_syms, Nsymsperpacket);
       f->snr_est = f->stats.snr_est;
+
+      FREE(decoded_codeword);
+      FREE(llr);
+      FREE(payload_amps_de);
+      FREE(payload_syms_de);
     } /* complete packet */
 
     if ((ofdm->np == 1) && (ofdm->modem_frame == 0)) {
@@ -615,5 +658,10 @@ int freedv_comp_short_rx_ofdm(struct freedv *f, void *demod_in_8kHz,
             rx_sync_flags_to_text[rx_status]);
   }
 
+  FREE(rx_uw);
+  FREE(payload_amps);
+  FREE(payload_syms);
+  FREE(txt_bits);
+  FREE(rx_bits);
   return rx_status;
 }
diff --git a/src/freedv_api.c b/src/freedv_api.c
index 3c812ca..aaf3651 100644
--- a/src/freedv_api.c
+++ b/src/freedv_api.c
@@ -264,10 +264,12 @@ void freedv_close(struct freedv *freedv) {
 static void codec2_encode_upacked(struct freedv *f, uint8_t unpacked_bits[],
                                   short speech_in[]) {
   int n_packed = (f->bits_per_codec_frame + 7) / 8;
-  uint8_t packed_codec_bits[n_packed];
+  uint8_t *packed_codec_bits = (uint8_t *)MALLOC(n_packed);
+  assert(packed_codec_bits != NULL);
 
   codec2_encode(f->codec2, packed_codec_bits, speech_in);
   freedv_unpack(unpacked_bits, packed_codec_bits, f->bits_per_codec_frame);
+  FREE(packed_codec_bits);
 }
 
 static int is_ofdm_mode(struct freedv *f) {
@@ -324,7 +326,7 @@ static int is_ofdm_data_mode(struct freedv *f) {
 
 void freedv_tx(struct freedv *f, short mod_out[], short speech_in[]) {
   assert(f != NULL);
-  COMP tx_fdm[f->n_nom_modem_samples];
+  COMP *tx_fdm = NULL;
   int i;
 
   /* FSK and MEFSK/FMFSK modems work only on real samples. It's simpler to just
@@ -343,8 +345,11 @@ void freedv_tx(struct freedv *f, short mod_out[], short speech_in[]) {
     }
     freedv_tx_fsk_voice(f, mod_out);
   } else {
+    tx_fdm = (COMP *)MALLOC(sizeof(COMP) * f->n_nom_modem_samples);
+    assert(tx_fdm != NULL);
     freedv_comptx(f, tx_fdm, speech_in);
     for (i = 0; i < f->n_nom_modem_samples; i++) mod_out[i] = tx_fdm[i].real;
+    FREE(tx_fdm);
   }
 }
 
@@ -446,20 +451,25 @@ void freedv_unpack(uint8_t *bits, uint8_t *bytes, int nbits) {
 unsigned short freedv_crc16_unpacked(unsigned char unpacked_bits[], int nbits) {
   assert((nbits % 8) == 0);
   int nbytes = nbits / 8;
-  uint8_t packed_bytes[nbytes];
+  uint8_t *packed_bytes = (uint8_t *)MALLOC(nbytes);
+  assert(packed_bytes != NULL);
   freedv_pack(packed_bytes, unpacked_bits, nbits);
-  return freedv_gen_crc16(packed_bytes, nbytes);
+  unsigned short crc = freedv_gen_crc16(packed_bytes, nbytes);
+  FREE(packed_bytes);
+  return crc;
 }
 
 /* Return non-zero if CRC16 of a frame of unpacked bits is correct */
 int freedv_check_crc16_unpacked(unsigned char unpacked_bits[], int nbits) {
   assert((nbits % 8) == 0);
   int nbytes = nbits / 8;
-  uint8_t packed_bytes[nbytes];
+  uint8_t *packed_bytes = (uint8_t *)MALLOC(nbytes);
+  assert(packed_bytes != NULL);
   freedv_pack(packed_bytes, unpacked_bits, nbits);
   uint16_t tx_crc16 =
       (packed_bytes[nbytes - 2] << 8) | packed_bytes[nbytes - 1];
   uint16_t rx_crc16 = freedv_crc16_unpacked(unpacked_bits, nbits - 16);
+  FREE(packed_bytes);
   return tx_crc16 == rx_crc16;
 }
 
@@ -496,7 +506,7 @@ void freedv_rawdatacomptx(struct freedv *f, COMP mod_out[],
 void freedv_rawdatatx(struct freedv *f, short mod_out[],
                       unsigned char *packed_payload_bits) {
   assert(f != NULL);
-  COMP mod_out_comp[f->n_nat_modem_samples];
+  COMP *mod_out_comp = NULL;
 
   /* Some FSK modes used packed bits, and coincidentally support real samples
    * natively */
@@ -509,11 +519,15 @@ void freedv_rawdatatx(struct freedv *f, short mod_out[],
     return; /* output is already real */
   }
 
+  mod_out_comp = (COMP *)MALLOC(sizeof(COMP) * f->n_nat_modem_samples);
+  assert(mod_out_comp != NULL);
   freedv_rawdatacomptx(f, mod_out_comp, packed_payload_bits);
 
   /* convert complex to real */
   for (int i = 0; i < f->n_nat_modem_samples; i++)
     mod_out[i] = mod_out_comp[i].real;
+
+  FREE(mod_out_comp);
 }
 
 int freedv_rawdatapreamblecomptx(struct freedv *f, COMP mod_out[]) {
@@ -549,7 +563,9 @@ int freedv_rawdatapreamblecomptx(struct freedv *f, COMP mod_out[]) {
 
 int freedv_rawdatapreambletx(struct freedv *f, short mod_out[]) {
   assert(f != NULL);
-  COMP mod_out_comp[f->n_nat_modem_samples];
+  COMP *mod_out_comp =
+      (COMP *)MALLOC(sizeof(COMP) * f->n_nat_modem_samples);
+  assert(mod_out_comp != NULL);
 
   int npreamble_samples = freedv_rawdatapreamblecomptx(f, mod_out_comp);
   assert(npreamble_samples <= f->n_nat_modem_samples);
@@ -557,6 +573,7 @@ int freedv_rawdatapreambletx(struct freedv *f, short mod_out[]) {
   /* convert complex to real */
   for (int i = 0; i < npreamble_samples; i++) mod_out[i] = mod_out_comp[i].real;
 
+  FREE(mod_out_comp);
   return npreamble_samples;
 }
 
@@ -578,7 +595,9 @@ int freedv_rawdatapostamblecomptx(struct freedv *f, COMP mod_out[]) {
 
 int freedv_rawdatapostambletx(struct freedv *f, short mod_out[]) {
   assert(f != NULL);
-  COMP mod_out_comp[f->n_nat_modem_samples];
+  COMP *mod_out_comp =
+      (COMP *)MALLOC(sizeof(COMP) * f->n_nat_modem_samples);
+  assert(mod_out_comp != NULL);
 
   int npostamble_samples = freedv_rawdatapostamblecomptx(f, mod_out_comp);
   assert(npostamble_samples <= f->n_nat_modem_samples);
@@ -587,6 +606,7 @@ int freedv_rawdatapostambletx(struct freedv *f, short mod_out[]) {
   for (int i = 0; i < npostamble_samples; i++)
     mod_out[i] = mod_out_comp[i].real;
 
+  FREE(mod_out_comp);
   return npostamble_samples;
 }
 
@@ -767,11 +787,14 @@ int freedv_rx(struct freedv *f, short speech_out[], short demod_in[]) {
   if (FDV_MODE_ACTIVE(FREEDV_MODE_2400A, f->mode) ||
       FDV_MODE_ACTIVE(FREEDV_MODE_2400B, f->mode) ||
       FDV_MODE_ACTIVE(FREEDV_MODE_800XA, f->mode)) {
-    float rx_float[f->n_max_modem_samples];
+    float *rx_float = (float *)MALLOC(sizeof(float) * f->n_max_modem_samples);
+    assert(rx_float != NULL);
     for (i = 0; i < nin; i++) {
       rx_float[i] = ((float)demod_in[i]);
     }
-    return freedv_floatrx(f, speech_out, rx_float);
+    int ret = freedv_floatrx(f, speech_out, rx_float);
+    FREE(rx_float);
+    return ret;
   }
 
   if (FDV_MODE_ACTIVE(FREEDV_MODE_1600, f->mode) ||
@@ -781,13 +804,16 @@ int freedv_rx(struct freedv *f, short speech_out[], short demod_in[]) {
     float gain = 1.0f;
 
     assert(nin <= f->n_max_modem_samples);
-    COMP rx_fdm[f->n_max_modem_samples];
+    COMP *rx_fdm = (COMP *)MALLOC(sizeof(COMP) * f->n_max_modem_samples);
+    assert(rx_fdm != NULL);
 
     for (i = 0; i < nin; i++) {
       rx_fdm[i].real = gain * (float)demod_in[i];
       rx_fdm[i].imag = 0.0f;
     }
-    return freedv_comprx(f, speech_out, rx_fdm);
+    int ret = freedv_comprx(f, speech_out, rx_fdm);
+    FREE(rx_fdm);
+    return ret;
   }
 
   /* special low memory version for 700D, to help with stm32 port */
@@ -836,11 +862,14 @@ int freedv_comprx(struct freedv *f, short speech_out[], COMP demod_in[]) {
 #endif
   }
 
-  short demod_in_short[f->nin_prev];
+  short *demod_in_short = (short *)MALLOC(sizeof(short) * f->nin_prev);
+  assert(demod_in_short != NULL);
 
   for (int i = 0; i < f->nin_prev; i++) demod_in_short[i] = demod_in[i].real;
 
-  return freedv_bits_to_speech(f, speech_out, demod_in_short, rx_status);
+  int ret = freedv_bits_to_speech(f, speech_out, demod_in_short, rx_status);
+  FREE(demod_in_short);
+  return ret;
 }
 
 /* memory efficient real short version - just for 700D on the SM1000 */
@@ -870,10 +899,12 @@ int freedv_shortrx(struct freedv *f, short speech_out[], short demod_in[],
 static void codec2_decode_upacked(struct freedv *f, short speech_out[],
                                   uint8_t unpacked_bits[]) {
   int n_packed = (f->bits_per_codec_frame + 7) / 8;
-  uint8_t packed_codec_bits[n_packed];
+  uint8_t *packed_codec_bits = (uint8_t *)MALLOC(n_packed);
+  assert(packed_codec_bits != NULL);
 
   freedv_pack(packed_codec_bits, unpacked_bits, f->bits_per_codec_frame);
   codec2_decode(f->codec2, speech_out, packed_codec_bits);
+  FREE(packed_codec_bits);
 }
 
 /*---------------------------------------------------------------------------* \
@@ -922,12 +953,14 @@ int freedv_bits_to_speech(struct freedv *f, short speech_out[],
            rate, so we need to resample */
         nout = 2 * f->nin_prev;
         assert(nout <= freedv_get_n_max_speech_samples(f));
-        float tmp[nout];
+        float *tmp = (float *)MALLOC(sizeof(float) * nout);
+        assert(tmp != NULL);
         for (int i = 0; i < nout / 2; i++)
           f->passthrough_2020[FDMDV_OS_TAPS_16K + i] = demod_in[i];
         fdmdv_8_to_16(tmp, &f->passthrough_2020[FDMDV_OS_TAPS_16K], nout / 2);
         for (int i = 0; i < nout; i++)
           speech_out[i] = f->passthrough_gain * tmp[i];
+        FREE(tmp);
       } else {
         /* Speech and modem rates might be different */
         int rate_factor = f->modem_sample_rate / f->speech_sample_rate;
@@ -1041,14 +1074,17 @@ int freedv_rawdatarx(struct freedv *f, unsigned char *packed_payload_bits,
   assert(f != NULL);
   int nin = freedv_nin(f);
   assert(nin <= f->n_max_modem_samples);
-  COMP demod_in_comp[f->n_max_modem_samples];
+  COMP *demod_in_comp = (COMP *)MALLOC(sizeof(COMP) * f->n_max_modem_samples);
+  assert(demod_in_comp != NULL);
 
   for (int i = 0; i < nin; i++) {
     demod_in_comp[i].real = (float)demod_in[i];
     demod_in_comp[i].imag = 0.0;
   }
 
-  return freedv_rawdatacomprx(f, packed_payload_bits, demod_in_comp);
+  int ret = freedv_rawdatacomprx(f, packed_payload_bits, demod_in_comp);
+  FREE(demod_in_comp);
+  return ret;
 }
 
 /* a way to receive raw frames of bytes, or speech data that will be
diff --git a/src/freedv_fsk.c b/src/freedv_fsk.c
index 0613263..a2b7a74 100644
--- a/src/freedv_fsk.c
+++ b/src/freedv_fsk.c
@@ -411,7 +411,8 @@ void freedv_tx_fsk_ldpc_framer(struct freedv *f, uint8_t frame[],
 /* FreeDV FSK_LDPC mode tx */
 void freedv_tx_fsk_ldpc_data(struct freedv *f, COMP mod_out[]) {
   int bits_per_frame = freedv_tx_fsk_ldpc_bits_per_frame(f);
-  uint8_t frame[bits_per_frame];
+  uint8_t *frame = (uint8_t *)MALLOC(bits_per_frame);
+  assert(frame != NULL);
 
   assert(f->mode == FREEDV_MODE_FSK_LDPC);
 
@@ -423,13 +424,16 @@ void freedv_tx_fsk_ldpc_data(struct freedv *f, COMP mod_out[]) {
     mod_out[i].real *= f->tx_amp;
     mod_out[i].imag *= f->tx_amp;
   }
+
+  FREE(frame);
 }
 
 void freedv_tx_fsk_ldpc_data_preamble(struct freedv *f, COMP mod_out[],
                                       int npreamble_bits,
                                       int npreamble_samples) {
   struct FSK *fsk = f->fsk;
-  uint8_t preamble[npreamble_bits];
+  uint8_t *preamble = (uint8_t *)MALLOC(npreamble_bits);
+  assert(preamble != NULL);
   // cycle through all 2 and 4FSK symbols, not sure if this is better than
   // random
   int sym = 0;
@@ -445,13 +449,17 @@ void freedv_tx_fsk_ldpc_data_preamble(struct freedv *f, COMP mod_out[],
     mod_out[i].real *= f->tx_amp;
     mod_out[i].imag *= f->tx_amp;
   }
+
+  FREE(preamble);
 }
 
 /* FreeDV FSK_LDPC mode rx */
 int freedv_rx_fsk_ldpc_data(struct freedv *f, COMP demod_in[]) {
   int bits_per_frame = freedv_tx_fsk_ldpc_bits_per_frame(f);
   struct FSK *fsk = f->fsk;
-  float rx_filt[fsk->mode * fsk->Nsym];
+  int rx_filt_size = fsk->mode * fsk->Nsym;
+  float *rx_filt = (float *)MALLOC(sizeof(float) * rx_filt_size);
+  assert(rx_filt != NULL);
   int rx_status = 0, seq = 0;
 
   /* Couple of layers of buffers to move chunks of fsk->Nbits into a
@@ -551,12 +559,15 @@ int freedv_rx_fsk_ldpc_data(struct freedv *f, COMP demod_in[]) {
       /* We may have a valid frame, based on the number on UW errors.  Lets do a
        * LDPC decode and check the CRC */
 
-      uint8_t decoded_codeword[f->ldpc->ldpc_coded_bits_per_frame];
+      uint8_t *decoded_codeword =
+          (uint8_t *)MALLOC(f->ldpc->ldpc_coded_bits_per_frame);
+      assert(decoded_codeword != NULL);
       iter = run_ldpc_decoder(
           f->ldpc, decoded_codeword,
           &f->twoframes_llr[f->fsk_ldpc_best_location + sizeof(fsk_ldpc_uw)],
           &parityCheckCount);
       memcpy(f->rx_payload_bits, decoded_codeword, f->bits_per_modem_frame);
+      FREE(decoded_codeword);
 
       /* check CRC */
       if (freedv_check_crc16_unpacked(f->rx_payload_bits,
@@ -574,12 +585,15 @@ int freedv_rx_fsk_ldpc_data(struct freedv *f, COMP demod_in[]) {
     if (f->fsk_ldpc_state == 1) {
       if (f->test_frames) {
         /* regenerate tx test frame */
-        uint8_t tx_frame[bits_per_frame];
+        uint8_t *tx_frame = (uint8_t *)MALLOC(bits_per_frame);
+        assert(tx_frame != NULL);
         memcpy(tx_frame, fsk_ldpc_uw, sizeof(fsk_ldpc_uw));
         ofdm_generate_payload_data_bits(tx_frame + sizeof(fsk_ldpc_uw),
                                         f->bits_per_modem_frame);
         int bytes_per_modem_frame = f->bits_per_modem_frame / 8;
-        uint8_t tx_bytes[bytes_per_modem_frame];
+        uint8_t *tx_bytes =
+            (uint8_t *)MALLOC(bytes_per_modem_frame);
+        assert(tx_bytes != NULL);
         freedv_pack(tx_bytes, tx_frame + sizeof(fsk_ldpc_uw),
                     f->bits_per_modem_frame);
         uint16_t tx_crc16 =
@@ -605,6 +619,9 @@ int freedv_rx_fsk_ldpc_data(struct freedv *f, COMP demod_in[]) {
         f->total_bits_coded += f->bits_per_modem_frame;
         if (Nerrs_coded) f->total_packet_errors++;
         f->total_packets++;
+
+        FREE(tx_bytes);
+        FREE(tx_frame);
       }
 
       /* extract packet sequence numbers optionally placed in byte[0] */
@@ -631,6 +648,7 @@ int freedv_rx_fsk_ldpc_data(struct freedv *f, COMP demod_in[]) {
     if (f->fsk_ldpc_state == 1) rx_status |= FREEDV_RX_SYNC;
   }
 
+  FREE(rx_filt);
   return rx_status;
 }
 
@@ -657,7 +675,8 @@ int freedv_comprx_fsk(struct freedv *f, COMP demod_in[]) {
   } else {
     /* 2400B needs real input samples */
     int n = fmfsk_nin(f->fmfsk);
-    float demod_in_float[n];
+    float *demod_in_float = (float *)MALLOC(sizeof(float) * n);
+    assert(demod_in_float != NULL);
     for (i = 0; i < n; i++) {
       demod_in_float[i] = demod_in[i].real;
     }
@@ -666,6 +685,8 @@ int freedv_comprx_fsk(struct freedv *f, COMP demod_in[]) {
        the mapping to SNR in 8k is hard to determine */
     f->snr_est = f->fmfsk->snr_mean;
     f->nin = fmfsk_nin(f->fmfsk);
+
+    FREE(demod_in_float);
   }
 
   rx_status = fvhff_deframe_bits(f->deframer, f->rx_payload_bits, proto_bits,
@@ -700,11 +721,15 @@ int freedv_floatrx(struct freedv *f, short speech_out[], float demod_in[]) {
 
   assert(nin <= f->n_max_modem_samples);
 
-  COMP rx_fdm[f->n_max_modem_samples];
+  COMP *rx_fdm =
+      (COMP *)MALLOC(sizeof(COMP) * f->n_max_modem_samples);
+  assert(rx_fdm != NULL);
   for (i = 0; i < nin; i++) {
     rx_fdm[i].real = demod_in[i];
     rx_fdm[i].imag = 0;
   }
 
-  return freedv_comprx(f, speech_out, rx_fdm);
+  int ret = freedv_comprx(f, speech_out, rx_fdm);
+  FREE(rx_fdm);
+  return ret;
 }
diff --git a/src/fsk.c b/src/fsk.c
index fe83cc6..2ee3050 100644
--- a/src/fsk.c
+++ b/src/fsk.c
@@ -69,6 +69,7 @@
 #include <stdlib.h>
 
 #include "comp_prim.h"
+#include "debug_alloc.h"
 #include "kiss_fftr.h"
 #include "modem_probe.h"
 
@@ -286,7 +287,8 @@ void fsk_mod(struct FSK *fsk, float fsk_out[], uint8_t tx_bits[], int nbits) {
   int Ts = fsk->Ts;                     /* samples-per-symbol */
   int Fs = fsk->Fs;                     /* sample freq */
   int M = fsk->mode;
-  COMP dosc_f[M]; /* phase shift per sample */
+  COMP *dosc_f = (COMP *)MALLOC(sizeof(COMP) * M);
+  assert(dosc_f != NULL);
   COMP dph;       /* phase shift of current bit */
   size_t i, j, m, bit_i, sym;
 
@@ -320,6 +322,8 @@ void fsk_mod(struct FSK *fsk, float fsk_out[], uint8_t tx_bits[], int nbits) {
     }
   }
 
+  FREE(dosc_f);
+
   /* Normalize TX phase to prevent drift */
   tx_phase_c = comp_normalize(tx_phase_c);
 
@@ -344,7 +348,8 @@ void fsk_mod_c(struct FSK *fsk, COMP fsk_out[], uint8_t tx_bits[], int nbits) {
   int Ts = fsk->Ts;                     /* samples-per-symbol */
   int Fs = fsk->Fs;                     /* sample freq */
   int M = fsk->mode;
-  COMP dosc_f[M]; /* phase shift per sample */
+  COMP *dosc_f = (COMP *)MALLOC(sizeof(COMP) * M);
+  assert(dosc_f != NULL);
   COMP dph;       /* phase shift of current bit */
   size_t i, j, bit_i, sym;
   int m;
@@ -379,6 +384,8 @@ void fsk_mod_c(struct FSK *fsk, COMP fsk_out[], uint8_t tx_bits[], int nbits) {
     }
   }
 
+  FREE(dosc_f);
+
   /* Normalize TX phase to prevent drift */
   tx_phase_c = comp_normalize(tx_phase_c);
 
@@ -470,7 +477,8 @@ void fsk_demod_freq_est(struct FSK *fsk, COMP fsk_in[], float *freqs, int M) {
   float max;
   int imax;
   kiss_fft_cfg fft_cfg = fsk->fft_cfg;
-  int freqi[M];
+  int *freqi = (int *)MALLOC(sizeof(int) * M);
+  assert(freqi != NULL);
   int st, en, f_zero;
 
   kiss_fft_cpx *fftin = (kiss_fft_cpx *)malloc(sizeof(kiss_fft_cpx) * Ndft);
@@ -575,7 +583,8 @@ void fsk_demod_freq_est(struct FSK *fsk, COMP fsk_in[], float *freqs, int M) {
    * at tone spacings ----- */
 
   /* construct mask */
-  float mask[Ndft];
+  float *mask = (float *)MALLOC(sizeof(float) * Ndft);
+  assert(mask != NULL);
   for (i = 0; i < Ndft; i++) mask[i] = 0.0;
   for (i = 0; i < 3; i++) mask[i] = 1.0;
   int bin = 0;
@@ -611,6 +620,8 @@ void fsk_demod_freq_est(struct FSK *fsk, COMP fsk_in[], float *freqs, int M) {
 
   free(fftin);
   free(fftout);
+  FREE(mask);
+  FREE(freqi);
 }
 
 /* core demodulator function */
@@ -628,7 +639,8 @@ void fsk_demod_core(struct FSK *fsk, uint8_t rx_bits[], float rx_filt[],
   size_t i, j, m;
   float ft1;
 
-  COMP t[M]; /* complex number temps */
+  COMP *t = (COMP *)MALLOC(sizeof(COMP) * M);
+  assert(t != NULL);
   COMP t_c;  /* another complex temp */
   COMP *phi_c = fsk->phi_c;
   COMP *f_dc = fsk->f_dc;
@@ -681,21 +693,26 @@ void fsk_demod_core(struct FSK *fsk, uint8_t rx_bits[], float rx_filt[],
   }
 
   /* integrate over symbol period at a variety of offsets */
-  COMP f_int[M][(nsym + 1) * P];
-  for (i = 0; i < (nsym + 1) * P; i++) {
+  int fint_stride = (nsym + 1) * P;
+  COMP *f_int =
+      (COMP *)MALLOC(sizeof(COMP) * (size_t)M * fint_stride);
+  assert(f_int != NULL);
+  for (i = 0; i < (size_t)fint_stride; i++) {
     int st = i * Ts / P;
     int en = st + Ts - 1;
     for (m = 0; m < M; m++) {
-      f_int[m][i] = comp0();
+      f_int[m * fint_stride + i] = comp0();
       for (j = st; j <= en; j++)
-        f_int[m][i] = cadd(f_int[m][i], f_dc[m * Nmem + j]);
+        f_int[m * fint_stride + i] =
+            cadd(f_int[m * fint_stride + i], f_dc[m * Nmem + j]);
     }
   }
 
 #ifdef MODEMPROBE_ENABLE
   for (m = 0; m < M; m++) {
     snprintf(mp_name_tmp, NMP_NAME, "t_f%zd_int", m + 1);
-    modem_probe_samp_c(mp_name_tmp, &f_int[m][0], (nsym + 1) * P);
+    modem_probe_samp_c(mp_name_tmp, &f_int[m * fint_stride],
+                       fint_stride);
   }
 #endif
 
@@ -713,8 +730,10 @@ void fsk_demod_core(struct FSK *fsk, uint8_t rx_bits[], float rx_filt[],
     /* Get abs^2 of fx_int[i], and add 'em */
     ft1 = 0;
     for (m = 0; m < M; m++) {
-      ft1 += (f_int[m][i].real * f_int[m][i].real) +
-             (f_int[m][i].imag * f_int[m][i].imag);
+      ft1 += (f_int[m * fint_stride + i].real *
+              f_int[m * fint_stride + i].real) +
+             (f_int[m * fint_stride + i].imag *
+              f_int[m * fint_stride + i].imag);
     }
 
     /* Down shift and accumulate magic line */
@@ -727,6 +746,8 @@ void fsk_demod_core(struct FSK *fsk, uint8_t rx_bits[], float rx_filt[],
   /* Check for NaNs in the fine timing estimate, return if found */
   /* otherwise segfaults happen */
   if (isnan(t_c.real) || isnan(t_c.imag)) {
+    FREE(f_int);
+    FREE(t);
     return;
   }
 
@@ -766,7 +787,8 @@ void fsk_demod_core(struct FSK *fsk, uint8_t rx_bits[], float rx_filt[],
   int high_sample = (int)ceilf(rx_timing);
 
   /* Vars for finding the max-of-4 for each bit */
-  float tmax[M];
+  float *tmax = (float *)MALLOC(sizeof(float) * M);
+  assert(tmax != NULL);
 
 #ifdef EST_EBNO
   meanebno = 0;
@@ -779,8 +801,11 @@ void fsk_demod_core(struct FSK *fsk, uint8_t rx_bits[], float rx_filt[],
     /* resample at ideal sampling instant */
     int st = (i + 1) * P;
     for (m = 0; m < M; m++) {
-      t[m] = fcmult(1 - fract, f_int[m][st + low_sample]);
-      t[m] = cadd(t[m], fcmult(fract, f_int[m][st + high_sample]));
+      t[m] = fcmult(1 - fract,
+                    f_int[m * fint_stride + st + low_sample]);
+      t[m] = cadd(
+          t[m],
+          fcmult(fract, f_int[m * fint_stride + st + high_sample]));
       /* Figure mag^2 of each resampled fx_int */
       tmax[m] = (t[m].real * t[m].real) + (t[m].imag * t[m].imag);
     }
@@ -908,7 +933,8 @@ void fsk_demod_core(struct FSK *fsk, uint8_t rx_bits[], float rx_filt[],
         assert((i * M + m) < MODEM_STATS_ET_MAX);
         assert(ind >= 0);
         assert(ind < (nsym + 1) * P);
-        fsk->stats->rx_eye[i * M + m][j] = cabsolute(f_int[m][ind]);
+        fsk->stats->rx_eye[i * M + m][j] =
+            cabsolute(f_int[m * fint_stride + ind]);
       }
     }
   }
@@ -936,6 +962,10 @@ void fsk_demod_core(struct FSK *fsk, uint8_t rx_bits[], float rx_filt[],
   modem_probe_samp_f("t_EbNodB", &(fsk->EbNodB), 1);
   modem_probe_samp_f("t_ppm", &(fsk->ppm), 1);
   modem_probe_samp_f("t_rx_timing", &(rx_timing), 1);
+
+  FREE(tmax);
+  FREE(f_int);
+  FREE(t);
 }
 
 /*---------------------------------------------------------------------------*\
diff --git a/src/gp_interleaver.c b/src/gp_interleaver.c
index 70b8ad0..b7c7010 100644
--- a/src/gp_interleaver.c
+++ b/src/gp_interleaver.c
@@ -29,6 +29,7 @@
 */
 
 #include "gp_interleaver.h"
+#include "debug_alloc.h"
 
 #include <assert.h>
 #include <math.h>
@@ -101,7 +102,8 @@ void gp_deinterleave_float(float frame[], float interleaved_frame[],
 // The above work on complex numbers (e.g. OFDM symbols), so the below work on
 // groups of two bits at a time to remain compatible with the above.
 void gp_interleave_bits(char interleaved_frame[], char frame[], int Nbits) {
-  char temp[Nbits];
+  char *temp = (char *)MALLOC(Nbits);
+  assert(temp != NULL);
   int b = choose_interleaver_b(Nbits);
   int i, j;
 
@@ -114,10 +116,13 @@ void gp_interleave_bits(char interleaved_frame[], char frame[], int Nbits) {
     interleaved_frame[i * 2] = temp[i] >> 1;
     interleaved_frame[i * 2 + 1] = temp[i] & 1;
   }
+
+  FREE(temp);
 }
 
 void gp_deinterleave_bits(char frame[], char interleaved_frame[], int Nbits) {
-  char temp[Nbits];
+  char *temp = (char *)MALLOC(Nbits);
+  assert(temp != NULL);
   int b = choose_interleaver_b(Nbits);
   int i, j;
 
@@ -131,4 +136,6 @@ void gp_deinterleave_bits(char frame[], char interleaved_frame[], int Nbits) {
     frame[i * 2] = temp[i] >> 1;
     frame[i * 2 + 1] = temp[i] & 1;
   }
+
+  FREE(temp);
 }
diff --git a/src/interldpc.c b/src/interldpc.c
index b94f711..6c783dc 100644
--- a/src/interldpc.c
+++ b/src/interldpc.c
@@ -35,6 +35,7 @@
 #include <string.h>
 
 #include "gp_interleaver.h"
+#include "debug_alloc.h"
 #include "mpdecode_core.h"
 #include "ofdm_internal.h"
 
@@ -87,11 +88,15 @@ void ldpc_mode_specific_setup(struct OFDM *ofdm, struct LDPC *ldpc) {
    selected FEC protection scheme */
 void ldpc_encode_frame(struct LDPC *ldpc, int codeword[],
                        unsigned char tx_bits_char[]) {
-  unsigned char pbits[ldpc->NumberParityBits];
+  unsigned char *pbits =
+      (unsigned char *)MALLOC(ldpc->NumberParityBits);
+  assert(pbits != NULL);
   int codec_frame;
   int i, j;
 
-  unsigned char tx_bits_char_padded[ldpc->ldpc_data_bits_per_frame];
+  unsigned char *tx_bits_char_padded =
+      (unsigned char *)MALLOC(ldpc->ldpc_data_bits_per_frame);
+  assert(tx_bits_char_padded != NULL);
 
   switch (ldpc->protection_mode) {
     case LDPC_PROT_EQUAL:
@@ -134,6 +139,9 @@ void ldpc_encode_frame(struct LDPC *ldpc, int codeword[],
      bits, we don't bother sending unused (known) data bits */
   for (i = 0; i < ldpc->data_bits_per_frame; i++) codeword[i] = tx_bits_char[i];
   for (j = 0; j < ldpc->NumberParityBits; i++, j++) codeword[i] = pbits[j];
+
+  FREE(tx_bits_char_padded);
+  FREE(pbits);
 }
 
 void qpsk_modulate_frame(COMP tx_symbols[], int codeword[], int n) {
@@ -153,10 +161,14 @@ void qpsk_modulate_frame(COMP tx_symbols[], int codeword[], int n) {
 /* run LDPC decoder, taking into account the FEC protection scheme */
 void ldpc_decode_frame(struct LDPC *ldpc, int *parityCheckCount, int *iter,
                        uint8_t out_char[], float llr[]) {
-  float llr_full_codeword[ldpc->ldpc_coded_bits_per_frame];
+  float *llr_full_codeword =
+      (float *)MALLOC(sizeof(float) * ldpc->ldpc_coded_bits_per_frame);
+  assert(llr_full_codeword != NULL);
   int unused_data_bits =
       ldpc->ldpc_data_bits_per_frame - ldpc->data_bits_per_frame;
-  uint8_t out_char_ldpc[ldpc->coded_bits_per_frame];
+  uint8_t *out_char_ldpc =
+      (uint8_t *)MALLOC(ldpc->coded_bits_per_frame);
+  assert(out_char_ldpc != NULL);
   int i, j;
   int codec_frame;
 
@@ -216,6 +228,9 @@ void ldpc_decode_frame(struct LDPC *ldpc, int *parityCheckCount, int *iter,
     default:
       assert(0);
   }
+
+  FREE(out_char_ldpc);
+  FREE(llr_full_codeword);
 }
 
 /* Count uncoded (raw) bit errors over frame, note we don't include UW
@@ -228,13 +243,21 @@ int count_uncoded_errors(struct LDPC *ldpc, struct OFDM_CONFIG *config,
   int coded_syms_per_frame = ldpc->coded_bits_per_frame / config->bps;
   int coded_bits_per_frame = ldpc->coded_bits_per_frame;
   int data_bits_per_frame = ldpc->data_bits_per_frame;
-  int rx_bits_raw[coded_bits_per_frame];
+  int *rx_bits_raw =
+      (int *)MALLOC(sizeof(int) * coded_bits_per_frame);
+  assert(rx_bits_raw != NULL);
 
   /* generate test codeword from known payload data bits */
 
-  int test_codeword[coded_bits_per_frame];
-  uint16_t r[data_bits_per_frame];
-  uint8_t tx_bits[data_bits_per_frame];
+  int *test_codeword =
+      (int *)MALLOC(sizeof(int) * coded_bits_per_frame);
+  uint16_t *r =
+      (uint16_t *)MALLOC(sizeof(uint16_t) * data_bits_per_frame);
+  uint8_t *tx_bits =
+      (uint8_t *)MALLOC(data_bits_per_frame);
+  assert(test_codeword != NULL);
+  assert(r != NULL);
+  assert(tx_bits != NULL);
 
   ofdm_rand(r, data_bits_per_frame);
 
@@ -264,6 +287,10 @@ int count_uncoded_errors(struct LDPC *ldpc, struct OFDM_CONFIG *config,
     if (test_codeword[i] != rx_bits_raw[i]) Nerrs++;
   }
 
+  FREE(tx_bits);
+  FREE(r);
+  FREE(test_codeword);
+  FREE(rx_bits_raw);
   return Nerrs;
 }
 
@@ -325,10 +352,19 @@ void ofdm_ldpc_interleave_tx(struct OFDM *ofdm, struct LDPC *ldpc,
   int Npayloadsymsperpacket = ldpc->coded_bits_per_frame / ofdm->bps;
   int Npayloadbitsperpacket = ldpc->coded_bits_per_frame;
   int Nbitsperpacket = ofdm_get_bits_per_packet(ofdm);
-  int codeword[Npayloadbitsperpacket];
-  COMP payload_symbols[Npayloadsymsperpacket];
-  COMP payload_symbols_inter[Npayloadsymsperpacket];
-  complex float tx_symbols[Nbitsperpacket / ofdm->bps];
+  int Nsymsperpacket = Nbitsperpacket / ofdm->bps;
+  int *codeword =
+      (int *)MALLOC(sizeof(int) * Npayloadbitsperpacket);
+  COMP *payload_symbols =
+      (COMP *)MALLOC(sizeof(COMP) * Npayloadsymsperpacket);
+  COMP *payload_symbols_inter =
+      (COMP *)MALLOC(sizeof(COMP) * Npayloadsymsperpacket);
+  complex float *tx_symbols =
+      (complex float *)MALLOC(sizeof(complex float) * Nsymsperpacket);
+  assert(codeword != NULL);
+  assert(payload_symbols != NULL);
+  assert(payload_symbols_inter != NULL);
+  assert(tx_symbols != NULL);
 
   ldpc_encode_frame(ldpc, codeword, tx_bits);
   qpsk_modulate_frame(payload_symbols, codeword, Npayloadsymsperpacket);
@@ -337,4 +373,9 @@ void ofdm_ldpc_interleave_tx(struct OFDM *ofdm, struct LDPC *ldpc,
   ofdm_assemble_qpsk_modem_packet_symbols(ofdm, tx_symbols,
                                           payload_symbols_inter, txt_bits);
   ofdm_txframe(ofdm, tx_sams, tx_symbols);
+
+  FREE(tx_symbols);
+  FREE(payload_symbols_inter);
+  FREE(payload_symbols);
+  FREE(codeword);
 }
diff --git a/src/lsp.c b/src/lsp.c
index aa7bac3..926fb80 100644
--- a/src/lsp.c
+++ b/src/lsp.c
@@ -35,6 +35,7 @@
 #include <stdlib.h>
 
 #include "defines.h"
+#include "lpc.h"
 
 /*---------------------------------------------------------------------------*\
 
@@ -92,8 +93,10 @@ static float cheb_poly_eva(float *coef, float x, int order)
 /*  int order 		order of the polynomial 			*/
 {
   int i;
+
+  assert(order <= LPC_MAX_ORDER);
   float *t, *u, *v, sum;
-  float T[(order / 2) + 1];
+  float T[(LPC_MAX_ORDER / 2) + 1];
 
   /* Initialise pointers */
 
@@ -145,8 +148,10 @@ int lpc_to_lsp(float *a, int order, float *freq, int nb, float delta)
   float *pt;     /* ptr used for cheb_poly_eval()
                     whether P' or Q' 			*/
   int roots = 0; /* number of roots found 	        */
-  float Q[order + 1];
-  float P[order + 1];
+
+  assert(order <= LPC_MAX_ORDER);
+  float Q[LPC_MAX_ORDER + 1];
+  float P[LPC_MAX_ORDER + 1];
 
   flag = 1;
   m = order / 2; /* order of P'(z) & Q'(z) polynimials 	*/
@@ -262,8 +267,10 @@ void lsp_to_lpc(float *lsp, float *ak, int order)
   int i, j;
   float xout1, xout2, xin1, xin2;
   float *pw, *n1, *n2, *n3, *n4 = 0;
-  float freq[order];
-  float Wp[(order * 4) + 2];
+
+  assert(order <= LPC_MAX_ORDER);
+  float freq[LPC_MAX_ORDER];
+  float Wp[(LPC_MAX_ORDER * 4) + 2];
 
   /* convert from radians to the x=cos(w) domain */
 
diff --git a/src/mpdecode_core.c b/src/mpdecode_core.c
index 5374255..cf13ac3 100644
--- a/src/mpdecode_core.c
+++ b/src/mpdecode_core.c
@@ -596,7 +596,9 @@ void Somap(float bit_likelihood[],    /* number_bits, bps*number_symbols */
            int bps,                   /* bits per symbol                 */
            int number_symbols) {
   int n, i, j, k, mask;
-  float num[bps], den[bps];
+  float *num = (float *)MALLOC(sizeof(float) * bps);
+  float *den = (float *)MALLOC(sizeof(float) * bps);
+  assert(num && den);
   float metric;
 
   for (n = 0; n < number_symbols; n++) { /* loop over symbols */
@@ -604,6 +606,7 @@ void Somap(float bit_likelihood[],    /* number_bits, bps*number_symbols */
       /* initialize */
       num[k] = -1000000;
       den[k] = -1000000;
+
     }
 
     for (i = 0; i < M; i++) {
@@ -631,14 +634,20 @@ void Somap(float bit_likelihood[],    /* number_bits, bps*number_symbols */
       bit_likelihood[bps * n + k] = num[k] - den[k];
     }
   }
+
+  FREE(num);
+  FREE(den);
 }
 
 void symbols_to_llrs(float llr[], COMP rx_qpsk_symbols[], float rx_amps[],
                      float EsNo, float mean_amp, int nsyms) {
   int i;
 
-  float symbol_likelihood[nsyms * QPSK_CONSTELLATION_SIZE];
-  float bit_likelihood[nsyms * QPSK_BITS_PER_SYMBOL];
+  int symbol_len = nsyms * QPSK_CONSTELLATION_SIZE;
+  float *symbol_likelihood = (float *)MALLOC(sizeof(float) * symbol_len);
+  int bit_len = nsyms * QPSK_BITS_PER_SYMBOL;
+  float *bit_likelihood = (float *)MALLOC(sizeof(float) * bit_len);
+  assert(symbol_likelihood && bit_likelihood);
 
   Demod2D(symbol_likelihood, rx_qpsk_symbols, S_matrix, EsNo, rx_amps, mean_amp,
           nsyms);
@@ -646,7 +655,11 @@ void symbols_to_llrs(float llr[], COMP rx_qpsk_symbols[], float rx_amps[],
         QPSK_BITS_PER_SYMBOL, nsyms);
   for (i = 0; i < nsyms * QPSK_BITS_PER_SYMBOL; i++) {
     llr[i] = -bit_likelihood[i];
+
   }
+
+  FREE(symbol_likelihood);
+  FREE(bit_likelihood);
 }
 
 /*
@@ -724,14 +737,21 @@ void fsk_rx_filt_to_llrs(float llr[], float rx_filt[], float v_est,
                          float SNRest, int M, int nsyms) {
   int i;
   int bps = log2(M);
-  float symbol_likelihood[M * nsyms];
-  float bit_likelihood[bps * nsyms];
+  int symbol_len = M * nsyms;
+  float *symbol_likelihood = (float *)MALLOC(sizeof(float) * symbol_len);
+  int bit_len = bps * nsyms;
+  float *bit_likelihood = (float *)MALLOC(sizeof(float) * bit_len);
+  assert(symbol_likelihood && bit_likelihood);
 
   FskDemod(symbol_likelihood, rx_filt, v_est, SNRest, M, nsyms);
   Somap(bit_likelihood, symbol_likelihood, M, bps, nsyms);
   for (i = 0; i < bps * nsyms; i++) {
     llr[i] = -bit_likelihood[i];
+
   }
+
+  FREE(symbol_likelihood);
+  FREE(bit_likelihood);
 }
 
 void ldpc_print_info(struct LDPC *ldpc) {
diff --git a/src/newamp1.c b/src/newamp1.c
index 3ba2de0..e5a80bc 100644
--- a/src/newamp1.c
+++ b/src/newamp1.c
@@ -171,13 +171,14 @@ float rate_K_mbest_encode(int *indexes, float *x, float *xq, int ndim,
   const float *codebook1 = newamp1vq_cb[0].cb;
   const float *codebook2 = newamp1vq_cb[1].cb;
   struct MBEST *mbest_stage1, *mbest_stage2;
-  float target[ndim];
+  float target[NEWAMP1_K];
   int index[MBEST_STAGES];
   float mse, tmp;
 
   /* codebook is compiled for a fixed K */
 
   assert(ndim == newamp1vq_cb[0].k);
+  assert(ndim <= NEWAMP1_K);
 
   mbest_stage1 = mbest_create(mbest_entries);
   mbest_stage2 = mbest_create(mbest_entries);
@@ -364,7 +365,11 @@ void determine_phase(C2CONST *c2const, COMP H[], MODEL *model, int Nfft,
                      codec2_fft_cfg fwd_cfg, codec2_fft_cfg inv_cfg) {
   int i, m, b;
   int Ns = Nfft / 2 + 1;
-  float Gdbfk[Ns], sample_freqs_kHz[Ns], phase[Ns];
+  assert(Nfft <= NEWAMP1_PHASE_NFFT);
+  assert(Ns <= NEWAMP1_PHASE_NFFT / 2 + 1);
+  float Gdbfk[NEWAMP1_PHASE_NFFT / 2 + 1];
+  float sample_freqs_kHz[NEWAMP1_PHASE_NFFT / 2 + 1];
+  float phase[NEWAMP1_PHASE_NFFT / 2 + 1];
   float AmdB[MAX_AMP + 1], rate_L_sample_freqs_kHz[MAX_AMP + 1];
 
   for (m = 1; m <= model->L; m++) {
@@ -404,7 +409,10 @@ void determine_autoc(C2CONST *c2const, float Rk[], int order, MODEL *model,
                      int Nfft, codec2_fft_cfg fwd_cfg, codec2_fft_cfg inv_cfg) {
   int i, m;
   int Ns = Nfft / 2 + 1;
-  float Gdbfk[Ns], sample_freqs_kHz[Ns];
+  assert(Nfft <= NEWAMP1_PHASE_NFFT);
+  assert(Ns <= NEWAMP1_PHASE_NFFT / 2 + 1);
+  float Gdbfk[NEWAMP1_PHASE_NFFT / 2 + 1];
+  float sample_freqs_kHz[NEWAMP1_PHASE_NFFT / 2 + 1];
   float AmdB[MAX_AMP + 1], rate_L_sample_freqs_kHz[MAX_AMP + 1];
 
   /* interpolate in the log domain */
@@ -422,7 +430,7 @@ void determine_autoc(C2CONST *c2const, float Rk[], int order, MODEL *model,
   interp_para(Gdbfk, &rate_L_sample_freqs_kHz[1], &AmdB[1], model->L,
               sample_freqs_kHz, Ns);
 
-  COMP S[Nfft], R[Nfft];
+  COMP S[NEWAMP1_PHASE_NFFT], R[NEWAMP1_PHASE_NFFT];
 
   /* install negative frequency components, convert to mag squared of spectrum
    */
diff --git a/src/ofdm.c b/src/ofdm.c
index 953179f..8b7eb08 100644
--- a/src/ofdm.c
+++ b/src/ofdm.c
@@ -98,6 +98,7 @@ static float cnormf(complex float val) {
   float imagf = cimagf(val);
 
   return realf * realf + imagf * imagf;
+
 }
 
 /*
@@ -796,7 +797,9 @@ static int est_timing(struct OFDM *ofdm, complex float *rx, int length,
                       int step) {
   complex float corr_st, corr_en;
   int Ncorr = length - (ofdm->samplesperframe + ofdm->samplespersymbol);
-  float corr[Ncorr];
+  assert(Ncorr > 0);
+  float *corr = (float *)MALLOC(sizeof(float) * Ncorr);
+  assert(corr != NULL);
   int i, j;
   float acc = 0.0f;
 
@@ -813,7 +816,9 @@ static int est_timing(struct OFDM *ofdm, complex float *rx, int length,
   PROFILE_VAR(wvecpilot);
   PROFILE_SAMPLE(wvecpilot);
 
-  complex float wvec_pilot[ofdm->samplespersymbol];
+  complex float *wvec_pilot =
+      (complex float *)MALLOC(sizeof(complex float) * ofdm->samplespersymbol);
+  assert(wvec_pilot != NULL);
 
   switch (fcoarse) {
     case -40:
@@ -919,6 +924,8 @@ static int est_timing(struct OFDM *ofdm, complex float *rx, int length,
             (double)av_level, (double)*timing_mx, timing_est, *timing_valid);
   }
 
+  FREE(wvec_pilot);
+  FREE(corr);
   return timing_est;
 }
 
@@ -937,7 +944,9 @@ static float est_freq_offset_pilot_corr(struct OFDM *ofdm, complex float *rx,
   /* precompute the freq shift multiplied by pilot samples outside of main loop
    */
 
-  complex float wvec_pilot[ofdm->samplespersymbol];
+  complex float *wvec_pilot =
+      (complex float *)MALLOC(sizeof(complex float) * ofdm->samplespersymbol);
+  assert(wvec_pilot != NULL);
   int j;
 
   switch (fcoarse) {
@@ -993,6 +1002,7 @@ static float est_freq_offset_pilot_corr(struct OFDM *ofdm, complex float *rx,
             (double)foff_est);
   }
 
+  FREE(wvec_pilot);
   return foff_est;
 }
 
@@ -1003,66 +1013,65 @@ static float est_freq_offset_pilot_corr(struct OFDM *ofdm, complex float *rx,
  */
 void ofdm_txframe(struct OFDM *ofdm, complex float *tx,
                   complex float *tx_sym_lin) {
-  complex float aframe[ofdm->np * ofdm->ns][ofdm->nc + 2];
-  complex float asymbol[ofdm->m];
-  complex float asymbol_cp[ofdm->samplespersymbol];
+  int rows = ofdm->np * ofdm->ns;
+  int cols = ofdm->nc + 2;
+  complex float *aframe =
+      (complex float *)MALLOC(sizeof(complex float) * rows * cols);
+  complex float *asymbol =
+      (complex float *)MALLOC(sizeof(complex float) * ofdm->m);
+  complex float *asymbol_cp =
+      (complex float *)MALLOC(sizeof(complex float) * ofdm->samplespersymbol);
+  assert(aframe && asymbol && asymbol_cp);
   int i, j, k, m;
 
   /* initialize aframe to complex zero */
-
-  for (i = 0; i < (ofdm->np * ofdm->ns); i++) {
-    for (j = 0; j < (ofdm->nc + 2); j++) {
-      aframe[i][j] = 0.0f;
+  for (i = 0; i < rows; i++) {
+    for (j = 0; j < cols; j++) {
+      aframe[i * cols + j] = 0.0f;
     }
   }
 
-  /*
-   * Place symbols in multi-carrier frame with pilots
-   * This will place boundary values of complex zero around data
-   */
+  /* Place symbols in multi-carrier frame with pilots */
   int s = 0;
-  for (int r = 0; r < ofdm->np * ofdm->ns; r++) {
+  for (int r = 0; r < rows; r++) {
     if ((r % ofdm->ns) == 0) {
-      /* copy in a row of complex pilots to first row of each frame */
-      for (i = 0; i < (ofdm->nc + 2); i++) {
-        aframe[r][i] = ofdm->pilots[i];
+      for (i = 0; i < cols; i++) {
+        aframe[r * cols + i] = ofdm->pilots[i];
       }
     } else {
-      /* copy in the Nc complex data symbols with [0 Nc 0] or (Nc + 2) total */
       for (j = 1; j < (ofdm->nc + 1); j++) {
-        aframe[r][j] = tx_sym_lin[s++];
+        aframe[r * cols + j] = tx_sym_lin[s++];
         if (ofdm->dpsk_en == true) {
-          aframe[r][j] *= aframe[r - 1][j];
+          aframe[r * cols + j] *= aframe[(r - 1) * cols + j];
         }
       }
     }
   }
 
   /* OFDM up-convert symbol by symbol so we can add CP */
-
-  for (i = 0, m = 0; i < (ofdm->np * ofdm->ns);
-       i++, m += ofdm->samplespersymbol) {
-    idft(ofdm, asymbol, aframe[i]);
+  for (i = 0, m = 0; i < rows; i++, m += ofdm->samplespersymbol) {
+    idft(ofdm, asymbol, &aframe[i * cols]);
 
     /* Copy the last Ncp samples to the front */
-
     for (j = (ofdm->m - ofdm->ncp), k = 0; j < ofdm->m; j++, k++) {
       asymbol_cp[k] = asymbol[j];
     }
 
     /* Now copy the all samples for this row after it */
-
     for (j = ofdm->ncp, k = 0; k < ofdm->m; j++, k++) {
       asymbol_cp[j] = asymbol[k];
     }
 
     /* Now move row to the tx output */
-
     for (j = 0; j < ofdm->samplespersymbol; j++) {
       tx[m + j] = asymbol_cp[j];
     }
   }
 
+  FREE(aframe);
+  FREE(asymbol);
+  FREE(asymbol_cp);
+
   size_t samplesperpacket = ofdm->np * ofdm->samplesperframe;
   ofdm_hilbert_clipper(ofdm, tx, samplesperpacket);
 }
@@ -1082,10 +1091,13 @@ void ofdm_hilbert_clipper(struct OFDM *ofdm, complex float *tx, size_t n) {
   /* BPF to remove out of band energy clipper introduces */
   if (ofdm->tx_bpf_en) {
     assert(ofdm->tx_bpf != NULL);
-    complex float tx_filt[n];
+    complex float *tx_filt =
+        (complex float *)MALLOC(sizeof(complex float) * n);
+    assert(tx_filt != NULL);
 
     quisk_ccfFilter(tx, tx_filt, n, ofdm->tx_bpf);
     memmove(tx, tx_filt, n * sizeof(complex float));
+    FREE(tx_filt);
   }
 
   /* BPF messes up peak levels, this gain gets back to approx OFDM_PEAK */
@@ -1177,7 +1189,9 @@ void ofdm_mod(struct OFDM *ofdm, COMP *result, const int *tx_bits) {
   int length = ofdm->bitsperpacket / ofdm->bps;
   complex float *tx =
       (complex float *)result;  // complex has same memory layout
-  complex float tx_sym_lin[length];
+  complex float *tx_sym_lin =
+      (complex float *)MALLOC(sizeof(complex float) * length);
+  assert(tx_sym_lin != NULL);
   int dibit[2];
   int s, i;
 
@@ -1199,6 +1213,7 @@ void ofdm_mod(struct OFDM *ofdm, COMP *result, const int *tx_bits) {
   } /* else if (ofdm->bps == 3) { } TODO */
 
   ofdm_txframe(ofdm, tx, tx_sym_lin);
+  FREE(tx_sym_lin);
 }
 
 /*
@@ -1259,9 +1274,11 @@ static float est_timing_and_freq(struct OFDM *ofdm, int *t_est, float *foff_est,
   float max_corr = 0;
   *t_est = 0;
   *foff_est = 0.0;
+  complex float *mvec =
+      (complex float *)MALLOC(sizeof(complex float) * Npsam);
+  assert(mvec != NULL);
   for (float afcoarse = fmin; afcoarse <= fmax; afcoarse += fstep) {
     float w = TAU * afcoarse / ofdm->fs;
-    complex float mvec[Npsam];
     for (int i = 0; i < Npsam; i++) {
       complex float ph = cmplx(w * i);
       mvec[i] = conjf(known_samples[i] * ph);
@@ -1289,7 +1306,9 @@ static float est_timing_and_freq(struct OFDM *ofdm, int *t_est, float *foff_est,
             (double)timing_mx, (double)*foff_est);
   }
 
+  FREE(mvec);
   return timing_mx;
+
 }
 
 /* Two stage burst mode acquisition  */
@@ -1553,7 +1572,10 @@ static void ofdm_demod_core(struct OFDM *ofdm, int *rx_bits) {
     en = st + ofdm->samplesperframe - 1 + ofdm->samplespersymbol +
          ofdm->ftwindowwidth;
 
-    complex float work[(en - st)];
+    int work_len = en - st;
+    complex float *work =
+        (complex float *)MALLOC(sizeof(complex float) * work_len);
+    assert(work != NULL);
 
     /*
      * Adjust for the frequency error by shifting the phase
@@ -1564,8 +1586,13 @@ static void ofdm_demod_core(struct OFDM *ofdm, int *rx_bits) {
     }
 
     int ft_est = est_timing(ofdm, work, (en - st), 0.0f, &ofdm->timing_mx,
+
                             &ofdm->timing_valid, 1);
 
+  FREE(aphase_est_pilot);
+  FREE(aamp_est_pilot);
+    FREE(work);
+
     ofdm->timing_est += ft_est - (int)ceilf((float)ofdm->ftwindowwidth / 2) + 1;
 
     if (ofdm->verbose > 2) {
@@ -1631,7 +1658,9 @@ static void ofdm_demod_core(struct OFDM *ofdm, int *rx_bits) {
   st = ofdm->rxbufst + ofdm->samplespersymbol + 1 + ofdm->sample_point;
   en = st + ofdm->m;
 
-  complex float work[ofdm->m];
+  complex float *work =
+      (complex float *)MALLOC(sizeof(complex float) * ofdm->m);
+  assert(work != NULL);
 
   /* down-convert at current timing instant------------------------------- */
 
@@ -1771,8 +1800,12 @@ static void ofdm_demod_core(struct OFDM *ofdm, int *rx_bits) {
   /* OK - now estimate and correct pilot phase  -------------------------- */
 
   complex float aphase_est_pilot_rect;
-  float aphase_est_pilot[ofdm->nc + 2];
-  float aamp_est_pilot[ofdm->nc + 2];
+  int pilot_len = ofdm->nc + 2;
+  float *aphase_est_pilot =
+      (float *)MALLOC(sizeof(float) * pilot_len);
+  float *aamp_est_pilot =
+      (float *)MALLOC(sizeof(float) * pilot_len);
+  assert(aphase_est_pilot && aamp_est_pilot);
 
   for (i = 0; i < (ofdm->nc + 2); i++) {
     aphase_est_pilot[i] = 10.0f;
@@ -1959,6 +1992,10 @@ static void ofdm_demod_core(struct OFDM *ofdm, int *rx_bits) {
     ofdm->rxbufst = rxbufst_next;
     ofdm->nin = 0;
   }
+
+  FREE(aphase_est_pilot);
+  FREE(aamp_est_pilot);
+  FREE(work);
 }
 
 /*
@@ -2579,7 +2616,8 @@ void ofdm_rand_seed(uint16_t r[], int n, uint64_t seed) {
 }
 
 void ofdm_generate_payload_data_bits(uint8_t payload_data_bits[], int n) {
-  uint16_t r[n];
+  uint16_t *r = (uint16_t *)MALLOC(sizeof(uint16_t) * n);
+  assert(r != NULL);
   int i;
 
   ofdm_rand(r, n);
@@ -2587,6 +2625,8 @@ void ofdm_generate_payload_data_bits(uint8_t payload_data_bits[], int n) {
   for (i = 0; i < n; i++) {
     payload_data_bits[i] = r[i] > 16384;
   }
+
+  FREE(r);
 }
 
 void ofdm_generate_preamble(struct OFDM *ofdm, COMP *tx_preamble, int seed) {
@@ -2596,9 +2636,12 @@ void ofdm_generate_preamble(struct OFDM *ofdm, COMP *tx_preamble, int seed) {
   memcpy(&ofdm_preamble, ofdm, sizeof(struct OFDM));
   ofdm_preamble.np = 1;
   ofdm_preamble.bitsperpacket = ofdm_preamble.bitsperframe;
-  uint16_t r[ofdm_preamble.bitsperpacket];
+  int preamble_len = ofdm_preamble.bitsperpacket;
+  uint16_t *r = (uint16_t *)MALLOC(sizeof(uint16_t) * preamble_len);
+  assert(r != NULL);
   ofdm_rand_seed(r, ofdm_preamble.bitsperpacket, seed);
-  int preamble_bits[ofdm_preamble.bitsperpacket];
+  int *preamble_bits = (int *)MALLOC(sizeof(int) * preamble_len);
+  assert(preamble_bits != NULL);
   for (int i = 0; i < ofdm_preamble.bitsperpacket; i++)
     preamble_bits[i] = r[i] > 16384;
   // ensures the signal passes through hilbert clipper unchanged
@@ -2606,6 +2649,8 @@ void ofdm_generate_preamble(struct OFDM *ofdm, COMP *tx_preamble, int seed) {
   ofdm_preamble.tx_bpf_en = false;
   ofdm_preamble.clip_en = false;
   ofdm_mod(&ofdm_preamble, tx_preamble, preamble_bits);
+  FREE(r);
+  FREE(preamble_bits);
 }
 
 void ofdm_print_info(struct OFDM *ofdm) {
diff --git a/src/phase.c b/src/phase.c
index dec8793..6104b2d 100644
--- a/src/phase.c
+++ b/src/phase.c
@@ -33,6 +33,8 @@
 #include <stdlib.h>
 #include <string.h>
 
+#include "debug_alloc.h"
+
 #include "comp.h"
 #include "comp_prim.h"
 #include "defines.h"
@@ -225,7 +227,11 @@ void mag_to_phase(
     float phase[], /* Nfft/2+1 output phase samples in radians       */
     float Gdbfk[], /* Nfft/2+1 positive freq amplitudes samples in dB */
     int Nfft, codec2_fft_cfg fft_fwd_cfg, codec2_fft_cfg fft_inv_cfg) {
-  COMP Sdb[Nfft], c[Nfft], cf[Nfft], Cf[Nfft];
+  COMP *Sdb = (COMP *)MALLOC(sizeof(COMP) * Nfft);
+  COMP *c = (COMP *)MALLOC(sizeof(COMP) * Nfft);
+  COMP *cf = (COMP *)MALLOC(sizeof(COMP) * Nfft);
+  COMP *Cf = (COMP *)MALLOC(sizeof(COMP) * Nfft);
+  assert(Sdb && c && cf && Cf);
   int Ns = Nfft / 2 + 1;
   int i;
 
@@ -272,4 +278,9 @@ void mag_to_phase(
   for (i = 0; i < Ns; i++) {
     phase[i] = Cf[i].imag / scale;
   }
+
+  FREE(Sdb);
+  FREE(c);
+  FREE(cf);
+  FREE(Cf);
 }
diff --git a/src/quantise.c b/src/quantise.c
index da1d821..56bfffd 100644
--- a/src/quantise.c
+++ b/src/quantise.c
@@ -121,11 +121,13 @@ long quantise(const float *cb, float vec[], float w[], int k, int m, float *se)
 
 void encode_lspds_scalar(int indexes[], float lsp[], int order) {
   int i, k, m;
-  float lsp_hz[order];
-  float lsp__hz[order];
-  float dlsp[order];
-  float dlsp_[order];
-  float wt[order];
+
+  assert(order <= LPC_MAX_ORDER);
+  float lsp_hz[LPC_MAX_ORDER];
+  float lsp__hz[LPC_MAX_ORDER];
+  float dlsp[LPC_MAX_ORDER];
+  float dlsp_[LPC_MAX_ORDER];
+  float wt[LPC_MAX_ORDER];
   const float *cb;
   float se;
 
@@ -162,8 +164,10 @@ void encode_lspds_scalar(int indexes[], float lsp[], int order) {
 
 void decode_lspds_scalar(float lsp_[], int indexes[], int order) {
   int i, k;
-  float lsp__hz[order];
-  float dlsp_[order];
+
+  assert(order <= LPC_MAX_ORDER);
+  float lsp__hz[LPC_MAX_ORDER];
+  float dlsp_[LPC_MAX_ORDER];
   const float *cb;
 
   for (i = 0; i < order; i++) {
@@ -230,8 +234,10 @@ int find_nearest_weighted(const float *codebook, int nb_entries, float *x,
 
 void lspjmv_quantise(float *x, float *xq, int order) {
   int i, n1, n2, n3;
-  float err[order], err2[order], err3[order];
-  float w[order], w2[order], w3[order];
+
+  assert(order <= LPC_MAX_ORDER);
+  float err[LPC_MAX_ORDER], err2[LPC_MAX_ORDER], err3[LPC_MAX_ORDER];
+  float w[LPC_MAX_ORDER], w2[LPC_MAX_ORDER], w3[LPC_MAX_ORDER];
   const float *codebook1 = lsp_cbjmv[0].cb;
   const float *codebook2 = lsp_cbjmv[1].cb;
   const float *codebook3 = lsp_cbjmv[2].cb;
@@ -653,8 +659,11 @@ float decode_log_Wo(C2CONST *c2const, int index, int bits) {
 float speech_to_uq_lsps(float lsp[], float ak[], float Sn[], float w[],
                         int m_pitch, int order) {
   int i, roots;
-  float Wn[m_pitch];
-  float R[order + 1];
+
+  assert(order <= LPC_MAX_ORDER);
+  float *Wn = (float *)malloc(sizeof(float) * m_pitch);
+  assert(Wn != NULL);
+  float R[LPC_MAX_ORDER + 1];
   float e, E;
 
   e = 0.0;
@@ -667,6 +676,7 @@ float speech_to_uq_lsps(float lsp[], float ak[], float Sn[], float w[],
 
   if (e == 0.0) {
     for (i = 0; i < order; i++) lsp[i] = (PI / order) * (float)i;
+    free(Wn);
     return 0.0;
   }
 
@@ -689,6 +699,7 @@ float speech_to_uq_lsps(float lsp[], float ak[], float Sn[], float w[],
     for (i = 0; i < order; i++) lsp[i] = (PI / order) * (float)i;
   }
 
+  free(Wn);
   return E;
 }
 
@@ -705,8 +716,10 @@ float speech_to_uq_lsps(float lsp[], float ak[], float Sn[], float w[],
 
 void encode_lsps_scalar(int indexes[], float lsp[], int order) {
   int i, k, m;
+
+  assert(order <= LPC_MAX_ORDER);
   float wt[1];
-  float lsp_hz[order];
+  float lsp_hz[LPC_MAX_ORDER];
   const float *cb;
   float se;
 
@@ -739,7 +752,9 @@ void encode_lsps_scalar(int indexes[], float lsp[], int order) {
 
 void decode_lsps_scalar(float lsp[], int indexes[], int order) {
   int i, k;
-  float lsp_hz[order];
+
+  assert(order <= LPC_MAX_ORDER);
+  float lsp_hz[LPC_MAX_ORDER];
   const float *cb;
 
   for (i = 0; i < order; i++) {
@@ -765,8 +780,10 @@ void decode_lsps_scalar(float lsp[], int indexes[], int order) {
 
 void encode_lsps_vq(int *indexes, float *x, float *xq, int order) {
   int i, n1, n2, n3;
-  float err[order], err2[order], err3[order];
-  float w[order], w2[order], w3[order];
+
+  assert(order <= LPC_MAX_ORDER);
+  float err[LPC_MAX_ORDER], err2[LPC_MAX_ORDER], err3[LPC_MAX_ORDER];
+  float w[LPC_MAX_ORDER], w2[LPC_MAX_ORDER], w3[LPC_MAX_ORDER];
   const float *codebook1 = lsp_cbjmv[0].cb;
   const float *codebook2 = lsp_cbjmv[1].cb;
   const float *codebook3 = lsp_cbjmv[2].cb;
